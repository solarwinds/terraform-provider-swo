# APM entity extension for Host
type APMHostExtension {
  # Host Id
  hostId: String!

  # Host Name
  hostname: String!

  # Entity name
  name: String

  # Original host name. User can add hostname alias in the config of instrumentation lib (which will override observed value). This attribute is used to represent observed/polled name.
  originalHostname: String

  # os description
  osDescription: String

  # Os name
  osName: String

  # Os type
  osType: String

  # Os version
  osVersion: String

  # Trace service host error
  traceServiceHostErrors: Metric!

  # Trace service host request
  traceServiceHostRequests: Metric!

  # Trace service host response time
  traceServiceHostResponseTime: Metric!
}

input ActiveAlertsFilterInput {
  # Activity within time range in minutes
  activeTimeRangeInMinutes: AlertIntRangeInput

  # List of condition types
  conditionTypes: [ConditionType!]

  # List of parent Alert definition IDs
  definitionIds: [String!]

  # List of entity IDs
  entityIds: [String!]

  # List of entity types
  entityTypes: [String!]

  # Alert filter expression
  filter: AlertFilterExpressionInput

  # Mute status
  muted: Boolean

  # String used to search in Alert definition name or Entity display name
  searchString: String

  # List of parent Alert definition severities
  severities: [AlertSeverity!]
}

type AgentInstallAlternativeMethod {
  command: String
  linkAddress: String
  packageManager: AgentInstallPackageManager
}

type AgentInstallInstruction {
  alternativeMethods: [AgentInstallAlternativeMethod!]
  instrumentedMethod: AgentInstallInstrumentedMethod
  script: String
  sessionId: ID!
}

type AgentInstallInstrumentedMethod {
  ansibleLink: String
  chefLink: String
  metadata: String
  swoUrl: String
  token: String
}

enum AgentInstallPackageManager {
  DNF
  DPKG
  RPM
  UNSPECIFIED
  YUM
  ZYPPER
}

type AgentInstallationSession {
  installationStatus: AgentInstallationStatus!
  uamsClientId: String
}

enum AgentInstallationStatus {
  CLIENT_INSTALLED
  ERROR
  REQUESTED
  UNKNOWN
}

# Defines how chainsaw will aggregate the data for this query
enum AggregationFunction {
  ANY
  AVG
  COUNT
  LAST
  MAX
  MIN
  SUM
}

type AlertAction {
  # List of notification configuration IDs
  configurationIds: [ID!]!

  # Type of a notification service
  type: String!
}

type AlertActionDeletedByCnsEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  cnsConfigurationId: String!
  cnsConfigurationType: String!
  eventId: String!
  timestamp: String!
  userId: String!
}

input AlertActionInput {
  # List of notification configuration IDs
  configurationIds: [ID!]!

  # Type of a notification service
  type: String!
}

interface AlertConditionEvaluationFlat {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String!

  # Alert definition severity
  alertDefinitionSeverity: AlertSeverity!

  # Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  changedAt: String!

  # Type of the condition
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityData

  # Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  # The first item is the tree root.
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  # Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  lastTriggeredAt: String

  # Information about pending mute configurations related to this evaluation
  muteInfo: AlertEvaluationMuteInfo!

  # Current state of evaluation
  state: AlertConditionState!
}

interface AlertConditionEvaluationV2 {
  # Alert definition related to this evaluation
  alertDefinition: AlertDefinition

  # Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  changedAt: String!

  # Type of the condition
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityEvaluationData

  # Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  # The first item is the tree root.
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  # Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  lastTriggeredAt: String

  # Information about pending mute configurations related to this evaluation
  muteInfo: AlertEvaluationMuteInfo!

  # Time when was the last notification sent for this evaluation in ISO-8601 date format - 2011-12-03T10:15:30Z
  notificationSentAt: String @deprecated(reason: "Not populated any more due to functionality changes.")

  # Current state of evaluation
  state: AlertConditionState!
}

type AlertConditionMatchFieldRule {
  # Field name to apply filtering rule on
  fieldName: String!

  # Rules to apply - multiple rules are joined by OR
  rules: [AlertConditionMatchRule!]!
}

input AlertConditionMatchFieldRuleInput {
  # Field name to apply filtering rule on
  fieldName: String!

  # Rules to apply - multiple rules are joined by OR
  rules: [AlertConditionMatchRuleInput!]!
}

type AlertConditionMatchRule {
  # Negate match (wraps in NOT)
  negate: Boolean!
  type: AlertConditionMatchRuleType!

  # Value match match
  value: String!
}

input AlertConditionMatchRuleInput {
  # Negate match (wraps in NOT)
  negate: Boolean! = false
  type: AlertConditionMatchRuleType!

  # Value match match
  value: String!
}

# Alert definition condition matching rule types
enum AlertConditionMatchRuleType {
  CONTAINS
  EQ
  MATCHES
  NE
}

# See https://swicloud.atlassian.net/wiki/spaces/NIT/pages/2700936948/Data+Format+for+storing+alerts.
type AlertConditionNode {
  # Data type for "constantValue" nodes. Supported values: "boolean", "number", "string"
  dataType: String

  # Entity filter for "metricField" nodes
  entityFilter: AlertConditionNodeEntityFilter

  # Entity metric field for "metricField" nodes
  fieldName: String

  # Condition node ID.
  id: Int!

  # Measurement filter for tags on metrics
  metricFilter: [FlatAlertFilterExpression]

  # Ordered list of child condition node IDs.
  operandIds: [Int!]

  # Operator for combining operands. Supported values:
  # - For aggregationOperator: "COUNT", "MIN", "MAX", "AVG", "SUM", "LAST"
  # - For binaryOperator: "=", "!=", ">", "<", ">=", "<="
  # - For logicalOperator: "AND", "OR"
  # - For unaryOperator: "!"
  operator: String

  # Query specification for "queryField" nodes.
  query: String

  # Source specification for "queryField" nodes.
  source: String

  # Node (operator) type. Supported values:
  # - "aggregationOperator" (child of "binaryOperator")
  # - "binaryOperator" (root, or child of "logicalOperator", "unaryOperator")
  # - "constantValue" (root, or child of "aggregationOperator", "binaryOperator")
  # - "logicalOperator" (root, or child of "logicalOperator", "unaryOperator")
  # - "metricField" (child of "binaryOperator", "aggregationOperator")
  # - "queryField" (child of "aggregationOperator")
  # - "unaryOperator" (root, or child of "logicalOperator", "unaryOperator")
  type: String!

  # String representation of value for "constantValue" nodes.
  value: String
}

type AlertConditionNodeEntityFilter {
  # List of alert condition field rules
  fields: [AlertConditionMatchFieldRule!]

  # Entity IDs
  ids: [ID!]
  type: String! @deprecated(reason: "Use the 'types' field instead.")

  # Entity types
  types: [String!]
}

input AlertConditionNodeEntityFilterInput {
  # Filter by Entity fields - multiple fields are joined by AND
  fields: [AlertConditionMatchFieldRuleInput!]

  # Filter by Entity IDs
  ids: [ID!]

  # @deprecated(reason: "Use the 'types' field instead.")
  type: String!

  # Filter by Entity types
  types: [String!]
}

# See https://swicloud.atlassian.net/wiki/spaces/NIT/pages/2700936948/Data+Format+for+storing+alerts.
input AlertConditionNodeInput {
  # Data type for "constantValue" nodes. Supported values: "boolean", "number", "string"
  dataType: String

  # Entity filter for "metricField" nodes, when defined (not null) metric is scoped to entity
  entityFilter: AlertConditionNodeEntityFilterInput

  # Entity metric field for "metricField" nodes
  fieldName: String

  # Condition node ID.
  id: Int!

  # Measurement filter for metric tags
  metricFilter: AlertFilterExpressionInput

  # Ordered list of child condition nodes IDs.
  operandIds: [Int!]

  # Operator for combining operands. Supported values:
  # - For aggregationOperator: "COUNT", "MIN", "MAX", "AVG", "SUM", "LAST"
  # - For binaryOperator: "=", "!=", ">", "<", ">=", "<="
  # - For logicalOperator: "AND", "OR"
  # - For unaryOperator: "!"
  operator: String

  # Query specification for "queryField" nodes.
  query: String

  # Source specification for "queryField" nodes.
  source: String

  # Node (operator) type. Supported values:
  # - "aggregationOperator" (child of "binaryOperator")
  # - "binaryOperator" (root, or child of "logicalOperator", "unaryOperator")
  # - "constantValue" (root, or child of "aggregationOperator", "binaryOperator")
  # - "logicalOperator" (root, or child of "logicalOperator", "unaryOperator")
  # - "metricField" (child of "binaryOperator", "aggregationOperator")
  # - "queryField" (child of "aggregationOperator")
  # - "unaryOperator" (root, or child of "logicalOperator", "unaryOperator")
  type: String!

  # String representation of value for "constantValue" nodes.
  value: String
}

# Alert definition condition evaluation states
enum AlertConditionState {
  FIRING
  OK
}

type AlertDefinition {
  # List of alert actions that shall be triggered in case of alert FIRING
  actions: [AlertAction!]!

  # List of alert evaluations
  conditionEvaluations: [AlertConditionEvaluationV2!]!

  # Alert definition condition type
  conditionType: ConditionType!

  # The time stamp that identifies when the condition was updated.
  conditionUpdatedAt: String!

  # Alert definition description
  description: String

  # Enabled whether Alert definition shall be evaluated
  enabled: Boolean!

  # Ordered list of condition nodes representing the flatten condition tree.
  # The first item is the tree root.
  flatCondition: [FlatAlertConditionExpression!]!

  # Alert definition ID in UUID format
  id: ID!

  # Information about any pending mutes on the Alert definition
  muteInfo: AlertDefinitionMuteInfo!

  # Alert definition name
  name: String!

  # Organization ID
  organizationId: ID!

  # Alert definition severity
  severity: AlertSeverity!

  # List of targeted Entity types
  targetEntityTypes: [String!]

  # A flag indicating whether to send a notification when active alert returns to normal.
  triggerResetActions: Boolean!

  # Indication whether alert is triggered
  triggered: Boolean!

  # Time when the Alert definition was triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  triggeredTime: String

  # User ID
  userId: ID!
}

input AlertDefinitionBulkInput {
  # Enabled whether given Alert definitions shall be evaluated
  enabled: Boolean
}

type AlertDefinitionCreatedEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  configuration: AlertDefinitionEventData!
  eventId: String!
  timestamp: String!
  userId: String!
}

type AlertDefinitionDeletedEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  eventId: String!
  timestamp: String!
  userId: String!
}

type AlertDefinitionDisabledEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  eventId: String!
  timestamp: String!
  userId: String!
}

type AlertDefinitionEnabledEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  eventId: String!
  timestamp: String!
  userId: String!
}

type AlertDefinitionEventData {
  # List of alert actions that shall be triggered in case of alert FIRING
  actions: [AlertAction!]!

  # Alert definition description
  description: String

  # Ordered list of condition nodes representing the flatten condition tree.
  # The first item is the tree root.
  flatCondition: [FlatAlertConditionExpression!]!

  # Alert definition name
  name: String!

  # Alert definition severity
  severity: AlertSeverity!

  # List of targeted Entity types
  targetEntityTypes: [String!]
}

input AlertDefinitionInput {
  # List of alert actions that shall be triggered in case of alert FIRING
  actions: [AlertActionInput!]

  # Ordered list of condition nodes representing the flatten condition tree.
  # The first item is the tree root.
  condition: [AlertConditionNodeInput!]!

  # Alert definition description
  description: String

  # Enabled whether Alert definition shall be evaluated
  enabled: Boolean!

  # Alert definition name
  name: String!

  # Alert definition severity
  severity: AlertSeverity!

  # A flag indicating whether to send a notification when active alert returns to normal.
  # It will be set to *false* if not specified.
  triggerResetActions: Boolean
}

type AlertDefinitionManualResetEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  eventId: String!
  timestamp: String!
  userId: String!
}

# Alert definitions can be muted for certain period of time or muted until resolved.
#
# If the muted is set to 'true' and until attribute is not set meaning no notification will be sent until
# all of the evaluations are set to OK state or alert definition is reset
type AlertDefinitionMuteInfo {
  # When muted no notifications are sent
  muted: Boolean!

  # Time until the mute expires in ISO-8601 date format - 2011-12-03T10:15:30Z or null - muted until resolved
  until: String
}

type AlertDefinitionMutedEvent implements AlertEntityTrait & AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  entity: AlertEntityData!
  eventId: String!
  expiresAt: String!
  timestamp: String!
  userId: String!
}

input AlertDefinitionPatchInput {
  # List of Alert Actions that shall be triggered in case of alert FIRING
  actions: [AlertActionInput!]

  # Ordered list of condition nodes representing the flatten condition tree.
  # The first item is the tree root.
  condition: [AlertConditionNodeInput!]

  # Alert definition description
  description: String

  # Enabled whether Alert definition shall be evaluated
  enabled: Boolean

  # Alert definition ID
  id: String!

  # Alert definition name
  name: String

  # Alert definition severity
  severity: AlertSeverity

  # A flag indicating whether to send a notification when active alert returns to normal.
  # It will be set to *false* if not specified.
  triggerResetActions: Boolean
}

type AlertDefinitionUnmutedEvent implements AlertEntityTrait & AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  entity: AlertEntityData!
  eventId: String!
  timestamp: String!
  userId: String
}

type AlertDefinitionUpdatedEvent implements AlertManagementEvent {
  alertDefinitionId: String!
  alertDefinitionName: String
  eventId: String!
  newConfiguration: AlertDefinitionEventData!
  originalConfiguration: AlertDefinitionEventData!
  timestamp: String!
  userId: String!
}

# @deprecated(reason: "Currently not used and will be removed")
input AlertDefinitionsFromTemplatesInput {
  actions: [AlertActionInput!]!
  enabled: Boolean!
  severity: AlertSeverity!
}

type AlertDefinitionsResult {
  # List of Alert definitions
  alertDefinitions: [AlertDefinition!]!

  # Cursor-based paging metadata
  pageInfo: PageInfo!

  # Number of records in data list
  totalRecords: Int
}

type AlertEntitiesFilter {
  # List of Entity types to get. If empty/missing then search is across all Entities.
  type: String!
}

input AlertEntitiesFilterInput {
  # List of Entity types to get. If empty/missing then search is across all Entities.
  type: String!
}

type AlertEntityData {
  # Displayed name
  displayName: String

  # HealthScore
  healthScore: Int

  # Entity ID
  id: ID!

  # Entity name
  name: String

  # Type of Entity
  type: String
}

type AlertEntityEvaluationData {
  # Evaluation condition state
  currentState: AlertConditionState!

  # Entity ID
  entityId: ID!

  # Time in ISO-8601 date format - 2011-12-03T10:15:30Z
  flippedAt: String! @deprecated(reason: "this value does not bring any value to customer right now")
}

interface AlertEntityTrait {
  entity: AlertEntityData!
}

input AlertEvaluationFilterInput {
  # By active
  active: Boolean

  # By list of entity IDs
  entityIds: [String!]

  # By list of entity types
  entityTypes: [String!]

  # By mute status
  muted: Boolean

  # By list of parent Alert definition severities
  severities: [AlertSeverity!]
}

# "
# If the muted detail is listed and until attribute is not set meaning no notification will be sent until
# all of the evaluations are set to OK state or alert definition is reset
type AlertEvaluationMuteDetail {
  # Type of the mute origin
  reason: AlertEvaluationMuteReason!

  # Time until the mute expires in ISO-8601 date format - 2011-12-03T10:15:30Z or null - muted until resolved
  until: String
}

type AlertEvaluationMuteInfo {
  # List of mute details
  details: [AlertEvaluationMuteDetail]

  # When muted no notifications are sent
  muted: Boolean!
}

# Evaluation mute reasons
enum AlertEvaluationMuteReason {
  ALERT_DEFINITION
  ENTITY
  ENTITY_PER_ALERT_DEFINITION
}

input AlertEvaluationsFilterInput {
  # By list of condition types
  conditionTypes: [ConditionType!]

  # By list of Entity IDs
  entityIds: [String!]

  # By last triggered filter
  lastTriggered: LastTriggeredFilterInput

  # By mute status
  muted: Boolean

  # By string in Alert definition name or Entity display name
  searchString: String

  # By alert status
  state: AlertConditionState
}

type AlertEvaluationsResult {
  # Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  # The first item is the tree root.
  conditionEvaluations: [AlertConditionEvaluationFlat!]!

  # Cursor-based paging metadata
  pageInfo: PageInfo!

  # Number of records in data list
  totalRecords: Int
}

type AlertFilterExpression {
  # Operation to use for the evaluation. Default: "EQ"
  operation: FilterOperation!

  # Name of the property to filter on.
  propertyName: String

  # Value of the property for operations that expect single value such as EQ, NE, GT, ...
  propertyValue: String

  # Values of the property for operations expecting multiple values, such as IN.
  propertyValues: [String]
}

# Input type for filtering
input AlertFilterExpressionInput {
  # Children filters in case of "operator" being one of "OR", "AND", "NOT".
  # In such case the "propertyName" and "propertyValue" are ignored.
  children: [AlertFilterExpressionInput!]

  # Operation to use for the evaluation. Default: "EQ"
  operation: FilterOperation! = EQ

  # Name of the property to filter on.
  propertyName: String

  # Value of the property for operations that expect single value such as EQ, NE, GT, ...
  propertyValue: String

  # Values of the property for operations expecting multiple values, such as IN.
  propertyValues: [String]
}

input AlertFilterInput {
  # By action configuration ID
  actionConfigurationId: ID

  # By list of condition types
  conditionTypes: [ConditionType!]

  # By Alert definition enablement
  enabled: Boolean

  # By list of Entity IDs
  entities: [String!]

  # By list of Entity types
  entityTypes: [String!]

  # By alert filter expression
  filter: AlertFilterExpressionInput

  # By Alert definition ID
  id: ID

  # By Alert definition name
  name: String

  # By list of Alert definition severities
  severities: [AlertSeverity!]

  # By trigger status
  triggered: Boolean

  # By user ID
  userId: ID
}

input AlertIntRangeInput {
  # Integer value from how many minutes ago to look for.
  from: Int!

  # Integer value from how many minutes ago end the search in. If not defined it looks up till now.
  to: Int
}

type AlertLogConditionEvaluation implements AlertConditionEvaluationV2 {
  # Alert definition
  alertDefinition: AlertDefinition

  # Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  changedAt: String!

  # Type of the condition
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityEvaluationData

  # Evaluated condition containing values
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  # Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  lastTriggeredAt: String

  # Information about pending mute configurations related to this evaluation
  muteInfo: AlertEvaluationMuteInfo!

  # Time when was the last notification sent for this evaluation in ISO-8601 date format - 2011-12-03T10:15:30Z
  notificationSentAt: String @deprecated(reason: "Not populated any more due to functionality changes.")

  # Current state of evaluation
  state: AlertConditionState!
}

type AlertLogConditionEvaluationFlat implements AlertConditionEvaluationFlat {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String!

  # Alert definition severity
  alertDefinitionSeverity: AlertSeverity!

  # Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  changedAt: String!

  # Type of the condition
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityData

  # Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  # The first item is the tree root.
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  # Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  lastTriggeredAt: String

  # Information about pending mute configurations related to this evaluation
  muteInfo: AlertEvaluationMuteInfo!

  # Current state of evaluation
  state: AlertConditionState!
}

interface AlertManagementEvent {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String

  # Event ID
  eventId: String!

  # Time in ISO-8601 date format - 2011-12-03T10:15:30Z
  timestamp: String!

  # User ID
  userId: String
}

# Alert management event types
enum AlertManagementEventType {
  ALERT_ACTION_DELETED_BY_CNS
  ALERT_DEFINITION_CREATED
  ALERT_DEFINITION_DELETED
  ALERT_DEFINITION_DISABLED
  ALERT_DEFINITION_ENABLED
  ALERT_DEFINITION_MANUAL_RESET
  ALERT_DEFINITION_MUTED
  ALERT_DEFINITION_UNMUTED
  ALERT_DEFINITION_UPDATED
}

input AlertManagementEventsFilterInput {
  # List of Alert definition IDs
  alertDefinitionIds: [String!]

  # Event ID
  eventId: String

  # Time range
  timeRange: AlertTimeRangeInput!

  # List of event types
  types: [AlertManagementEventType!]

  # User ID
  userId: String
}

type AlertManagementEventsResult {
  # List of alert management events
  events: [AlertManagementEvent!]!

  # Cursor-based paging metadata
  pageInfo: PageInfo!
}

type AlertMetricConditionEvaluation implements AlertConditionEvaluationV2 {
  # Alert definition
  alertDefinition: AlertDefinition

  # Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  changedAt: String!

  # Type of the condition
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityEvaluationData

  # Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  # The first item is the tree root.
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  # Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  lastTriggeredAt: String

  # Information about pending mute configurations related to this evaluation
  muteInfo: AlertEvaluationMuteInfo!

  # Time when was the last notification sent for this evaluation in ISO-8601 date format - 2011-12-03T10:15:30Z
  notificationSentAt: String @deprecated(reason: "Not populated any more due to functionality changes.")

  # Current state of evaluation
  state: AlertConditionState!
}

type AlertMetricConditionEvaluationFlat implements AlertConditionEvaluationFlat {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String!

  # Alert definition severity
  alertDefinitionSeverity: AlertSeverity!

  # Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  changedAt: String!

  # Type of the condition
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityData

  # Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  # The first item is the tree root.
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  # Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  lastTriggeredAt: String

  # Information about pending mute configurations related to this evaluation
  muteInfo: AlertEvaluationMuteInfo!

  # Current state of evaluation
  state: AlertConditionState!
}

type AlertMutations {
  # Updates an Alert definitions by bulkDefinition and returns the Alert definitions on success, or null when no such
  # Alert definition exists.
  # Bulk definition updates only fields that are specified within the request of no value is sent field is left within
  # Alert definition as it was before bulk update.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  bulkUpdateAlertDefinitions(bulkDefinition: AlertDefinitionBulkInput!, ids: [ID!]!): [AlertDefinition!]!

  # Creates a new Alert definition and returns it on success, or null on error.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  createAlertDefinition(definition: AlertDefinitionInput!): AlertDefinition

  # Creates Alert definitions for existing alert templates with given parameters and returns list of created alerts,
  # or null on error.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  createAlertDefinitionsFromTemplates(alertsInput: AlertDefinitionsFromTemplatesInput!): [AlertDefinition!]!

  # Deletes all alert actions with given configuration IDs from every Alert definition that contains any of them and
  # returns the list of IDs of affected Alert definitions. If no such definitions were found, empty list is returned.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  deleteAlertActionByConfigurationId(id: ID!): [ID!]

  # Deletes an Alert definition by ID and returns the ID on success, or null when no such Alert definition exists.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  deleteAlertDefinition(id: ID!): ID

  # Deletes Alert definitions by IDs and returns the list of IDs.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  deleteAlertDefinitions(ids: [ID!]!): [ID!]!

  # Mutes given alerting targets until given timestamp or 'until resolved' when no timestamp is specified.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  muteAlerts(targets: [AlertMuteOrUnmuteTargetInput!]!, until: String): Boolean

  # Patches an Alert definition and returns the Alert definition on success, or null
  # when no such alert definition exists.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  patchAlertDefinition(alertDefinitionPatch: AlertDefinitionPatchInput!): AlertDefinition

  # Resets evaluations for a given Alert definition ID and returns the number of affected entities, or null when no
  # such Alert definition exists.
  # (Resetting evaluations means that all entities associated with the Alert definition are put back to the 'OK' state,
  # and a new notification will be sent if the alert fires again.)
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  resetAlertEvaluation(id: ID!): Int

  # Resets evaluations for a given list of Alert definition IDs and returns the total number of affected entries.
  # (Resetting evaluations means that all entities associated with the Alert definition are put back to the 'OK' state,
  # and a new notification will be sent if the alert fires again.)
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  resetAlertEvaluations(ids: [ID!]!): Int!

  # Unmutes given alerting targets.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  unmuteAlerts(targets: [AlertMuteOrUnmuteTargetInput!]!): Boolean

  # Updates an Alert definition by ID and returns the alert on success, or null when no such Alert definition exists.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  updateAlertDefinition(definition: AlertDefinitionInput!, id: ID!): AlertDefinition
}

# What should be muted - one or both fields must be specified.
input AlertMuteOrUnmuteTargetInput {
  # Alert definition ID
  alertDefinitionId: String

  # Entity ID
  entityId: String
}

type AlertQueries {
  # Returns firing alert instances (also referred as objects or evaluations) for given Filter, Paging and Sorting.
  # Sorting is supported for 'alertDefinitionName', 'alertDefinitionSeverity', 'entityDisplayName', 'changedAt' and 'lastTriggeredAt'.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  activeAlerts(filter: ActiveAlertsFilterInput!, paging: PagingInput, sortBy: SortInput): AlertEvaluationsResult!

  # Returns all Alert definitions with given Filter, Paging and Sorting.
  # Filtering can be performed either using dedicated fields in the 'filter' input, or using a generic 'filter.filter'
  # field. The latter one can be also used to filter Alert definitions with no configured actions/condition evaluations
  # using 'propertyName' 'actions'/'conditionEvaluations' and 'operation' 'EXISTS'.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  alertDefinitions(filter: AlertFilterInput!, paging: PagingInput, sortBy: SortInput): AlertDefinitionsResult!

  # Returns all alert instances (also referred as objects or evaluations) for given alert definition with given Filter, Paging and Sorting.
  # Sorting is supported for 'entityDisplayName', 'state', 'changedAt', and 'lastTriggeredAt'.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  alertEvaluationsV2(filter: AlertEvaluationsFilterInput!, id: ID!, paging: PagingInput, sortBy: SortInput): AlertEvaluationsResult!

  # Returns alert management events with for given Filter and Paging.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  alertManagementEvents(filter: AlertManagementEventsFilterInput!, paging: PagingInput): AlertManagementEventsResult!

  # Returns alert definition statistics, both for all definitions and for definitions complying with the given filter.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  alertStatistics(filter: AlertFilterInput!): [AlertStatistics!]!

  # Returns all alert templates available for alerts creation.
  alertTemplates: [AlertTemplate!]!

  # Evaluates the alert condition and returns the result, or null on error.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  #
  # @param condition the ordered list of condition nodes representing the flatten condition tree.
  # The first item is the tree root.
  evaluateAlertConditionV2(condition: [AlertConditionNodeInput!]!): [AlertConditionEvaluationV2!]!

  # Returns alert evaluation statistics, both for all evaluations and for evaluations complying with the given filter.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  evaluationStatistics(filter: AlertEvaluationFilterInput!): [AlertStatistics!]!

  # Returns all past firing alert instances (also referred as objects or evaluations) for given Filter, Paging and Sorting.
  # Sorting is supported for 'alertDefinitionName', 'alertDefinitionSeverity', 'triggeredAt', 'resolvedAt' and 'entityDisplayName'.
  # Requires JWT payload (x-jwt-verified header) with org_id claim containing Organization ID.
  historicalAlerts(filter: HistoricalAlertsFilterInput!, paging: PagingInput, sortBy: SortInput): HistoricalAlertsResult!
}

# Alert resolution reasons
enum AlertReason {
  AUTO_RESET
  ENTITY_DELETED
  MANUAL_RESET
}

# Alert Definition severities
enum AlertSeverity {
  CRITICAL
  INFO
  WARNING
}

type AlertStatistics {
  # Category
  category: AlertStatisticsCategory!

  # List of statistics items
  items: [AlertStatisticsItem!]!
}

# Alerting statistics categories
enum AlertStatisticsCategory {
  ACTIVE
  ALERT_DEFINITION
  CONDITION_TYPE
  ENABLED
  ENTITY
  MUTED
  REASON
  SEVERITY
  TRIGGERED
  TRIGGERING_OBJECT
}

type AlertStatisticsItem {
  # Total number of items
  countForAll: Int!

  # Number of items matching current filter
  countForFilter: Int!

  # Name of statistics item
  name: String!
}

# @deprecated(reason: "Not currently used.")
type AlertTemplate {
  # Ordered list of condition nodes representing the flatten condition tree.
  # The first item is the tree root.
  condition: [AlertConditionNode!]!
  description: String
  id: ID!
  name: String!
}

input AlertTimeRangeInput {
  # End time of the time range, accepts: UNIX timestamp, ISO format and `1 day ago` formats.
  endTime: String

  # Start time of the time range, accepts: UNIX timestamp, ISO format and `2 days ago` formats.
  startTime: String!
}

# The base interface for Entities that can be targeted and evaluated in Alert definitions.
interface AlertingEntity {
  # Evaluations of the Entity in individual Alert definitions. Details of each Alert definition can be fetched through
  # the nested type.
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Unique identifier of the Entity.
  id: ID!
}

type AlertsHistogramColumn {
  # End time from which the histogram is represented
  endTime: String!

  # Number of alerts triggered within start to end period
  newAlerts: Int!

  # Carry on alerts from previous periods
  ongoingAlerts: Int!

  # Start time from which the histogram is represented
  startTime: String!
}

type AllPermissionsResponse {
  featurePermissions: [FeaturePermissions!]!
  roleNames: [String!]!
}

interface AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
}

type AnalysisRedirect {
  connectionDetails: ConnectionDetails
  durationInMs: Int!
  ipLookupDetails: IpLookupDetails
  requestDetails: RequestDetails
  responseDetails: ResponseDetails
  url: String!
}

type ApmConfig {
  collectorUrl: String
}

type ApmContainerExtension {
  # Container id
  containerId: String

  # Container image name
  imageName: String

  # Container image tag
  imageTag: String

  # Entity name
  name: String

  # Container runtime
  runtime: String
}

interface Attribute {
  description: String!
  id: ID!
  name: String!
  type: AttributeType!
}

type AttributeBool implements Attribute {
  defaultValue: Boolean
  description: String!
  id: ID!
  name: String!
  type: AttributeType!
  value: Boolean
}

type AttributeFloat implements Attribute {
  defaultValue: Float
  description: String!
  id: ID!
  name: String!
  type: AttributeType!
  value: Float
}

type AttributeInt implements Attribute {
  defaultValue: Int
  description: String!
  id: ID!
  name: String!
  type: AttributeType!
  value: Int
}

type AttributeJson implements Attribute {
  defaultValue: JSON
  description: String!
  id: ID!
  name: String!
  type: AttributeType!
  value: JSON
}

type AttributeString implements Attribute {
  defaultValue: String
  description: String!
  id: ID!
  name: String!
  type: AttributeType!
  value: String
}

enum AttributeType {
  BOOL
  FLOAT
  INT
  JSON
  STRING
}

type AuditTrailEntity {
  data: JSON
  event: String!
  id: ID!
  label: String!
  timestamp: DateTime!
}

type AuthenticatedUser implements SwicusUser {
  auditTrail(limit: Int): [AuditTrailEntity]
  currentOrganization: Organization!
  email: String!
  emailVerified: Boolean!
  firstName: String
  id: ID!
  lastLogin: DateTime
  lastName: String
  organizations: [OrganizationBaseInfo!]!
  timezone: String
  trustedDevices: [TrustedDevice]!
  userAttribute(id: String!): UserAttribute
}

# Generic Response type for autocomplete requests
type AutocompleteResponse {
  chainsawMeta: ChainsawMetadata
  keys: [String!]
  pageInfo: PageInfo
}

type AvailabilityMonitoring {
  checkForString: CheckForStringType
  locationOptions: [ProbeLocation!]!
  platformOptions: PlatformOptions
  protocols: [WebsiteProtocol!]!
  ssl: SslMonitoring
  testFromLocation: ProbeLocationType
  testIntervalInSeconds: Int
}

input AvailabilityMonitoringInput {
  checkForString: CheckForStringInput
  platformOptions: PlatformOptionsInput
  protocols: [WebsiteProtocol!]!
  ssl: SslMonitoringInput
  testFrom: [ProbeLocationInput!]!
  testIntervalInSeconds: Int!
}

type AvailabilityTestAnalysis {
  analysisId: ID!
  durationInMs: Int!
  errorMessage: String
  redirects: [AnalysisRedirect!]!
}

type AvailabilityTestAnalysisQueries {
  byId(analysisId: ID!, testResultTime: DateTime!): AvailabilityTestAnalysis
}

type AvailabilityTestValidations {
  checkForString: CheckForString
  sslCertificates: SslCertificates
}

type AvailabilityTestValidationsQueries {
  byId(testResultTime: DateTime!, validationId: ID!): AvailabilityTestValidations
}

# AWS API GATEWAY
type AwsApiGateway implements Entity & HealthEntity {
  # API Gateway API ID.
  apiId: String

  # API Gateway API name.
  apiName: String

  # The number of requests served from the API cache in a given period.
  cacheHitCount: Metric!

  # The number of requests served from the backend in a given period, when API caching is enabled.
  cacheMissCount: Metric!

  # The number of requests that have a 4XX response returned by API Gateway before the integration is invoked.
  clientError: Metric!

  # Cloud Account to which this API GATEWAY belongs to.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # The number of messages sent to the $connect route integration.
  connectCount: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # The amount of data processed in bytes.
  dataProcessed: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Errors that occurred when calling the integration.
  executionError: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # AWS API Gateway Type (Like: Rest. Http, Websocket).
  gatewayType: String
  healthScore: HealthScore

  # Rate of 5xx error against total request count for Http based AWS Api Gateway.
  http5xxErrorRate: Metric!

  # Unique identifier of an entity
  id: ID!

  # The number of requests that return a 4XX/5XX response from the integration.
  integrationError: Metric!

  # The time between when API Gateway relays a request to the backend and when it receives a response from the backend.
  integrationLatency: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The time between when API Gateway receives a request from a client and when it returns a response to the client. The latency includes the integration latency and other API Gateway overhead.
  latency: Metric!

  # The number of messages sent to the WebSocket API, either from or to the client.
  messageCount: Metric!

  # API Gateway Method
  method: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # API GATEWAY APINAME.
  name: String

  # The number of client-side errors captured in a given period.
  numberOf4xx: Metric!

  # The number of HTTP 4xx client error status code requests made to an Amazon API GATEWAY.
  numberOf4xxErrors: Metric!

  # The number of server-side errors captured in a given period.
  numberOf5xx: Metric!

  # The number of HTTP 5xx client error status code requests made to an Amazon API GATEWAY.
  numberOf5xxErrors: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The total number API requests in a given period.
  requestCount: Metric!

  # API Gateway Resource
  resource: String

  # Rate of 5xx error against total request count for Rest based AWS Api Gateway.
  rest5xxErrorRate: Metric!

  # API Gateway Route
  route: String

  # API Gateway Stage
  stage: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Rate of Execution error against message count for Websocket based AWS Api Gateway.
  websocketExecutionErrorRate: Metric!
}

# AWS Application load balancer
type AwsApplicationELB implements Entity & HealthEntity & StatefulEntity {
  # The total number of concurrent TCP connections active from clients to the load balancer and from the load balancer to targets.
  activeConnectionCount: Metric!

  # The Availability Zone of the instance.
  availabilityZone: String

  # The number of TLS connections initiated by the client that did not establish a session with the load balancer due to a TLS error.
  clientTlsNegotiationErrorCount: Metric!

  # Relation: Cloud Account to which this ALB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this load balacer belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # The number of load balancer capacity units (LCU) used by your load balancer.
  consumedLcus: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # The number of requests that do not comply with RFC 7230.
  desyncMitigationModeNonCompliantRequestCount: Metric!

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String

  # DNS name of Application load balancer
  dnsName: String

  # The number of requests where the load balancer removed HTTP headers with header fields that are not valid before routing the request.
  droppedInvalidHeaderRequestCount: Metric!
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # The number of user authentications that could not be completed because an authenticate action was misconfigured, the load balancer couldn't establish a connection with the IdP, or the load balancer couldn't complete the authentication flow due to an internal error.
  elbAuthError: Metric!

  # The number of user authentications that could not be completed because the IdP denied access to the user or an authorization code was used more than once.
  elbAuthFailure: Metric!

  # The time elapsed, in milliseconds, to query the IdP for the ID token and user info.
  elbAuthLatency: Metric!

  # The number of times the load balancer successfully refreshed user claims using a refresh token provided by the IdP.
  elbAuthRefreshTokenSuccess: Metric!

  # The number of authenticate actions that were successful.
  elbAuthSuccess: Metric!

  # The number of times that a configured IdP returned user claims that exceeded 11K bytes in size.
  elbAuthUserClaimsSizeExceeded: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The number of requests routed by the load balancer that had HTTP headers with header fields that are not valid.
  forwardedInvalidHeaderRequestCount: Metric!

  # The number of gRPC requests processed over IPv4 and IPv6.
  grpcRequestCount: Metric!
  healthScore: HealthScore

  # The number of targets that are considered healthy.
  healthyHostCount: Metric!

  # The HealthyHostRate metric provides percentage of healthy hosts over all the hosts(healthy & unhealthy)
  healthyHostRate: Metric!

  # The number of HTTP 3XX redirection codes that originate from the load balancer.
  httpCodeElb3xxCount: Metric!

  # The number of HTTP 4XX client error codes that originate from the load balancer.
  httpCodeElb4xxCount: Metric!

  # The number of HTTP 5XX server error codes that originate from the load balancer.
  httpCodeElb5xxCount: Metric!

  # The number of HTTP 500 error codes that originate from the load balancer.
  httpCodeElb500Count: Metric!

  # The number of HTTP 502 error codes that originate from the load balancer.
  httpCodeElb502Count: Metric!

  # The number of HTTP 503 error codes that originate from the load balancer.
  httpCodeElb503Count: Metric!

  # The number of HTTP 504 error codes that originate from the load balancer.
  httpCodeElb504Count: Metric!

  # The number of HTTP 2XX response codes generated by the targets
  httpCodeTarget2xxCount: Metric!

  # The number of HTTP 3XX response codes generated by the targets
  httpCodeTarget3xxCount: Metric!

  # The number of HTTP 4XX response codes generated by the targets
  httpCodeTarget4xxCount: Metric!

  # The number of HTTP 5XX response codes generated by the targets
  httpCodeTarget5xxCount: Metric!

  # The number of fixed-response actions that were successful.
  httpFixedResponseCount: Metric!

  # The number of redirect actions that were successful.
  httpRedirectCount: Metric!

  # The number of redirect actions that couldn't be completed because the URL in the response location header is larger than 8K.
  httpRedirectUrlLimitExceededCount: Metric!

  # Unique identifier of an entity
  id: ID!

  # This field represents the ip address for the load balancer.
  ipaddress: String

  # The total number of bytes processed by the load balancer over IPv6. This count is included in ProcessedBytes.
  ipv6ProcessedBytes: Metric!

  # The number of IPv6 requests received by the load balancer.
  ipv6RequestCount: Metric!

  # The number of requests to a Lambda function that failed because of an issue internal to the load balancer or AWS Lambda. 
  lambdaInternalError: Metric!

  # The total number of bytes processed by the load balancer for requests to and responses from a Lambda function.
  lambdaTargetProcessedBytes: Metric!

  # The number of requests to a Lambda function that failed because of an issue with the Lambda function.
  lambdaUserError: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Application load balancer
  loadBalancer: String!

  # This field represents the type of load balancer (application | gateway | network).
  loadBalancerType: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Application load balancer name
  name: String

  # The total number of new TCP connections established from clients to the load balancer and from the load balancer to targets.
  newConnectionCount: Metric!

  # The number of requests where the load balancer chose a new target because it couldn't use an existing sticky session.
  nonStickyRequestCount: Metric!

  # The total number of bytes processed by the load balancer over IPv4 and IPv6.
  processedBytes: Metric!

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # The number of connections that were rejected because the load balancer had reached its maximum number of connections.
  rejectedConnectionCount: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The number of requests processed over IPv4 and IPv6. This metric is only incremented for requests where the load balancer node was able to choose a target.
  requestCount: Metric!

  # The average number of requests received by each target in a target group. 
  requestCountPerTarget: Metric!

  # The number of rules processed by the load balancer given a request rate averaged over an hour.
  ruleEvaluations: Metric!

  # This field represents schema of load balancer.
  schema: String

  # This field represents the ALB state.
  state: State

  # The number of connections that were not successfully established between the load balancer and target.
  targetConnectionErrorCount: Metric!

  # Application load balancer target group
  targetGroup: String

  # The time elapsed, in seconds, after the request leaves the load balancer until a response from the target is received.
  targetResponseTime: Metric!

  # The number of TLS connections initiated by the load balancer that did not establish a session with the target.
  targetTlsNegotiationErrorCount: Metric!

  # Entity type.
  type: String!

  # The number of targets that are considered unhealthy.
  unHealthyHostCount: Metric!

  # The UnHealthyHost rate metric is used in health score for AWS ALB, which is sum of UnHealthyHostCount by total number of UnHealthyHostCount and HealthyHostCount.
  unHealthyHostRate: Metric!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # This field represents the ID of the VPC for the load balancer.
  vpcId: String
}

# AWS Aurora Cluster
type AwsAuroraCluster implements Entity & HealthEntity & StatefulEntity {
  # The current capacity of an Aurora Serverless DB cluster.
  ServerlessDatabaseCapacity: Metric!

  # In an Aurora Global Database, the amount of redo log data transferred from the master AWS Region to a secondary AWS Region.
  auroraGlobalDBDataTransferBytes: Metric!

  # In an Aurora Global Database, the measure of how far the secondary cluster is behind the primary cluster for both user transactions and system transactions.
  auroraGlobalDBProgressLag: Metric!

  # In an Aurora Global Database, the recovery point objective (RPO) lag time. This metric measures how far the secondary cluster is behind the primary cluster for user transactions.
  auroraGlobalDBRPOLag: Metric!

  # In an Aurora Global Database, the number of write I/O operations replicated from the primary AWS Region to the cluster volume in a secondary AWS Region.
  auroraGlobalDBReplicatedWriteIO: Metric!

  # For an Aurora Global Database, the amount of lag when replicating updates from the primary AWS Region.
  auroraGlobalDBReplicationLag: Metric!

  # The remaining available space for the cluster volume. As the cluster volume grows, this value decreases. If it reaches zero, the cluster reports an out-of-space error.
  auroraVolumeBytesLeftTotal: Metric!

  # The number of backtrack change records created over 5 minutes for your DB cluster.
  backtrackChangeRecordsCreationRate: Metric!

  # The number of backtrack change records used by your DB cluster.
  backtrackChangeRecordsStored: Metric!

  # The total amount of backup storage used to support the point-in-time restore feature within the Aurora DB cluster's backup retention window. 
  backupRetentionPeriodStorageUsed: Metric!

  # Relation: Cloud Account to which this Aurora Cluster belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this Aurora Cluster belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Aurora Cluster Database Name
  databaseName: String

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Aurora Cluster Engine Mode (provisioned | serverless | parallelquery | global | multimaster)
  engineMode: String!

  # Aurora Cluster Engine Name
  engineName: String

  # Aurora Cluster Engine Version
  engineVersion: String

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Aurora Cluster name
  name: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The total amount of backup storage consumed by all Aurora snapshots for an Aurora DB cluster outside its backup retention window.
  snapshotStorageUsed: Metric!

  # The current state of the Aurora DB Cluster.
  state: State

  # The total amount of backup storage in bytes for which you are billed for a given Aurora DB cluster.
  totalBackupStorageBilled: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The amount of storage used by your Aurora DB instance.
  volumeBytesUsed: Metric!

  # The number of billed read I/O operations from a cluster volume within a 5-minute interval.
  volumeReadIOPs: Metric!

  # The number of write disk I/O operations to the cluster volume.
  volumeWriteIOPs: Metric!
}

# AWS Aurora Instance
type AwsAuroraInstance implements Entity & HealthEntity & StatefulEntity {
  # The number of client connections that have not been closed properly.
  abortedClients: Metric!

  # The average number of current transactions executing on an Aurora database instance per second.
  activeTransactions: Metric!

  # The amount of time that a binary log replica DB cluster running on Aurora MySQL-Compatible Edition lags behind the binary log replication source.
  auroraBinlogReplicaLag: Metric!

  # Relation: Cluster to which this Aurora Instance belongs
  auroraCluster: AwsAuroraCluster

  # For an Aurora replica, the amount of lag when replicating updates from the primary instance.
  auroraReplicaLag: Metric!

  # The maximum amount of lag between the primary instance and each Aurora DB instance in the DB cluster.
  auroraReplicaLagMaximum: Metric!

  # The minimum amount of lag between the primary instance and each Aurora DB instance in the DB cluster.
  auroraReplicaLagMinimum: Metric!

  # The difference between the target backtrack window and the actual backtrack window.
  backtrackWindowActual: Metric!

  # The number of times that the actual backtrack window is smaller than the target backtrack window for a given period of time.
  backtrackWindowAlert: Metric!

  # The average number of transactions in the database that are blocked per second.
  blockedTransactions: Metric!

  # The percentage of requests that are served by the buffer cache.
  bufferCacheHitRatio: Metric!

  # Relation: Cloud Account to which this Aurora Instance belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this Aurora Cluster belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # Aurora Cluster to which Instance belongs
  clusterIdentifier: String

  # The average duration of commit operations.
  commitLatency: Metric!

  # The average number of commit operations per second.
  commitThroughput: Metric!

  # The number of attempts to connect to an instance, whether successful or not.
  connectionAttempts: Metric!

  # The number of CPU credits that an instance has accumulated, reported at 5-minute intervals.
  cpuCreditBalance: Metric!

  # The number of CPU credits consumed during the specified period, reported at 5-minute intervals.
  cpuCreditUsage: Metric!

  # The percentage of CPU used by an Aurora DB instance.
  cpuUtilization: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # The number of client network connections to the database instance.
  databaseConnections: Metric!

  # Aurora Instance Database Name
  databaseName: String

  # The average duration of requests such as example, create, alter, and drop requests.
  ddlLatency: Metric!

  # The average number of DDL requests per second.
  ddlThroughput: Metric!

  # The average number of deadlocks in the database per second.
  deadlocks: Metric!

  # The average duration of delete operations.
  deleteLatency: Metric!

  # The average number of delete queries per second.
  deleteThroughput: Metric!

  # The number of outstanding read/write requests waiting to access the disk.
  diskQueueDepth: Metric!

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String

  # The average duration of inserts, updates, and deletes.
  dmlLatency: Metric!

  # The average number of inserts, updates, and deletes per second.
  dmlThroughput: Metric!
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Aurora Instance Engine Name
  engineName: String

  # The amount of time that the instance has been running.
  engineUptime: Metric!

  # Aurora Instance Engine Version
  engineVersion: String

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The amount of local storage available.
  freeLocalStorage: Metric!

  # The amount of available random access memory.
  freeableMemory: Metric!
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # The average number of insert operations per second.
  insertLatency: Metric!

  # The average number of failed login attempts per second.
  insertThroughput: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The average number of failed login attempts per second.
  loginFailures: Metric!

  # The age of the oldest unvacuumed transaction ID, in transactions.
  maximumUsedTransactionIDs: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Aurora Instance name
  name: String

  # The amount of network throughput received from clients by each instance in the Aurora MySQL DB cluster.
  networkReceiveThroughput: Metric!

  # The amount of network throughput both received from and transmitted to clients by each instance in the Aurora MySQL DB cluster.
  networkThroughput: Metric!

  # The amount of network throughput sent to clients by each instance in the Aurora DB cluster. 
  networkTransmitThroughput: Metric!

  # The number of binlog files generated.
  numBinaryLogFiles: Metric!

  # The average number of queries executed per second.
  queries: Metric!

  # The lag when replicating updates from the primary RDS PostgreSQL instance to other nodes in the cluster.
  rdsToAuroraPostgreSQLReplicaLag: Metric!

  # The average number of disk I/O operations per second.
  readIOPS: Metric!

  # The average amount of time taken per disk I/O operation.
  readLatency: Metric!

  # The average number of bytes read from disk per second.
  readThroughput: Metric!

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The amount of disk space consumed by replication slot files.
  replicationSlotDiskUsage: Metric!

  # The percentage of requests that are served by the Resultset cache.
  resultSetCacheHitRatio: Metric!

  # The undo logs that record committed transactions with delete-marked records
  rollbackSegmentHistoryListLength: Metric!

  # The total time spent acquiring row locks for InnoDB tables.
  rowLockTime: Metric!

  # The average amount of time for select operations.
  selectLatency: Metric!

  # The average number of select queries per second.
  selectThroughput: Metric!

  # The current state of the Aurora DB Instance.
  state: State

  # The amount of network throughput received from the Aurora storage subsystem by each instance in the DB cluster.
  storageNetworkReceiveThroughput: Metric!

  # The amount of network throughput received from and sent to the Aurora storage subsystem by each instance in the Aurora MySQL DB cluster.
  storageNetworkThroughput: Metric!

  # The amount of network throughput sent to the Aurora storage subsystem by each instance in the Aurora MySQL DB cluster.
  storageNetworkTransmitThroughput: Metric!

  # The total size of the binlog files.
  sumBinaryLogSize: Metric!

  # The amount of swap space used. This metric is available for the Aurora PostgreSQL DB instance classes 
  swapUsage: Metric!

  # The amount of disk space consumed by transaction logs on the Aurora PostgreSQL DB instance.
  transactionLogsDiskUsage: Metric!

  # Entity type.
  type: String!

  # The average amount of time taken for update operations.
  updateLatency: Metric!

  # The average number of updates per second.
  updateThroughput: Metric!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The number of Aurora storage write records generated per second. 
  writeIOPS: Metric!

  # The average amount of time taken per disk I/O operation.
  writeLatency: Metric!

  # The average number of bytes written to persistent storage every second.
  writeThroughput: Metric!
}

# AWS Auto Scaling Group entity
type AwsAutoScalingGroup implements Entity & HealthEntity {
  # Cloud Account to which this CloudFront belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The number of instances that the Auto Scaling group attempts to maintain.
  groupDesiredCapacity: Metric!

  # The number of instances that are running as part of the Auto Scaling group. This metric does not include instances that are pending or terminating.
  groupInServiceInstances: Metric!

  # The groupInServiceInstancesPercent metric provides percentage of instances in service over desired number of instances.
  groupInServiceInstancesPercent: Metric!

  # The maximum size of the Auto Scaling group.
  groupMaxSize: Metric!

  # The minimum size of the Auto Scaling group.
  groupMinSize: Metric!

  # The number of instances that are pending. A pending instance is not yet in service. This metric does not include instances that are in service or terminating.
  groupPendingInstances: Metric!

  # The number of instances that are in a Standby state. Instances in this state are still running but are not actively in service.
  groupStandbyInstances: Metric!

  # The number of instances that are in the process of terminating. This metric does not include instances that are in service or pending.
  groupTerminatingInstances: Metric!

  # The total number of instances in the Auto Scaling group. This metric identifies the number of instances that are in service, pending, and terminating.
  groupTotalInstances: Metric!
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type AwsCloudAccount {
  displayName: String!
  entityId: ID!
}

type AwsCloudAccountConfiguration implements CloudAccountConfigurationInterface {
  accountId: ID!
  arn: String!
  enabled: Boolean!
  externalIdMasked: String!
  metricsTag: String
  regions: [AwsRegion!]!
  services: [AwsService!]!
}

input AwsCloudAccountConfigurationInput {
  arn: String!
  metricsTag: String!
  regions: [String!]!
  services: [String!]!
}

type AwsCloudAccountEditWizardSession {
  externalId: Guid!
  sessionId: Guid!
}

type AwsCloudAccountWizardSession {
  accountId: ID!
  externalId: Guid!
  sessionId: Guid!
}

# AWS CloudFront entity
type AwsCloudFrontDistribution implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The total number of bytes downloaded by viewers for GET, HEAD, and OPTIONS requests.
  bytesDownloaded: Metric!

  # The total number of bytes that viewers uploaded to your origin with CloudFront, using POST and PUT requests.
  bytesUploaded: Metric!

  # Cloud Account to which this CloudFront belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String

  # Distribution ID.
  distributionId: String!

  # Domain name.
  domainName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name 
  name: String

  # The percentage of all viewer requests for which the responses HTTP status code is 4xx.
  rateOf4xxErrors: Metric!

  # The percentage of all viewer requests for which the responses HTTP status code is 5xx.
  rateOf5xxErrors: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The total number of viewer requests received by CloudFront, for all HTTP methods and for both HTTP and HTTPS requests.
  requests: Metric!

  # The percentage of all viewer requests for which the responses HTTP status code is 4xx or 5xx.
  totalErrorRate: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# EBS entity 
type AwsEBS implements AlertingEntity & Entity & HealthEntity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The Availability Zone of the volume.
  availabilityZone: String

  # Avg Read Latency- The average time is taken to complete one read operation.(ms/Operation)
  averageReadLatency: Metric!

  # Avg Write Latency- The average time is taken to complete one write operation.(ms/Operation)
  averageWriteLatency: Metric!

  # Provides information about the percentage of I/O credits (for gp2) or throughput credits (for st1 and sc1) remaining in the burst bucket.
  burstBalance: Metric!

  # Cloud Account to which this EBS volume belongs.
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this volume belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String

  # Relation: List of ec2Host to which this ebsVolume is attached.
  ec2Host: [Host!]
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # The metricsTag of the volume.
  metricsTag: String

  # Entity name 
  name: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # This field represents the EBS volume size.
  size: Int

  # This field represents the EBS volume state
  state: State

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The total amount of read and write operations (normalized to 256K capacity units) consumed in a specified period of time.
  # For example, a 1024K I/O would count as 4 consumed IOPS.
  volumeConsumedReadWriteOps: Metric!

  # EBS volume ID
  volumeId: String!

  # The total number of seconds in a specified period of time when no read or write operations were submitted.
  volumeIdleTime: Metric!

  # EBS volume name
  volumeName: String

  # The number of read and write operation requests waiting to be completed in a specified period of time.
  volumeQueueLength: Metric!

  # Provides information on the read operations in a specified period of time.
  volumeReadBytes: Metric!

  # The total number of read operations in a specified period of time.
  volumeReadOps: Metric!

  # The percentage of I/O operations per second (IOPS) delivered of the total IOPS provisioned for an Amazon EBS volume.
  volumeThroughputPercentage: Metric!

  # The total number of read and write operations in a specified period of time.
  volumeTotalOps: Metric!

  # The total number of seconds spent by all read operations that completed in a specified period of time. 
  volumeTotalReadTime: Metric!

  # The total number of seconds spent by all write operations that completed in a specified period of time.
  volumeTotalWriteTime: Metric!

  # This field represents the EBS volume type
  volumeType: String

  # Provides information on the write operations in a specified period of time. 
  volumeWriteBytes: Metric!

  # The total number of write operations in a specified period of time. 
  volumeWriteOps: Metric!
}

# ElasticFileSystem 
type AwsEFS implements AlertingEntity & Entity & HealthEntity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The number of burst credits that a file system has.
  burstCreditBalance: Metric!

  # The number of client connections to a file system.
  clientConnections: Metric!

  # Cloud Account to which this EFS service belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # The number of bytes for each file system read operation .
  dataReadIOBytes: Metric!

  # The number of bytes for each file write operation.
  dataWriteIOBytes: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Filesystem ID of EFS.
  fileSystemId: String!
  healthScore: HealthScore

  # Relation: Service to Host (EFS mounted on which EC2 instance)
  hosts: [Host!]

  # Unique identifier of an entity
  id: ID!

  # Percentage of MetadataIOBytes through PermittedThroughput
  ioPercentage: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The deprecated lifecycle phase of the file system.
  lifecycleState: String @deprecated(reason: "State object is introduced, hence state attributes are changed to State Type")

  # The number of bytes for each metadata operation.
  metadataIOBytes: Metric!

  # The number of metered bytes for each file system operation, including data read, data write, and metadata operations, with read operations metered at one-third the rate of other operations.
  meteredIOBytes: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # EFS name
  name: String

  # Metric Shows how close a file system is to reaching the I/O limit of the General Purpose performance mode.
  percentIOLimit: Metric!

  # The maximum amount of throughput that a file system can drive.
  permittedThroughput: Metric!

  # The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for file systems using ThroughputMode set to provisioned.
  provisionedThroughputInMibps: Float

  # Region where EFS file system has been mounted from AWS instance
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The lifecycle phase of the file system.
  state: State

  # TThe size of the file system in bytes, including the amount of data stored in the EFS Standard and EFS Standard-Infrequent Access (EFS Standard-IA) storage classes.
  storageBytes: Metric!

  # Metric Shows the amount of time that has passed since the last successful sync to the destination file system in a replication configuration.
  timeSinceLastSync: Metric!

  # The actual number of bytes for each file system operation, including data read, data write, and metadata operations.
  totalIOBytes: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# AWS Elastic load balancer (Classic Load Balancer)
type AwsELB implements Entity & HealthEntity {
  # The Availability Zone of the instance.
  availabilityZone: String

  # The number of connections that were not successfully established between the load balancer and the registered instances.
  backendConnectionErrors: Metric!

  # The backendConnectionErrorsRate metric provides percentage of backendconnection erros over total request count
  backendConnectionErrorsRate: Metric!

  # Relation: Cloud Account to which this ELB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this load balacer belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # The number of requests that do not comply with RFC 7230.
  desyncMitigationModeNonCompliantRequestCount: Metric!

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String

  # DNS name of ELB
  dnsName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # ELB healthcheck healthythreshold 
  healthcheckHealthyThreshold: String

  # ELB healthcheck interval 
  healthcheckInterval: String

  # ELB healthcheck target 
  healthcheckTarget: String

  # ELB healthcheck timeout 
  healthcheckTimeout: String

  # ELB healthcheck unhealthythreshold 
  healthcheckUnhealthyThreshold: String

  # The number of healthy instances registered with your load balancer.
  healthyHostCount: Metric!

  # The HealthyHostPercent metric provides percentage of healthy hosts over all the hosts(healthy & unhealthy)
  healthyHostPercent: Metric!

  # The number of HTTP 2XX response codes generated by registered instances.
  httpCodeBackend2xx: Metric!

  # The number of HTTP 3XX response codes generated by registered instances.
  httpCodeBackend3xx: Metric!

  # The number of HTTP 4XX response codes generated by registered instances.
  httpCodeBackend4xx: Metric!

  # The number of HTTP 5XX response codes generated by registered instances.
  httpCodeBackend5xx: Metric!

  # The number of HTTP 4XX client error codes generated by the load balancer.
  httpCodeELB4xx: Metric!

  # The number of HTTP 5XX client error codes generated by the load balancer.
  httpCodeELB5xx: Metric!

  # The httpCodeELB5xxRate metric provides percentage of 5xx erros over total request count
  httpCodeELB5xxRate: Metric!

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The total time elapsed, in seconds, from the time the load balancer sent the request to a registered instance until the instance started to send the response headers.
  latency: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # ELB name
  name: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The number of requests completed or connections made during the specified interval (1 or 5 minutes).
  requestCount: Metric!

  # This field represents type of Elastic load balancer. Valid only for load balancers in a VPC.
  scheme: String

  # The total number of requests that were rejected because the surge queue is full.
  spilloverCount: Metric!

  # The total number of requests (HTTP listener) or connections (TCP listener) that are pending routing to a healthy instance. 
  surgeQueueLength: Metric!

  # Entity type.
  type: String!

  # The number of unhealthy instances registered with your load balancer. 
  unHealthyHostCount: Metric!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# AwsElasticBeanstalkEnvironment entity
type AwsElasticBeanstalkEnvironment implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Cloud Account to which this AwsElasticBeanstalkEnvironment belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String

  # Unique identifier of the AwsElasticBeanstalkEnvironment.
  distributionId: String!
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name.
  name: String

  # Average latency for the slowest x percent of requests over the last 10 seconds, where x is the difference between
  # the number and 100. For example, p99 1.403 indicates the slowest 1% of requests over the last 10 seconds had an
  # average latency of 1.403 seconds.
  p999: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Number of requests handled by the web server per second over the last 10 seconds. Shown as an average r/sec (requests per second) in the EB CLI and Environment health page.
  requestCount: Metric!

  # Number of requests that resulted in 2xx status code over the last 10 seconds.
  # For example, successful requests return a 200 OK.
  status2xx: Metric!

  # Number of requests that resulted in 3xx status code over the last 10 seconds.
  # For example, redirects are a 301.
  status3xx: Metric!

  # Number of requests that resulted in 4xx status code over the last 10 seconds.
  # For example, 404 is returned if the URL entered doesn't match any resources in the application.
  status4xx: Metric!

  # Number of requests that resulted in 5xx status code over the last 10 seconds.
  # For example, 503 is returned if the web server responds with this status code when it is currently unable to handle
  # the request due to a temporary overloading or maintenance of the server.
  status5xx: Metric!

  # The status5xxPercent metric provides percentage of requests that returned 5XX errors over total number of requests.
  status5xxPercent: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# AWS Lambda Entity
type AwsLambda implements AlertingEntity & Entity & HealthEntity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Relation: Cloud Account to which this lambda function belongs
  cloudAccount: CloudAccount

  # The cloud account id for AWS Lambda entity
  cloudAccountId: String

  # Cloudprovider name
  cloudProvider: String

  # The number of function instances that are processing events.
  concurrentExecutions: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # The number of times that Lambda attempts to send an event to a dead-letter queue but fails.
  deadLetterErrors: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String

  # The amount of time that your function code spends processing an event.
  duration: Metric!
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # The error rate metric is used in health score for AWS Lambda, which sum of errors by sum of innvocations.
  errorRate: Metric!

  # The number of invocations that result in a function error. 
  errors: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # The number of times that your function code is invoked.
  invocations: Metric!

  # The age is the amount of time between when a stream receives the record and when the event source mapping sends the event to the function.
  iteratorAge: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # This field represents the status of the last update that was performed on the lambda function
  lastUpdateStatus: String

  # This field represents the reason code for the last update that was performed on the lambda function
  lastUpdateStatusReasonCode: String

  # This field represents the amount of memory available to the lambda function at runtime
  memorySize: Int
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # The metricsTag of the lambda function
  metricTag: String

  # Entity name
  name: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity resource
  resource: String

  # This field represents the current status of the lambda function
  state: State

  # The throttle rate metric is used in health score for AWS Lambda, which is sum of throttle by total number of throllet and innvocations.
  throttleRate: Metric!

  # The number of invocation requests that are throttled.
  throttles: Metric!

  # This field represents the amount of time in seconds that Lambda allows a lambda function to run before stopping it
  timeout: Int

  # Relation: lambda functions are triggered by aws s3
  triggeringS3Buckets: [AwsS3]

  # Entity type.
  type: String!

  # For a Region the number of events that functions without reserved concurrency are processing.
  unreservedConcurrentExecutions: Metric!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Function version
  version: String
}

# AWS NAT Gateway
type AwsNatGateway implements Entity & HealthEntity & StatefulEntity {
  # The total number of concurrent active TCP connections through the NAT gateway.
  activeConnectionCount: Metric!

  # Bandwidth of AWS NAT Gateway
  bandwidth: Metric!

  # The number of bytes received by the NAT gateway from the destination.
  bytesInFromDestination: Metric!

  # The number of bytes received by the NAT gateway from clients in your VPC.
  bytesInFromSource: Metric!

  # The number of bytes sent out through the NAT gateway to the destination.
  bytesOutToDestination: Metric!

  # The number of bytes sent through the NAT gateway to the clients in your VPC.
  bytesOutToSource: Metric!

  # Relation: Cloud Account to which this ALB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this NAT gateway belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # The number of connection attempts made through the NAT gateway.
  connectionAttemptCount: Metric!

  # The number of connections established through the NAT gateway.
  connectionEstablishedCount: Metric!

  # The ConnectionEstablishedPercent metric provides percentage of Connection Established count over Connection Attempt Count.
  connectionEstablishedPercent: Metric!

  # NAT Gateway connectivity type  (private | public)
  connectivityType: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # The number of times the NAT gateway could not allocate a source port.
  errorPortAllocation: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # NAT Gateway name
  gatewayName: String
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # The number of connections that transitioned from the active state to the idle state. An active connection transitions to idle if it was not closed gracefully and there was no activity for the last 350 seconds.
  idleTimeoutCount: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # NAT Gateway Id
  natGatewayId: String

  # The number of packets dropped by the NAT gateway.
  packetsDropCount: Metric!

  # The number of packets received by the NAT gateway from the destination.
  packetsInFromDestination: Metric!

  # The number of packets received by the NAT gateway from clients in your VPC.
  packetsInFromSource: Metric!

  # The number of packets sent out through the NAT gateway to the destination.
  packetsOutToDestination: Metric!

  # The number of packets sent through the NAT gateway to the clients in your VPC.
  packetsOutToSource: Metric!

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # State of NAT Gateway(pending | failed | available | deleting | deleted).
  state: State

  # The ID of the subnet in which the NAT gateway is located.
  subnetId: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # VPC id in which the NAT Gateway existing.
  vpcId: String
}

# AWS RDS
type AwsRDS implements Entity & HealthEntity & StatefulEntity {
  # The Availability Zone of the instance.
  availabilityZone: String

  # The amount of disk space occupied by binary logs.
  binLogDiskUsage: Metric!

  # The percent of General Purpose SSD (gp2) burst-bucket I/O credits available.
  burstBalance: Metric!

  # Cloud Account to which this RDS belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # The number of earned CPU credits that an instance has accrued.
  cpuCreditBalance: Metric!

  # The number of CPU credits spent by the instance for CPU utilization. 
  cpuCreditUsage: Metric!

  # The percentage of CPU utilization.
  cpuUtilization: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # All instances in a database class. For example, we can aggregate metrics for all instances that belong to the database class db.r5.large.
  databaseClass: String

  # A number of instances can be entangled in a cluster. 
  databaseClusterIdentifier: String

  # The number of client network connections to the database instance.
  databaseConnections: Metric!

  # Unique identifier of an instance.
  dbInstanceIdentifier: String!

  # Database Name
  dbName: String

  # The number of outstanding I/Os (read/write requests) waiting to access the disk.
  diskQueueDepth: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # The identified engine name only. For example, we can aggregate metrics for all instances that have the engine name postgres.
  engineName: String

  # Information about an RDS engine version. Example: engineName = "mysql" and versions ="5.7.42"
  engineVersion: String

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The number of failed Microsoft SQL Server Agent jobs during the last minute.
  failedSQLServerAgentJobsCount: Metric!

  # The amount of available storage space.
  freeStorageSpace: Metric!

  # The amount of available random access memory.
  freeableMemory: Metric!
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The maximum transaction IDs that have been used.
  maximumUsedTransactionIDs: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # The metricsTag of the volume.
  metricsTag: String

  # Unique identifier of an instance.
  name: String

  # The incoming (receive) network traffic on the DB instance, including both customer database traffic and Amazon RDS traffic used for monitoring and replication.
  networkReceiveThroughput: Metric!

  # The outgoing (transmit) network traffic on the DB instance, including both customer database traffic and Amazon RDS traffic used for monitoring and replication.
  networkTransmitThroughput: Metric!

  # The lagging size of the replica lagging the most in terms of write-ahead log (WAL) data received. Applies to PostgreSQL.
  oldestReplicationSlotLag: Metric!

  # The average number of disk read I/O operations per second.
  readIOPS: Metric!

  # The average amount of time taken per disk I/O operation.
  readLatency: Metric!

  # The average number of bytes read from disk per second.
  readThroughput: Metric!

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # For read replica configurations, the amount of time a read replica DB instance lags behind the source DB instance.
  replicaLag: Metric!

  # The disk space used by replication slot files.
  replicationSlotDiskUsage: Metric!

  # This field represents the RDS state
  state: State

  # The amount of swap space used on the DB instance.
  swapUsage: Metric!

  # The disk space used by transaction logs. 
  transactionLogsDiskUsage: Metric!

  # The size of transaction logs generated per second.
  transactionLogsGeneration: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The average number of disk write I/O operations per second.
  writeIOPS: Metric!

  # The average amount of time taken per disk I/O operation.
  writeLatency: Metric!

  # The average number of bytes written to disk per second.
  writeThroughput: Metric!
}

type AwsRegion {
  code: String!
}

# AWS S3 
type AwsS3 implements AlertingEntity & Entity & HealthEntity {
  # The total size of all objects for the specified Outposts account.
  accountUsedBytes: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The total number of HTTP requests made to an Amazon S3 bucket.
  allRequests: Metric!

  # The amount of data in bytes stored in a bucket.
  bucketSizeBytes: Metric!

  # The total size of all objects for the given bucket.
  bucketUsedBytes: Metric!

  # The number of bytes downloaded for requests made to an Amazon S3 bucket, where the response includes a body.
  bytesDownloaded: Metric!

  # The total number of bytes of objects pending replication for a given replication rule.
  bytesPendingReplication: Metric!

  # The number of bytes uploaded that contain a request body, made to an Amazon S3 bucket.
  bytesUploaded: Metric!

  # Cloud Account to which this S3 bucket belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # The number of HTTP DELETE requests made for objects in an Amazon S3 bucket.
  # This also includes Delete Multiple Objects requests.
  # This metric shows the number of requests, not the number of objects deleted.
  deleteRequests: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The per-request time from the complete request being received by an Amazon S3 bucket to when the
  # response starts to be returned.
  firstByteLatency: Metric!

  # The number of HTTP GET requests made for objects in an Amazon S3 bucket. This doesn't include list operations.
  getRequests: Metric!

  # The number of HTTP HEAD requests made to an Amazon S3 bucket.
  headRequests: Metric!
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The number of HTTP requests that list the contents of a bucket.
  listRequests: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # S3 bucket name.
  name: String

  # The number of HTTP 4xx client error status code requests made to an Amazon S3 bucket.
  numberOf4xxErrors: Metric!

  # The number of HTTP 5xx server error status code requests made to an Amazon S3 bucket with a value of either 0 or 1.
  # The average statistic shows the error rate, and the sum statistic shows the count of that type of error,
  # during each period.
  numberOf5xxErrors: Metric!

  # The total number of objects stored in a bucket for all storage classes.
  numberOfObjects: Metric!

  # The number of operations pending replication for a given replication rule.
  operationsPendingReplication: Metric!

  # The count of free bytes available on an Outpost to store customer data.
  outpostFreeBytes: Metric!

  # The total provisioned capacity in bytes for an Outpost.
  outpostTotalBytes: Metric!

  # The number of HTTP POST requests made to an Amazon S3 bucket.
  postRequests: Metric!

  # The number of HTTP PUT requests made for objects in an Amazon S3 bucket.
  putRequests: Metric!

  # Percentage of 5xx request against all requests to S3 bucket.
  rateOf5xxError: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The maximum number of seconds by which the replication destination Region is behind the source Region for a given replication rule.
  replicationLatency: Metric!

  # The number of bytes of data returned with Amazon S3 SELECT Object Content requests in an Amazon S3 bucket.
  selectBytesReturned: Metric!

  # The number of bytes of data scanned with Amazon S3 SELECT Object Content requests in an Amazon S3 bucket.
  selectBytesScanned: Metric!

  # The number of Amazon S3 SELECT Object Content requests made for objects in an Amazon S3 bucket.
  selectRequests: Metric!

  # Types of storage.
  storageType: String

  # The elapsed per-request time from the first byte received to the last byte sent to an Amazon S3 bucket.
  totalRequestLatency: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# AWS SNS entities for Topic
type AwsSNSTopic implements Entity & HealthEntity {
  # Relation: Cloud Account to which this ALB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this SNS Topic belongs.
  cloudAccountId: String!

  # Cloud provider Name.
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # SNS Topic name
  name: String

  # The TopicSuccessRate metric provides percentage of messages sent successfully
  notificationSuccessRate: Metric!

  # The number of messages published to your Amazon SNS topics.
  numberOfMessagesPublished: Metric!

  # The number of messages successfully delivered from your Amazon SNS topics to subscribing endpoints.
  numberOfNotificationsDelivered: Metric!

  # The number of messages that Amazon SNS failed to deliver.
  numberOfNotificationsFailed: Metric!

  # The number of messages that couldn't be moved to a dead-letter queue.
  numberOfNotificationsFailedToRedriveToDlq: Metric!

  # The number of messages that were rejected by subscription filter policies.
  numberOfNotificationsFilteredOut: Metric!

  # The number of messages that were rejected by subscription filter policies because the messages' attributes are invalid  for example, because the attribute JSON is incorrectly formatted.
  numberOfNotificationsFilteredOutInvalidAttributes: Metric!

  # The number of messages that were rejected by subscription filter policies because the messages have no attributes.
  numberOfNotificationsFilteredOutNoMessageAttributes: Metric!

  # The number of messages that have been moved to a dead-letter queue.
  numberOfNotificationsRedrivenToDlq: Metric!

  # Cloud Account ID who owns SNS service.
  owner: String

  # The size of messages published.
  publishSize: Metric!

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The number of confirmed subscriptions for the topic.
  subscriptionsConfirmed: Int

  # The number of deleted subscriptions for the topic.
  subscriptionsDeleted: Int

  # The number of subscriptions pending confirmation for the topic.
  subscriptionsPending: Int

  # ARN of SNS Topic.
  topicARN: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# AWS Simple Queue Service
type AwsSQS implements Entity & HealthEntity {
  # The approximate age of the oldest non-deleted message in the queue.
  approximateAgeOfOldestMessage: Metric!

  # The number of messages in the queue that are delayed and not available for reading immediately.
  approximateNumberOfMessagesDelayed: Metric!

  # The number of messages that are in flight.
  approximateNumberOfMessagesNotVisible: Metric!

  # The number of messages available for retrieval from the queue.
  approximateNumberOfMessagesVisible: Metric!

  # Relation: Cloud Account to which this ALB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this SQS Topic belongs.
  cloudAccountId: String!

  # Cloud provider Name.
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # The time when the queue was created in seconds.
  createdTimestamp: String

  # The default delay on the queue in seconds.
  delaySeconds: Int

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # The time when the queue was last changed in seconds.
  lastModifiedTimestamp: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The limit of how many bytes a message can contain before Amazon SQS rejects it.
  maximumMessageSize: Int

  # The length of time, in seconds, for which Amazon SQS retains a message.
  messageRetentionPeriod: Int
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # SQS Queue name
  name: String

  # The number of ReceiveMessage API calls that did not return a message.
  numberOfEmptyReceives: Metric!

  # The number of messages deleted from the queue.
  numberOfMessagesDeleted: Metric!

  # The number of messages returned by calls to the ReceiveMessage action.
  numberOfMessagesReceived: Metric!

  # The number of messages added to a queue.
  numberOfMessagesSent: Metric!

  # The Amazon resource name (ARN) of the queue.
  queueArn: String

  # The length of time, in seconds, for which the ReceiveMessage action waits for a message to arrive.
  receiveMessageWaitTimeSeconds: Int

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The size of messages added to a queue.
  sentMessageSize: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The visibility timeout for the queue.
  visibilityTimeout: Int
}

type AwsService {
  id: String!
}

type AwsTestConnectionResult {
  errorMessage: String
  success: Boolean!
}

# AWS Transit Gateway
type AwsTransitGateway implements Entity & HealthEntity & StatefulEntity {
  # The number of bytes dropped because they matched a blackhole route on the transit gateway attachment.
  bytesDropCountBlackhole: Metric!

  # The number of bytes dropped because they did not match a route on the transit gateway attachment.
  bytesDropCountNoRoute: Metric!

  # The BytesDropPercentage metric provides percentage of Bytes Drop over Bytes In
  bytesDropPercentage: Metric!

  # The number of bytes received by the transit gateway from the attachment.
  bytesIn: Metric!

  # The number of bytes sent from the transit gateway to the attachment.
  bytesOut: Metric!

  # Relation: Cloud Account to which this ALB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this Transit gateway belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String

  # Indicates whether DNS support is enabled.
  dnsSupport: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Transit Gateway name
  gatewayName: String
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Indicates whether multicast is enabled on the transit gateway.
  multicastSupport: String

  # Entity name
  name: String

  # The ID of the AWS account that owns the transit gateway.
  ownerId: String

  # The number of packets dropped because they matched a blackhole route on the transit gateway attachment.
  packetDropCountBlackhole: Metric!

  # The number of packets dropped because they did not match a route on the transit gateway attachment.
  packetDropCountNoRoute: Metric!

  # The PacketsDropPercentage metric provides percentage of packets Drop over packets in
  packetsDropPercentage: Metric!

  # The number of packets received by the transit gateway from the attachment.
  packetsIn: Metric!

  # The number of packets sent by the transit gateway to the attachment.
  packetsOut: Metric!

  # The ID of the default propagation route table.
  propagationDefaultRouteTableId: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The ID of the resource.
  resourceId: String

  # The ID of the AWS account that owns the resource.
  resourceOwnerId: String

  # The resource type (vpc | vpn | direct-connect-gateway | connect | peering | tgw-peering).
  resourceType: String

  # State of Transit Gateway(pending | available | modifying | deleting | deleted).
  state: State

  # The ID of the Transit attachment.
  transitGatewayAttachmentId: String

  # The Name of the Transit attachment.
  transitGatewayAttachmentName: String

  # Transit Gateway Id
  transitGatewayId: String!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Indicates whether Equal Cost Multipath Protocol support is enabled.
  vpnEcmpSupport: String
}

# AWS VPN (Virtual Private Network)
type AwsVPN implements Entity & HealthEntity & StatefulEntity {
  # Relation: Cloud Account to which this ALB belongs
  cloudAccount: CloudAccount

  # The cloudaccountId of the cloudAccount to which this AWS VPN  belongs.
  cloudAccountId: String!

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # The ID of the customer gateway at your end of the VPN connection.
  customerGatewayId: String

  # Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The current state of the gateway association (associated | not-associated | associating | disassociating).
  gatewayAssociationState: String
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The current state of the VPN connection (pending | available | deleting | deleted).
  state: State

  # The ID of the transit gateway associated with the VPN connection.
  transitGatewayId: String

  # The bytes received on the AWS side of the connection through the VPN tunnel from a customer gateway.Each metric data point represents the number of bytes received after the previous data point.
  tunnelDataIn: Metric!

  # The bytes sent from the AWS side of the connection through the VPN tunnel to the customer gateway. Each metric data point represents the number of bytes sent after the previous data point.
  tunnelDataOut: Metric!

  # The state of the tunnels. For static VPNs, 0 indicates DOWN and 1 indicates UP. For BGP VPNs, 1 indicates ESTABLISHED and 0 is used for all other states. For both types of VPNs, values between 0 and 1 indicate at least one tunnel is not UP
  tunnelState: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The current state of the VPC attachment to the virtual private gateway(attaching | attached | detaching | detached).
  vpcAttachmentState: String

  # The ID of the VPC attached to the virtual private gateway.
  vpcId: String

  # The category of the VPN connection. A value of VPN indicates an AWS VPN connection. A value of VPN-Classic indicates an AWS Classic VPN connection.
  vpnCategory: String

  # The type of VPN connection(ipsec.1).
  vpnConnectionType: String

  # The ID of the virtual private gateway at the AWS side of the VPN connection.
  vpnGatewayId: String

  # VPN Id
  vpnId: String!

  # VPN name
  vpnName: String
}

# Azure App Service
type AzureAppService implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The number of bound sockets existing in the sandbox.
  appConnections: Metric!

  # The average amount of memory used by the app, in megabytes (MiB)
  averageMemoryWorkingSet: Metric!

  # The average time taken for the app to serve requests, in seconds.  
  averageResponseTime: Metric!

  # The amount of incoming bandwidth consumed by the app in MiB.  
  bytesReceived: Metric!

  # The amount of outgoing bandwidth consumed by the app in MiB. 
  bytesSent: Metric!

  # Relation: Cloud Account to which this app service belongs
  cloudAccount: CloudAccount

  # The cloud account id for Azure function entity
  cloudAccountId: String

  # Name of the cloud provider for filtering purpose
  cloudProvider: String

  # The amount of CPU consumed by the app, in seconds
  cpuTime: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # The current number of Assemblies loaded across all AppDomains in this application.
  currentAssemblies: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # 5xx Error Rate
  errorRate5xx: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The number of times the generation 0 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  gen0Collections: Metric!

  # The number of times the generation 1 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  gen1Collections: Metric!

  # The number of times the generation 2 objects are garbage collected since the start of the app process.
  gen2Collections: Metric!

  # The total number of handles currently open by the app process. 
  handles: Metric!
  healthScore: HealthScore

  # The count of requests resulting in an HTTP status code = 200 but < 300. 
  http2xx: Metric!

  # The count of requests resulting in an HTTP status code = 300 but < 400.
  http3xx: Metric!

  # The count of requests resulting in an HTTP status code = 400 but < 500.  
  http4xx: Metric!

  # The count of requests resulting in an HTTP status code = 500 but < 600. 
  # The average statistic shows the error rate and the sum statistic shows the count of that type of error during each period.
  http5xx: Metric!

  # The count of requests resulting in an HTTP status code 101.
  http101: Metric!

  # The count of requests resulting in HTTP 401 status code.
  http401: Metric!

  # The count of requests resulting in HTTP 403 status code.
  http403: Metric!

  # The count of requests resulting in HTTP 404 status code. 
  http404: Metric!

  # The count of requests resulting in HTTP 406 status code.
  http406: Metric!

  # Unique identifier of an entity
  id: ID!

  # Azure App Service instance
  instance: String

  # The rate at which the app process is issuing bytes to I/O operations that don't involve data such as controls operations.
  ioOtherBytesPerSecond: Metric!

  # The rate at which the app process is issuing I/O operations that aren't read or write operations. 
  ioOtherOperationsPerSecond: Metric!

  # The rate at which the app process is reading bytes from I/O operations.
  ioReadBytesPerSecond: Metric!

  # The rate at which the app process is issuing read I/O operations.
  ioReadOperationsPerSecond: Metric!

  # The rate at which the app process is writing bytes to I/O operations. 
  ioWriteBytesPerSecond: Metric!

  # The rate at which the app process is issuing write I/O operations.
  ioWriteOperationsPerSecond: Metric!

  # Azure App Service Type 
  kind: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # The current amount of memory used by the app in MiB. 
  memoryWorkingSet: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # The metricsTag of the Azure function
  metricTag: String

  # App Service name
  name: String

  # Private Bytes is the current size in bytes of memory that the app process has allocated that can't be shared with other processes.
  privateBytes: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The total number of requests regardless of their resulting HTTP status code.
  requests: Metric!

  # The number of requests in the application request queue.
  requestsInApplicationQueue: Metric!

  # Azure App Service resourceId
  resourceId: String

  # The number of threads currently active in the app process.
  threads: Metric!

  # The current number of AppDomains loaded in this application.
  totalAppDomains: Metric!

  # The total number of AppDomains unloaded since the start of the application. 
  totalAppDomainsUnloaded: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

enum AzureAuthenticationState {
  FAIL
  PENDING
  SUCCESS
}

type AzureAuthenticationStateResponse {
  state: AzureAuthenticationState!
}

# Azure Blob Storage
type AzureBlobStorage implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The total number of HTTP requests made to an Azure Storage.
  allRequests: Metric!

  # The percentage of availability for the storage service or the specified API operation.
  # All unexpected errors result in reduced availability for the storage service or the specified API operation
  availbility: Metric!

  # The amount of data in bytes stored in a bucket.
  bucketSizeBytes: Metric!

  # The number of bytes downloaded for requests made to an Azure Storage, where the response includes a body.
  bytesDownloaded: Metric!

  # The number of bytes uploaded that contain a request body, made to an Azure Storage.
  bytesUploaded: Metric!

  # Relation: Cloud Account to which this lambda function belongs
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Name of Azure Storage.
  name: String

  # The total number of objects stored in a bucket for all storage classes.
  numberOfObjects: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Azure Blob Storage resourceId
  resourceId: String

  # Azure Storage Type (Blob, File, Queue, Table)
  storageType: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Azure CDN entity
type AzureCdn implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # This is the ratio of the total bytes served from the cache compared to the total response bytes
  byteHitRatio: Metric!

  # Cloud Account to which this CDN resource belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Azure Front Door - CDN name
  name: String

  # The percentage of successful health probes from AFDX to backends
  originHealthPercentage: Metric!

  # The time calculated from when the request was sent by AFDX edge to the backend until AFDX received the last response byte from the backend
  originLatency: Metric!

  # The number of requests sent from AFDX to origin
  originRequestCount: Metric!

  # The percentage of all the client requests for which the response status code is 4XX
  percentage4XX: Metric!

  # The percentage of all the client requests for which the response status code is 5XX
  percentage5XX: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The number of client requests served by the HTTP/S proxy
  requestCount: Metric!

  # The number of bytes sent as requests from clients to AFDX
  requestSize: Metric!

  # Azure resourceId
  resourceId: String

  # The number of bytes sent as responses from HTTP/S proxy to clients
  responseSize: Metric!

  # The time calculated from when the client request was received by the HTTP/S proxy until the client acknowledged the last response byte from the HTTP/S proxy
  totalLatency: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The number of client requests processed by the Web Application Firewall
  webApplicationFirewallRequestCount: Metric!
}

type AzureCloudAccount {
  configuration: AzureCloudAccountConfiguration
  displayName: String!
  entityId: ID!
}

type AzureCloudAccountConfiguration implements CloudAccountConfigurationInterface {
  clientId: String
  enabled: Boolean!
  metricsTag: String
  subscriptions: [AzureSubscription!]!
  tenantId: String!
}

input AzureCloudAccountConfigurationInput {
  metricsTag: String!
  subscriptions: [AzureSubscriptionInput!]!
}

# Azure Cosmos DB
type AzureCosmosDb implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Autoscale Max Throughput. 
  autoscaleMaxThroughput: Metric!

  # The amount of storage available.
  availableStorage: Metric!

  # Number of Cassandra connections that were closed reported at a 1 minute granularity.
  cassandraConnectionClosures: Metric!

  # Cassandra Connector Average ReplicationLatency. 
  cassandraConnectorAvgReplicationLatency: Metric!

  # Cassandra Connector Replication Health Status. 
  cassandraConnectorReplicationHealthStatus: Metric!

  # RUs consumed for Cassandra requests made.  
  cassandraRequestCharges: Metric!

  # Number of Cassandra requests made. 
  cassandraRequests: Metric!

  # Relation: Cloud Account to which this Azure Cosmos DB belongs
  cloudAccount: CloudAccount

  # The cloud account id for Azure Cosmos DB entity
  cloudAccountId: String

  # Name of the cloud provider for filtering purpose
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Total data usage reported at 5 minutes granularity.
  dataUsage: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String

  # Total document count reported at 5 minutes, 1 hour and 1 day granularity.
  documentCount: Metric!

  # Total storage quota reported at 5 minutes granularity.
  documentQuota: Metric!
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Request Units consumed for Gremlin requests made. 
  gremlinRequestCharges: Metric!

  # Number of Gremlin requests made. 
  gremlinRequests: Metric!
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Total index usage reported at 5 minutes granularity.
  indexUsage: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Count of metadata requests. Cosmos DB maintains system metadata collection for each account, that allows you to enumerate collections, databases,etc.
  metadataRequests: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # The metricsTag of the Azure Cosmos DB
  metricTag: String

  # Mongo Request Units Consumed.
  mongoRequestCharge: Metric!

  # Number of Mongo Requests Made. 
  mongoRequests: Metric!

  # Azure Cosmos DB name
  name: String

  # Max RU consumption percentage per minute. 
  normalizedRUConsumption: Metric!

  # Provisioned Throughput.
  provisionedThroughput: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # P99 Replication Latency across source and target regions for geo-enabled account.
  replicationLatency: Metric!

  # Azure Cosmos DB resourceId
  resourceId: String

  # Server Side Latency. 
  serverSideLatency: Metric!

  # Account requests availability at one hour or day or month granularity. 
  serviceAvailability: Metric!

  # Request Units consumed.
  totalRequestUnits: Metric!

  # Number of requests made. 
  totalRequests: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

input AzureCredentialInput {
  clientId: String!
  clientSecret: String!
  tenantId: String!
}

# Add Entity description here
type AzureDatabasesName implements Entity & HealthEntity {
  # Allocated data storage. Not applicable to data warehouses.
  allocatedDataStorage: Metric!

  # Blocked by Firewall
  blockedByFirewall: Metric!

  # Cloud Account to which this entity belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Failed Connections
  connectionFailed: Metric!

  # Successful Connections
  connectionSuccessful: Metric!

  # Containment state of the database
  containmentState: String

  # CPU percentage
  cpuPercent: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Database Edition
  databaseEdition: String

  # Database ID
  databaseId: String

  # Database's server name
  databaseServer: String

  # Deadlocks. Not applicable to data warehouses.
  deadlock: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String

  # DTU Percentage. Applies to DTU-based databases.
  dtuConsumptionPercent: Metric!

  # DTU Limit. Applies to DTU-based databases.
  dtuLimit: Metric!

  # DTU used. Applies to DTU-based databases.
  dtuUsed: Metric!
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Elastic pool name
  elasticPoolName: String

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Log IO percentage. Not applicable to data warehouses.
  logWritePercent: Metric!

  # Max size of the the database
  maxSizeBytes: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Azure Entity name
  name: String

  # Data IO percentage
  physicalDataReadPercent: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Azure resourceId
  resourceId: String

  # Sessions percentage. Not applicable to data warehouses.
  sessionsPercent: Metric!

  # Data space used. Not applicable to data warehouses.
  storage: Metric!

  # Data space used percent. Not applicable to data warehouses or hyperscale databases.
  storagePercent: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Workers percentage. Not applicable to data warehouses.
  workersPercent: Metric!

  # In-Memory OLTP storage percent. Not applicable to data warehouses.
  xtpStoragePercent: Metric!
}

# Azure Event Hubs entity
type AzureEventHubs implements Entity & HealthEntity {
  # Total Active Connections for Microsoft.EventHub.
  activeConnections: Metric!

  # Capture Backlog for Microsoft.EventHub.
  captureBacklog: Metric!

  # Captured Bytes for Microsoft.EventHub.
  capturedBytes: Metric!

  # Captured Messages for Microsoft.EventHub.
  capturedMessages: Metric!

  # Cloud Account to which this Event Hubs belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Connections Closed for Microsoft.EventHub.
  connectionsClosed: Metric!

  # Connections Opened for Microsoft.EventHub.
  connectionsOpened: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Incoming Bytes for Microsoft.EventHub.
  incomingBytes: Metric!

  # Incoming Messages for Microsoft.EventHub.
  incomingMessages: Metric!

  # Incoming Requests for Microsoft.EventHub.
  incomingRequests: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Azure Event Hubs name
  name: String

  # CPU usage metric for Premium SKU namespaces.
  namespaceCpuUsage: Metric!

  # Memory usage metric for Premium SKU namespaces.
  namespaceMemoryUsage: Metric!

  # Outgoing Bytes for Microsoft.EventHub.
  outgoingBytes: Metric!

  # Outgoing Messages for Microsoft.EventHub.
  outgoingMessages: Metric!

  # Quota Exceeded Errors for Microsoft.EventHub.
  quotaExceededErrors: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Azure resourceId
  resourceId: String

  # Server Errors for Microsoft.EventHub.
  serverErrors: Metric!

  # The serverErrorsPercent metric provides percentage of requests that errored out over incoming requests.
  serverErrorsPercent: Metric!

  # Size of an EventHub in Bytes.
  size: Metric!

  # Successful Requests for Microsoft.EventHub.
  successfulRequests: Metric!

  # The successfulRequestsPercent metric provides percentage of requests that are successful over incoming requests.
  successfulRequestsPercent: Metric!

  # Throttled Requests for Microsoft.EventHub.
  throttledRequests: Metric!

  # The throttledRequestsPercent metric provides percentage of requests that are throttled over incoming requests.
  throttledRequestsPercent: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # User Errors for Microsoft.EventHub.
  userErrors: Metric!
}

# AZURE FILES 
type AzureFiles implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Metric Shows the percentage of availability for the storage service or the specified API operation.
  availability: Metric!

  # Relation: Cloud Account to which this lambda function belongs
  cloudAccount: CloudAccount

  # The cloud account id for Azure Files entity
  cloudAccountId: String

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Metric Shows the amount of egress data, in bytes.
  egress: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # The amount of storage used by the storage account's File service in bytes.
  fileCapacity: Metric!

  # The number of file in the storage account's File service.
  fileCount: Metric!

  # The number of file shares in the storage account's File service.
  fileShareCount: Metric!

  # The upper limit on the amount of storage that can be used by Azure Files Service in bytes.
  fileShareQuotaSize: Metric!

  # The number of snapshots present on the share in storage account's Files Service.
  fileShareSnapshotCount: Metric!

  # The amount of storage used by the snapshots in storage account's File service in bytes.
  fileShareSnapshotSize: Metric!
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # The amount of ingress data, in bytes. 
  ingress: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Name of the Azure Storage.
  name: String

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Azure Files resourceId
  resourceId: String

  # Azure Storage Type (Blob, File, Queue, Table)
  storageType: String

  # The end-to-end latency of successful requests made to a storage service or the specified API operation, in milliseconds. 
  successE2ELatency: Metric!

  # The latency used by Azure Storage to process a successful request, in milliseconds.
  successServerLatency: Metric!

  # The number of requests made to a storage service or the specified API operation.
  transactions: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Azure Front Door entity
type AzureFrontDoor implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The percentage of successful health probes from the HTTP/S proxy to backends
  backendHealthPercentage: Metric!

  # The number of requests sent from the HTTP/S proxy to backends
  backendRequestCount: Metric!

  # The time calculated from when the request was sent by the HTTP/S proxy to the backend until the HTTP/S proxy received the last response byte from the backend
  backendRequestLatency: Metric!

  # The number of billable bytes (minimum 2KB per request) sent as responses from HTTP/S proxy to clients
  billableResponseSize: Metric!

  # Cloud Account to which this Front Door resource belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Azure Front Door - CDN name
  name: String

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The number of client requests served by the HTTP/S proxy
  requestCount: Metric!

  # The number of bytes sent as requests from clients to the HTTP/S proxy
  requestSize: Metric!

  # Azure resourceId
  resourceId: String

  # The number of bytes sent as responses from HTTP/S proxy to clients
  responseSize: Metric!

  # The time calculated from when the client request was received by the HTTP/S proxy until the client acknowledged the last response byte from the HTTP/S proxy
  totalLatency: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # The number of client requests processed by the Web Application Firewall
  webApplicationFirewallRequestCount: Metric!
}

# Azure Function
type AzureFunction implements AlertingEntity & Entity & HealthEntity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # The average amount of memory used by the app in megabytes (MiB).
  averageMemoryWorkingSet: Metric!

  # The average time taken for the app to serve requests, in seconds.  
  averageResponseTime: Metric!

  # The amount of incoming bandwidth consumed by the app in MiB.  
  bytesReceived: Metric!

  # The amount of outgoing bandwidth consumed by the app in MiB. 
  bytesSent: Metric!

  # Relation: Cloud Account to which this lambda function belongs
  cloudAccount: CloudAccount

  # The cloud account id for Azure function entity
  cloudAccountId: String

  # Name of the cloud provider for filtering purpose
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # The current number of Assemblies loaded across all AppDomains in this application.
  currentAssemblies: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # 5xx Error Rate
  functionErrorRate5xx: Metric!

  # Function Execution Count. For FunctionApps only.
  functionExecutionCount: Metric!

  # Function Execution unit. For FunctionApps only.
  functionExecutionUnit: Metric!

  # The number of times the generation 0 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  gen0Collections: Metric!

  # The number of times the generation 1 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  gen1Collections: Metric!

  # The number of times the generation 2 objects are garbage collected since the start of the app process.
  gen2Collections: Metric!
  healthScore: HealthScore

  # Azure function app host name
  hostName: String

  # The count of requests resulting in an HTTP status code = 200 but < 300. 
  http2xx: Metric!

  # The count of requests resulting in an HTTP status code = 400 but < 500.  
  http4xx: Metric!

  # The count of requests resulting in an HTTP status code = 500 but < 600. 
  # The average statistic shows the error rate and the sum statistic shows the count of that type of error during each period.
  http5xx: Metric!

  # Unique identifier of an entity
  id: ID!

  # The rate at which the app process is issuing bytes to I/O operations that don't involve data such as controls operations.
  ioOtherBytesPerSecond: Metric!

  # The rate at which the app process is issuing I/O operations that aren't read or write operations. 
  ioOtherOperationsPerSecond: Metric!

  # The rate at which the app process is reading bytes from I/O operations.
  ioReadBytesPerSecond: Metric!

  # The rate at which the app process is issuing read I/O operations.
  ioReadOperationsPerSecond: Metric!

  # The rate at which the app process is writing bytes to I/O operations. 
  ioWriteBytesPerSecond: Metric!

  # The rate at which the app process is issuing write I/O operations.
  ioWriteOperationsPerSecond: Metric!

  # Azure function java version
  javaVersion: String

  # Azure function kind
  kind: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Azure function linux version
  linuxFxVersion: String

  # The current amount of memory used by the app in MiB. 
  memoryWorkingSet: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # The metricsTag of the Azure function
  metricTag: String

  # Function name
  name: String

  # Azure function net framework version
  netFrameworkVersion: String

  # Azure function node version
  nodeVersion: String

  # Azure function php version
  phpVersion: String

  # Azure function power shell version
  powerShellVersion: String

  # Private Bytes is the current size in bytes of memory that the app process has allocated that can't be shared with other processes.
  privateBytes: Metric!

  # Azure function python version
  pythonVersion: String

  # Azure function redundancy mode
  redundancyMode: String

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # The total number of requests regardless of their resulting HTTP status code.
  requests: Metric!

  # The number of requests in the application request queue.
  requestsInApplicationQueue: Metric!

  # Azure Function resourceId
  resourceId: String

  # Azure function app state
  state: State

  # The current number of AppDomains loaded in this application.
  totalAppDomains: Metric!

  # The total number of AppDomains unloaded since the start of the application. 
  totalAppDomainsUnloaded: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Azure function windows version
  windowsFxVersion: String
}

# Azure Key Vault entity
type AzureKeyVault implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Cloud Account to which this key vault belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Number of total service api hits
  hit: Metric!

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Overall latency of service api requests
  latency: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Azure Key Vault name
  name: String

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Azure resourceId
  resourceId: String

  # Number of total service api results
  result: Metric!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type AzureRegion {
  enabled: Boolean!
  id: String!
}

input AzureRegionInput {
  enabled: Boolean!
  id: String!
}

type AzureResourceType {
  displayName: String!
  enabled: Boolean!
  typeName: String!
}

input AzureResourceTypeInput {
  displayName: String!
  enabled: Boolean!
  typeName: String!
}

type AzureSubscription {
  displayName: String!
  enabled: Boolean!
  id: String!
  regions: [AzureRegion!]!
  resourceTypes: [AzureResourceType!]!
}

input AzureSubscriptionInput {
  displayName: String!
  enabled: Boolean!
  id: String!
  regions: [AzureRegionInput!]!
  resourceTypes: [AzureResourceTypeInput!]!
}

# Azure entity extension for Host
type AzureVMHostExtension {
  # The Availability Zone of the instance.
  availabilityZone: String

  # Available Memory
  availableMemory: Metric!

  # Cloud Account to which this VM belongs.
  cloudAccount: CloudAccount

  # Name of the cloud platform eg: azure vm
  cloudPlatform: String

  # Name of the cloud provider for filtering purpose
  cloudProvider: String

  # The number of CPU cores for the instance.
  cpuCount: Int

  # CPU Credits Remaining
  cpuCreditRemaining: Metric!

  # CPU Credits Consumed
  cpuCreditUsage: Metric!

  # Percentage CPU
  cpuUtilization: Metric!

  # Percentage of data disk bandwidth consumed per minute
  dataDiskBandwidthConsumedPercentage: Metric!

  # Percentage of data disk I/Os consumed per minute
  dataDiskIOPSConsumedPercentage: Metric!

  # Premium Data Disk Cache Read Hit
  diskCacheDataReadHit: Metric!

  # Premium Data Disk Cache Read Miss
  diskCacheDataReadMiss: Metric!

  # Premium OS Disk Cache Read Hit
  diskCacheOsReadHit: Metric!

  # Premium OS Disk Cache Read Miss
  diskCacheOsReadMiss: Metric!

  # Data Disk Queue Depth
  diskDataQueueDepth: Metric!

  # Data Disk Read Bytes/sec
  diskDataReadBytes: Metric!

  # Data Disk Read Operations/sec
  diskDataReadOps: Metric!

  # Data Disk Write Bytes/sec
  diskDataWriteBytes: Metric!

  # Data Disk Write Operations/sec
  diskDataWriteOps: Metric!

  # OS Disk Queue Depth
  diskOsQueueDepth: Metric!

  # OS Disk Read Bytes/sec
  diskOsReadBytes: Metric!

  # OS Disk Read Operations/sec
  diskOsReadOps: Metric!

  # OS Disk Write Bytes/sec
  diskOsWriteBytes: Metric!

  # OS Disk Write Operations/sec
  diskOsWriteOps: Metric!

  # Disk Read Operations/Sec
  diskReadOps: Metric!

  # Disk Write Operations/Sec
  diskWriteOps: Metric!

  # Unique identifier of an Azure VM
  hostId: String!

  # Azure VM type
  hostType: String!

  # The ID of the image used to launch the instance.
  imageId: String

  # The name of the image that was provided during image creation.
  imageName: String

  # Inbound Flows Maximum Creation Rate
  inboundFlowsMaximumCreationRate: Metric!

  # Azure VM name
  name: String

  # Network In Total
  networkIn: Metric!

  # Inbound Flows
  networkInboundFlows: Metric!

  # Network Out Total
  networkOut: Metric!

  # Outbound Flows
  networkOutboundFlows: Metric!

  # The value is ReadWrite/ReadOnly or blank.
  osDiskCaching: String

  # The name of the os disk. There is one os disk per VM.
  osDiskName: String

  # The size of the os disk. There is one os disk per VM.
  osDiskSize: String

  # The value is window or linux.
  osType: String

  # Outbound Flows Maximum Creation Rate
  outboundFlowsMaximumCreationRate: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String!

  # Azure resourceId
  resourceId: String
}

# Azure VirtualMachine ScaleSet
type AzureVirtualMachineScaleSet implements Entity & HealthEntity {
  # Amount of physical memory, in bytes, immediately available for allocation to a process or for system use in the Virtual Machine
  availableMemoryBytes: Metric!

  # Cloud Account to which this entity belongs.
  cloudAccount: CloudAccount

  # Cloud provider Name
  cloudProvider: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Data Disk Queue Depth(or Queue Length)
  dataDiskQueueDepth: Metric!

  # Bytes/Sec read from a single disk during monitoring period
  dataDiskReadBytesPerSec: Metric!

  # Read IOPS from a single disk during monitoring period
  dataDiskReadOperationsPerSec: Metric!

  # Bytes/Sec written to a single disk during monitoring period
  dataDiskWriteBytesPerSec: Metric!

  # Write IOPS from a single disk during monitoring period
  dataDiskWriteOperationsPerSec: Metric!

  # Bytes read from disk during monitoring period
  diskReadBytes: Metric!

  # Disk Read IOPS
  diskReadOperationsPerSec: Metric!

  # Bytes written to disk during monitoring period
  diskWriteBytes: Metric!

  # Disk Write IOPS
  diskWriteOperationsPerSec: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Inbound Flows are number of current flows in the inbound direction (traffic going into the VM)
  inboundFlows: Metric!

  # The maximum creation rate of inbound flows (traffic going into the VM)
  inboundFlowsMaximumCreationRate: Metric!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Azure Entity name
  name: String

  # The number of bytes received on all network interfaces by the Virtual Machine(s) (Incoming Traffic)
  networkInTotal: Metric!

  # The number of bytes out on all network interfaces by the Virtual Machine(s) (Outgoing Traffic)
  networkOutTotal: Metric!

  # OS Disk Queue Depth(or Queue Length)
  oSDiskQueueDepth: Metric!

  # Bytes/Sec read from a single disk during monitoring period for OS disk
  oSDiskReadBytesPerSec: Metric!

  # Read IOPS from a single disk during monitoring period for OS disk
  oSDiskReadOperationsPerSec: Metric!

  # Bytes/Sec written to a single disk during monitoring period for OS disk
  oSDiskWriteBytesPerSec: Metric!

  # Write IOPS from a single disk during monitoring period for OS disk
  oSDiskWriteOperationsPerSec: Metric!

  # Outbound Flows are number of current flows in the outbound direction (traffic going out of the VM)
  outboundFlows: Metric!

  # The maximum creation rate of outbound flows (traffic going out of the VM)
  outboundFlowsMaximumCreationRate: Metric!

  # The percentage of allocated compute units that are currently in use by the Virtual Machine(s)
  percentageCPU: Metric!

  # Premium Data Disk Cache Read Hit
  premiumDataDiskCacheReadHit: Metric!

  # Premium Data Disk Cache Read Miss
  premiumDataDiskCacheReadMiss: Metric!

  # Premium OS Disk Cache Read Hit
  premiumOSDiskCacheReadHit: Metric!

  # Premium OS Disk Cache Read Miss
  premiumOSDiskCacheReadMiss: Metric!

  # Separate geographic area that Azure uses to house its infrastructure.
  region: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Azure resourceId
  resourceId: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type BasicRelationship implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

scalar Byte

# Byte array representation of the value.
type BytesKeyValuePair implements EventKeyValuePair {
  key: String!
  value: String! @deprecated(reason: "Only for backwards compatibility, will be removed in favor of typed values (valueBytes)")
  valueBytes: [Byte!]
}

type CategoryDashboards {
  category: DashboardCategory!
  dashboardsCount: Int!
}

input CategoryFilter {
  ownerId: ID
  type: CategoryType
}

type CategoryOwner {
  id: ID!
  name: String!
}

enum CategoryType {
  custom
  system
}

# Metadata describing the underlying query to chainsaw
type ChainsawMetadata {
  error: String
  plan: String
  planQueries: String
  query: String
  requestId: String
  warnings: [String!]
}

type CheckForString implements Validation {
  status: ValidationStatus!
  string: String!
  type: ValidationType!
}

input CheckForStringInput {
  operator: CheckStringOperator!
  value: String!
}

type CheckForStringType {
  operator: CheckStringOperator!
  value: String!
}

enum CheckStringOperator {
  CONTAINS
  DOES_NOT_CONTAIN
}

# Cloud Account entity
type CloudAccount implements AlertingEntity & Entity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Cloud Account provider (AWS, ...)
  cloudProvider: String!
  configuration: CloudAccountConfigurationInterface

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

interface CloudAccountConfigurationInterface {
  enabled: Boolean!
  metricsTag: String
}

enum CollectionType {
  LIST
  SET
}

# Alert definition condition types
enum ConditionType {
  ENTITY_METRIC
  LOG_QUERY
  STANDALONE_METRIC
  UNKNOWN
}

type ConnectionDetails implements AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
  ipAddress: String!
  port: Int!
  protocol: String!
}

# Container entity
type Container implements AlertingEntity & Entity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Extension field that adds Apm instance fields to the Container entity
  apm: ApmContainerExtension

  # Container id
  containerId: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Read-only flag that's 'true' when there is "apm" extension set on the entity
  # and 'false' if there's not.
  hasApm: Boolean!

  # Unique identifier of an entity
  id: ID!

  # Container image name
  imageName: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type ConversationMeasurements {
  destination: String!
  measurements: [Measurement!]!
  source: String!
}

input CreateAwsCloudAccountInput {
  configuration: AwsCloudAccountConfigurationInput!
  displayName: String!
  sessionId: Guid!
}

type CreateAwsCloudAccountResponse implements MutationResponseInterface {
  awsCloudAccount: AwsCloudAccount
  code: String!
  message: String!
  success: Boolean!
}

input CreateAzureCloudAccountInput {
  configuration: AzureCloudAccountConfigurationInput!
  displayName: String!
  sessionId: Guid!
}

type CreateAzureCloudAccountResponse implements MutationResponseInterface {
  azureCloudAccount: AzureCloudAccount
  code: String!
  message: String!
  success: Boolean!
}

input CreateAzureIntegrationInput {
  credential: AzureCredentialInput!
  displayName: String!
  metricsTag: String!
  subscription: AzureSubscriptionInput!
}

type CreateAzureIntegrationResponse implements MutationResponseInterface {
  azureCloudAccount: AzureCloudAccount
  code: String!
  message: String!
  success: Boolean!
}

input CreateCategoryInput {
  name: String!
}

type CreateCategoryResponse {
  category: DashboardCategory
  code: String!
  message: String!
  success: Boolean!
}

input CreateDashboardInput {
  categoryId: ID
  description: String
  isPrivate: Boolean
  layout: [LayoutInput!]!
  name: String!
  widgets: [WidgetInput!]!
}

type CreateDashboardResponse {
  code: String!
  dashboard: Dashboard
  message: String!
  success: Boolean!
}

union CreateEntityGroupResult = CreateEntityGroupSuccess | EntityGroupMutationError

type CreateEntityGroupSuccess {
  # Created entity group
  entityGroup: EntityGroup!
}

input CreateExclusionFilterExpressionInput {
  expression: String!
  kind: ExclusionFilterExpressionKind!
}

input CreateExclusionFilterInput {
  description: String!
  expressions: [CreateExclusionFilterExpressionInput!]!
  name: String!
  tokenSignature: String
}

type CreateExclusionFilterResponse implements ExclusionFilterResponseInterface {
  code: ExclusionFilterResponseCode!
  exclusionFilter: ExclusionFilter
  message: String!
  success: Boolean!
}

input CreateKubernetesManifestInput {
  clusterName: String!
  customClusterUid: String
  kubernetesNamespace: String!
  prometheusUrl: String!
}

type CreateKubernetesManifestResponse implements MutationResponseInterface {
  code: String!
  kubernetesManifest: KubernetesManifest
  message: String!
  success: Boolean!
}

input CreateLogArchiveStorageInput {
  name: String!
  provider: LogArchiveProvider!
}

type CreateLogArchiveStorageResponse implements LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  message: String!
  success: Boolean!
}

input CreateLogFilterInput {
  description: String
  expressions: [LogFilterExpressionInput!]!
  global: Boolean!
  groupIds: [ID!]!
  name: String!
}

type CreateLogFilterResponse implements MutationResponseInterface {
  code: String!
  logFilter: LogFilter
  message: String!
  success: Boolean!
}

input CreateLogGroupInput {
  description: String
  name: String!
  syslogApps: [String!]
  syslogHosts: [String!]
  tags: [String!]
}

input CreateLogSearchHistoryInput {
  query: String!
}

input CreateLogSearchInput {
  groupId: ID
  name: String!
  query: String!
}

type CreateNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  configuration: NotificationService
  message: String!
  success: Boolean!
}

input CreateOrganizationInvitationInput {
  email: String!
  role: OrganizationRole!
}

type CreateOrganizationInvitationResponse implements MutationResponseInterface {
  code: String!
  invitation: OrganizationInvitation
  message: String!
  success: Boolean!
}

input CreateSamlConfigurationInput {
  enabled: Boolean
  identityProvider: SamlIdentityProviderInput!
}

input CreateSavedSearchInput {
  context: SavedSearchContext!
  isPrivate: Boolean
  name: String!
  objectId: String
  query: String!
}

type CreateSavedSearchResponse {
  code: String!
  message: String!
  savedSearch: SavedSearch
  success: Boolean!
}

input CreateTokenInput {
  accessLevel: TokenAccessLevel!
  name: String!
  type: String
}

type CreateTokenResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
  token: Token
}

input CreateWebsiteInput {
  availability: AvailabilityMonitoringInput!
  customHeaders: [CustomHeaderInput!]
  name: String!
  options: MonitoringOptionsInput!
  rum: RumMonitoringInput
  url: String!
}

union CreateWebsiteResult = CreateWebsiteSuccess | WebsiteInputValidationError

type CreateWebsiteSuccess {
  website: Website!
}

type Credential {
  description: String
  id: String!
  name: String!
  secretType: String!
  tags: [KeyValuePairOfStringAndString]
}

input CredentialFilter {
  secretTypes: [String]!
}

type CustomHeader {
  name: String!
  value: String!
}

input CustomHeaderInput {
  name: String!
  value: String!
}

type DBOQueries {
  internalQueryIDs: [String!]!
}

type Dashboard {
  category: DashboardCategory
  createdAt: DateTime!
  description: String
  id: ID!
  isPrivate: Boolean
  layout: [Layout!]!
  name: String!
  owner: DashboardOwner
  ownerId: ID @deprecated
  systemReference: ID
  updatedAt: DateTime!
  widgets: [Widget!]!
}

type DashboardCategory {
  createdAt: DateTime!
  id: ID!
  name: String!
  owner: CategoryOwner
  type: String!
  updatedAt: DateTime!
}

type DashboardCategoryQueries {
  search(inputs: SearchDashboardCategoriesInput!): SearchCategoriesResult!
}

input DashboardFilter {
  categoryId: ID
  isSystem: Boolean
  ownerId: ID
}

type DashboardOwner {
  id: ID!
  name: String!
}

type DashboardQueries {
  byId(id: ID!): Dashboard
  categories: DashboardCategoryQueries
  search(inputs: SearchDashboardsInput!): SearchDashboardsResult!
  widgets: WidgetQueries
}

type DatabaseAgent {
  agent: String!
  deploymentStatus: String!
  healthStatus: String!
  id: String!
  version: String!
}

type DatabaseInstance implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
  cloudProvider: String

  # Queries execution time
  concurrency: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Credential Id points to the credentials to be used to connect with the database instance
  credentialId: String

  # Database address in the form of host:port e.g. localhost:3306
  databaseAddress: String

  # Database instance bindings e.g. [127.0.0.1:3306]
  databaseBindings: [String!]

  # Database name to connect to, if required
  databaseDbName: String

  # Date and time in UTC of when the database instance was discovered
  databaseDiscoveredAt: String

  # Database display name e.g. 'mysql on offhost0 listening on shard1:3306'
  databaseDisplayName: String

  # Database product name e.g. MySQL Community Server (GPL) 
  databaseProductName: String

  # Database query capture method [poll, sniff, profiler, slow-log, query-cache]
  # Allowed values depend on the databaseType
  databaseQueryCapture: String

  # Database instance tags e.g. [rds, aurora, prod]
  databaseTags: [String!]

  # Database TLS enabled
  databaseTlsEnabled: Boolean

  # Database type/family [mongo, mssql, mysql, pgsql, redis]
  databaseType: String!

  # Database version e.g. 8.0.27
  databaseVersion: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Queries error rate
  errorRate: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Latency (computed as executionTime/executionCount) rate of observed queries
  latency: Metric!
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Queries execution count
  throughput: Metric!

  # Total queries execution time
  totalConcurrency: Metric!

  # Total queries error rate
  totalErrorRate: Metric!

  # Total queries execution count
  totalThroughput: Metric!

  # Entity type.
  type: String!

  # Uamsclient ID that runs dbo agents if any.
  uamsClientID: String

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type DatabaseMetricColumn {
  metric: String!
  value: String!
}

type DatabaseProfiler {
  # Returns the profiler configuration for the given input
  configuration(input: DatabaseProfilerConfigurationInput!): DatabaseProfilerConfiguration!

  # Returns a ranked result by the given metric
  rank(input: DatabaseProfilerRankInput): DatabaseProfilerRankResponse!
}

type DatabaseProfilerCategory {
  # These are the columns that can be included in the table when the category is ranked
  columns: [DatabaseProfilerDescribableMetric!]!
  filters: [DatabaseProfilerRankOption!]! @deprecated(reason: "Use options instead")

  # A user-friendly name for the category
  name: String!
  options: [DatabaseProfilerRankOption!]!

  # This field defines what the user can rank the category by. For example, rank 'Queries' BY 'Total Time'.
  rankBy: [DatabaseProfilerDescribableMetric!]!
}

type DatabaseProfilerCategoryFilter {
  # A unique id for this filter, to be used as 'propertyName' when used in a query.
  id: String!

  # This field defines how the filter should be used by the end user.
  type: DatabaseProfilerCategoryFilterType!
}

enum DatabaseProfilerCategoryFilterType {
  BOOL
  KEYVALUE
  STRING
}

type DatabaseProfilerColumn {
  # The user-defined id that was received in the request
  id: String!
  percentage: Float!
  value: Float!
}

input DatabaseProfilerColumnMetric {
  # A user-defined id that will be returned in the response as part of the column data.
  id: String!

  # The metric name associated to the column
  metricName: String!
}

type DatabaseProfilerConfiguration {
  # The set of categories a user can rank in the profiler.
  categories: [DatabaseProfilerCategory!]!
}

input DatabaseProfilerConfigurationInput {
  # Optional unique identifier of an entity. If provided, the configuration will be related only to the given entity.
  entityId: ID

  # Used for fetching hosts information from dbo-hosts-api
  timeRange: TimeRangeInput!
}

type DatabaseProfilerDescribableMetric {
  # A user-friendly description of the metric
  description: String!

  # The metric name known by the internal services
  metricName: String!
}

input DatabaseProfilerRankInput {
  # Extra filter to be applied to the result
  extraColumnsMetrics: [DatabaseProfilerColumnMetric!]!

  # Extra filter to be applied to the result
  filter: FilterInput

  # The resulting rows cannot be greater than this limit
  limit: Int!

  # The metric name to rank the data by
  metricName: String!

  # The time range from the resulting data
  timeRange: TimeRangeInput!
}

type DatabaseProfilerRankOption {
  # A unique id for this filter, to be used as 'propertyName' when used in a query.
  id: String!

  # This field defines how the filter should be used by the end user.
  type: DatabaseProfilerRankOptionType!
}

enum DatabaseProfilerRankOptionType {
  BOOL
  KEYVALUE
  STRING
}

# Rank representation. It contains the ranked rows and a single item including a
# summarized result of any other item that did not ranked high enough to be on the
# table.
type DatabaseProfilerRankResponse {
  rest: DatabaseProfilerRankRest!
  rows: [DatabaseProfilerRankRow!]!
}

# Represents a summarized rank of elements that are not included in the main result
type DatabaseProfilerRankRest {
  columns: [DatabaseProfilerColumn!]!
  description: String!
  ranking: DatabaseProfilerRanking!
  rowCount: Int!
}

# Ranked row describing a single element
type DatabaseProfilerRankRow {
  columns: [DatabaseProfilerColumn!]!
  description: String!
  id: String!
  ranking: DatabaseProfilerRanking!
}

type DatabaseProfilerRanking {
  measurements: [Measurement!]!
  percentage: Float!
  position: Int!
  value: Float!
}

type DatabaseQuery {
  digest: String!
  firstSeen: String!
  id: String!
  lastSeen: String!
  samples: [DatabaseQuerySample!]
  tags: [DatabaseQueryTag!]
}

input DatabaseQueryInput {
  entityId: String
  queryId: String!
  timeRange: TimeRangeInput!
}

type DatabaseQuerySample {
  application: String!
  connectionId: String!
  database: String!
  databaseType: String!
  entityId: String!
  explainError: String!
  latency: Float!
  origin: String!
  rawPlan: String!
  sampleError: String!
  text: String!
  textEmptyReason: String!
  timestamp: String!
  truncated: Boolean!
  user: String!
  warnings: [Int!]
}

type DatabaseQuerySpan {
  queryId: String!
  spanId: String!
}

type DatabaseQueryTag {
  key: String!
  keyValue: String!
  value: String!
}

type DatabaseRank {
  time: Int! @deprecated(reason: "time is deprecated. Use totalTime instead.")
  totalTime: Float!
  value: String!
}

type DatabaseResponseDetails {
  metric: String!
  value: Float!
}

type DatabaseTopQueries {
  column(metric: [String!]): [DatabaseMetricColumn!]!
  digest: String!
  id: String!
  percentage: Float!
  rank: DatabaseRank
  timeseries(bucketSizeInS: Int!): [Measurement!]!
}

input DatabaseTopQueriesInput {
  entityId: String
  filter: FilterInput
  limit: Int!
  metricName: String!
  newQueriesOnly: Boolean! = false
  timeRange: TimeRangeInput!
}

type DatabaseTrace {
  queries: [DatabaseQuerySpan!]
}

input DatabaseTraceInput {
  spanIds: [String!]
  traceId: String!
}

scalar DateTime

input DeleteCategoryInput {
  id: ID!
}

type DeleteCategoryResponse {
  code: String!
  message: String!
  success: Boolean!
}

input DeleteCloudAccountsInput {
  entityIds: [String!]!
}

type DeleteCloudAccountsResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

input DeleteDashboardInput {
  id: ID!
}

type DeleteDashboardResponse {
  code: String!
  message: String!
  success: Boolean!
}

input DeleteDatabaseRequest {
  databaseInstanceID: String!
}

type DeleteDatabaseResponse {
  code: String!
  message: String
}

union DeleteEntityGroupResult = DeleteEntityGroupSuccess | EntityGroupMutationError

type DeleteEntityGroupSuccess {
  # Deleted entity group ID
  id: ID!
}

input DeleteExclusionFilterInput {
  id: ID!
}

input DeleteLogFilterInput {
  filterId: ID!
}

type DeleteNetworkDeviceResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

input DeleteNotificationServiceConfigurationInput {
  id: ID!
}

type DeleteNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

type DeleteOrganizationMemberResponse implements MutationResponseInterface {
  code: String!
  lifespan: Int
  message: String!
  success: Boolean!
}

input DeleteSavedSearchInput {
  id: ID!
}

type DeleteSavedSearchResponse {
  code: String!
  message: String!
  success: Boolean!
}

type DeleteServiceError {
  message: String!
}

input DeleteServiceInput {
  id: ID!
}

union DeleteServiceResult = DeleteServiceError | DeleteServiceSuccess

type DeleteServiceSuccess {
  id: ID!
}

input DeleteTokenInput {
  id: ID!
}

type DeleteTokenResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

input DeleteWebsiteInput {
  id: ID!
}

union DeleteWebsiteResult = DeleteWebsiteSuccess

type DeleteWebsiteSuccess {
  id: ID!
}

enum Density {
  Comfort
  Compact
}

type DeployedOn implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

enum DeploymentStatus {
  DELETE_IN_PROGRESS
  DEPLOYMENT_IN_PROGRESS
  FAILED
  SCHEDULED_FOR_DELETION
  SCHEDULED_FOR_INSTALLATION
  UNKNOWN
  UPDATE_AVAILABLE
  UPDATE_CHECK_FAILED
  UP_TO_DATE
}

# DeviceVolume entity
type DeviceVolume implements AlertingEntity & Entity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Average Disk Queue Length of Device Volume Entity.
  avgDiskQLength: Metric!

  # Average Disk Reads of Device Volume Entity.
  avgDiskReads: Metric!

  # Average Disk Writes of Device Volume Entity.
  avgDiskWrites: Metric!

  # Average Disk Transfer of Device Volume Entity.
  avgDiskpersectransfer: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Disk Usage Percentage of Device Volume Entity.
  diskUsed: Metric!

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity.
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Relation: Network Device to Device Volume.
  networkDevice: NetworkDevice

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # State of Device Volume entity.
  state: State

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion Volume Uri 
  # Serves as natural key for Device Volume
  uri: String!

  # Average Disk Size of Device Volume Entity.
  volumeSize: Metric!

  # Device Volume type
  volumeType: String
}

enum DiagnosticsType {
  LOGS
}

enum Direction {
  BACKWARD
  FORWARD
}

# EC2 entity extension for Host
type EC2HostExtension {
  # The architecture of the image.
  architecture: String

  # The Availability Zone of the instance.
  availabilityZone: String

  # Cloud Account to which this EC2 host belongs.
  cloudAccount: CloudAccount

  # Name of the cloud platform eg: AWS EC2
  cloudPlatform: String

  # Name of the cloud provider for filtering purpose
  cloudProvider: String

  # The number of CPU cores for the instance.
  cpuCoreCount: String

  # The number of earned CPU credits that an instance has accrued since it was launched or started.
  cpuCreditBalance: Metric!

  # The number of CPU credits spent by the instance for CPU utilization.
  cpuCreditUsage: Metric!

  # The number of surplus credits that have been spent by an unlimited instance when its CPUCreditBalance value is zero.
  cpuSurplusCreditBalance: Metric!

  # The number of spent surplus credits that are not paid down by earned CPU credits, and which thus incur an additional charge.
  cpuSurplusCreditsCharged: Metric!

  # The percentage of allocated EC2 compute units that are currently in use on the instance.
  cpuUtilization: Metric!

  # The percentage of allocated compute capacity that is currently in use by the instances running on the Dedicated Host.
  dedicatedHostCpuUtilization: Metric!

  # Completed I/O operations to all instance store volumes available to the instance in a specified period of time.
  diskIOps: Metric!

  # Bytes read from all instance store volumes available to the instance.
  diskReadBytes: Metric!

  # Completed read operations from all instance store volumes available to the instance in a specified period of time.
  diskReadOps: Metric!

  # Bytes written to all instance store volumes available to the instance.
  diskWriteBytes: Metric!

  # Completed write operations to all instance store volumes available to the instance in a specified period of time.
  diskWriteOps: Metric!

  # Provides information about the percentage of throughput credits remaining in the burst bucket.
  ebsByteBalance: Metric!

  # Provides information about the percentage of I/O credits remaining in the burst bucket.
  ebsIOBalance: Metric!

  # Bytes read from all EBS volumes attached to the instance in a specified period of time.
  ebsReadBytes: Metric!

  # Completed read operations from all Amazon EBS volumes attached to the instance in a specified period of time.
  ebsReadOps: Metric!

  # Bytes written to all EBS volumes attached to the instance in a specified period of time.
  ebsWriteBytes: Metric!

  # Completed write operations to all EBS volumes attached to the instance in a specified period of time.
  ebsWriteOps: Metric!

  # EC2 entity hostname (private Dns Name)
  hostname: String

  # The description of the AMI that was provided during image creation.
  imageDescription: String

  # The ID of the AMI used to launch the instance.
  imageId: String

  # The name of the AMI that was provided during image creation.
  imageName: String

  # Unique identifier of an AWS instance
  instanceId: String!

  # AWS EC2 instance type
  instanceType: String!

  # The number of times the instance metadata service was successfully accessed using a method that does not use a token.
  metadataNoToken: Metric!

  # EC2 instance name
  name: String

  # The number of bites sent and received by the instance on all network interfaces per second.
  networkIO: Metric!

  # The number of bytes received by the instance on all network interfaces. This metric identifies the volume of incoming network traffic to a single instance.
  networkIn: Metric!

  # The number of bytes sent out by the instance on all network interfaces.
  networkOut: Metric!

  # The number of packets received by the instance on all network interfaces
  networkPacketsIn: Metric!

  # The number of packets sent out by the instance on all network interfaces.
  networkPacketsOut: Metric!

  # The value is Windows for Windows instances; otherwise blank.
  platform: String

  # Separate geographic area that AWS uses to house its infrastructure.
  region: String!

  # State of the EC2 instance
  state: State

  # Reports whether the instance has passed both the instance status check and the system status check in the last minute.
  statusCheckFailed: Metric!

  # Reports whether the instance has passed the instance status check in the last minute.
  statusCheckFailedInstance: Metric!

  # Reports whether the instance has passed the system status check in the last minute.
  statusCheckFailedSystem: Metric!
}

input EdgeFilter {
  filter: EntityFilter
  inDepth: Int
  inEdgeTypes: [String!]
  outDepth: Int
  outEdgeTypes: [String!]
  timeFilter: TimeFilter
}

type EmptyLogFilterResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

type EmptyLogGroupResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

# Entities group for search result. Even search without grouping returns result in an entity group
# with "grouping" value null.
type EntitiesGroup {
  # Entities in this group
  entities: [Entity!]!

  # If the search query contained grouping then this property contains information about particular groups.
  # If the search query was not grouped then this property is null
  grouping: [EntityGrouping!]

  # Unique group identifier to allow clients to cache the group.
  # Note the value is not human readable due to potentially multiple
  # group by properties.
  id: ID!

  # If the 'pagingPerGroup' flag is set in the grouping definition then each group contains extra page information
  # valid for given group. 
  # If a client wants to load next page of only a single group it has to adjust original search filter to limit the results
  # to that group only. Applying group page information on the original query will load all the other groups as well 
  # but their paging won't be valid.
  pageInfo: PageInfo

  # Total count of entities without paging.
  totalEntitiesCount: Int
}

# A list of groups of entities
type EntitiesResponse {
  entityGroups: [EntityGroup_old!]
  pageInfo: PageInfo
}

type Entitlement {
  asOf: Int!
  isSubscribed: Boolean!
  limit: Int!
  name: String!
  subscription: String!
  usage: Int!
}

input EntitlementFilterInput {
  name: String!
}

# Base interface for all entities
interface Entity {
  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# A key-value pair describing an entity
type EntityAttribute {
  key: String!
  value: String!
}

# Members of the group are a subtree starting from the these root ids.
type EntityContextEntityGroupDefinition {
  entityContextRootEntityIds: [ID!]!
}

# NOT IMPLEMENTED
type EntityCounts {
  count: Int!
  value: String!
}

# Filter the entity graph based on attribute filter and limited to a set of types
# If types is empty, evaluate all entity types
input EntityFilter {
  filter: TagFilter
  types: [String!]
}

# Input type for generic entity queries
input EntityFilterInput {
  # Optional filter definition.
  filter: FilterInput

  # Contextual search query string. If used along with filter, entities must match both filters.
  query: String

  # List of entity types to get. If empty/missing then search is across all entities.
  types: [String!]
}

# Type describing entity filter
type EntityFilterMetadata {
  # List of available filter options (values) with number of matching entities
  options: [EntityFilterOptionMetadata!]!

  # Paging information. If there are too many options available there may be multiple pages.
  pageInfo: PageInfo!

  # Name of filtered property
  propertyName: String!
}

# Type describing entity filter option
type EntityFilterOptionMetadata {
  # Number of entities matching this filter option
  count: Int!

  # Value of the property to filter by
  value: String!
}

# Input type for entity traversal queries
input EntityGraphTraversalInput {
  # How deep across relationships the traversal should go when looking for entities.
  # If the depth is 0 then traversal across relationships is not executed at all.
  depth: Int

  # Entity filter to filter out the entities during traversal. The filter can limit the entity types 
  # and apply conditions on entity properties.
  filter: EntityFilterInput

  # List of incoming (where current entity is on "to" end) relationship types that should be traversed
  # when looking for entities.
  # When this list is empty then all incoming relationships are traversed.
  inRelationshipTypes: [String!]

  # List of outgoing (where current entity is on "from" end) relationship types that should be traversed
  # when looking for entities.
  # When this list is empty then all outgoing relationships are traversed.
  outRelationshipTypes: [String!]
}

# Entity Group entity that may contain other entities
type EntityGroup implements Entity & HealthEntity {
  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity Group definition. Describes how to find members of the group.
  definition: EntityGroupDefinition!

  # Description of the Entity Group
  description: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Type of the Entity Group
  groupType: EntityGroupType!

  # Health score of the entity
  healthScore: HealthScore

  # Defines how the Health Score of the entity group should be calculated
  healthScoreCalculationMethod: EntityGroupHealthScoreCalculationMethod!

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Collection of entities that are members of this group
  members: [Entity!]

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# A list of attributes used to group entities
input EntityGroupBy {
  tags: [String!]
}

# Group by definition. 
# Grouping supports multiple levels so order of propertyNames values matters.
input EntityGroupByInput {
  # Specify how to apply paging when grouping result. This only applies to endpoints
  # with pagination.
  # If true then result will contain all groups and each group will be paged separately.
  # If false (default) then paging will be applied to the whole result at once so only first 
  # group or groups may have data for the first page and the rest may be empty. You need to move 
  # to following pages to get data for remaining groups.
  pagingPerGroup: Boolean = false

  # Property names to group result by.
  propertyNames: [String!]!
}

union EntityGroupDefinition = EntityContextEntityGroupDefinition | FilterEntityGroupDefinition | StaticEntityGroupDefinition

input EntityGroupDefinitionInput {
  # Dynamic group members filter if 'groupType' is FILTER. Ignored for other group types.
  dynamicFilter: EntityFilterInput

  # List of group's root entities if 'groupType' is ENTITY_CONTEXT. Ignored for other group types.
  entityContextRootEntityIds: [ID!]

  # List of group's static members if 'groupType' is STATIC. Ignored for other group types.
  staticMemberIds: [ID!]
}

# Defines how the Health Score of the entity group should be calculated
enum EntityGroupHealthScoreCalculationMethod {
  AVERAGE
  BEST
  WORST
}

input EntityGroupInput {
  # Entity Group definition. Describes how to find members of the group.
  definition: EntityGroupDefinitionInput!

  # Description of the Entity Group
  description: String

  # Type of the Entity Group
  groupType: EntityGroupType!

  # Defines how the Health Score of the entity group should be calculated
  healthScoreCalculationMethod: EntityGroupHealthScoreCalculationMethod! = AVERAGE

  # Name of the Entity Group
  name: String!
}

# Result in case of entity group mutation error.
type EntityGroupMutationError {
  # Mutation error
  error: String

  # Validation errors
  validationResults: [ValidationResult!]
}

# Entity Group type options
enum EntityGroupType {
  ENTITY_CONTEXT
  FILTER
  STATIC
}

# A group of entities sharing a set of key-value pairs
type EntityGroup_old {
  entities: [Entity!]
  keyValuePairs: [EntityAttribute!]!
}

# Entity group description telling what property and value this group represents
type EntityGrouping {
  propertyName: String!
  propertyValue: String
}

input EntityLookupInput {
  # Keys and values used to lookup entities.
  kvPairs: [KeyValuePairInput!]!

  # Include only entities that match given kvPairs with at least this score.
  minMatchScore: Int!
}

type EntityLookupResult {
  # List of entities that match lookup keys in some way. Actual match score is included in each result.
  entities: [EntityMatchResult!]!
}

type EntityMatchResult {
  entity: Entity!

  # How well the entity matched the lookup values. 
  # Value is in range 0-100 where 0 is no match at all and 100 is full match.
  matchScore: Int!
}

# Result in case of entity mutation error.
type EntityMutationError {
  # Mutation error
  error: String

  # Validation errors
  validationResults: [ValidationResult!]
}

type EntityMutations {
  # Set existing entity's display name / alias.
  # Setting the explicit value sets display name to that value.
  # Setting empty/null value removes display name and entity will use original name as its display name.
  setEntityDisplayName(displayName: String, id: ID!): SetEntityDisplayNameResult
}

type EntityQueries {
  # Get Entity by ID. If "timeRange" argument is passed it set a "time context" for the whole query and override any "intervalSec" values in metric scalars 
  # metric directives. If the "timeRange" is not defined the default "intervalSec" value from the schema is used.
  byId(id: ID!, timeRange: TimeRangeInput): Entity

  # Perform entity lookup based on provided kv pairs. These can be properties or tags.
  lookup(request: EntityLookupInput!): EntityLookupResult! @deprecated(reason: "This query was never implemented and will be removed.")

  # Search for entities. The result can be grouped and sorted. If "timeRange" argument is passed it set a "time context" for the whole query and override any 
  # "intervalSec" values in metric scalars metric directives. If the "timeRange" is not defined the default "intervalSec" value from the schema is used.
  search(filter: EntityFilterInput, groupBy: EntityGroupByInput, paging: PagingInput, sortBy: EntitySortInput, timeRange: TimeRangeInput): SearchEntitiesResult!

  # Search for entities using graph traversal. Search first finds starting entities using `filter` constraints and then uses `traversal`
  # to go to related entities via relationships.
  #
  # Depending on the used traversal `depth` value the supported behavior is slightly different:
  # * `depth <= 1` - Results can be sorted using `sortBy` argument and full paging is supported.
  # * `depth > 1` - Sorting is not supported and paging supports only `first` argument.
  #
  # If "timeRange" argument is passed it set a "time context" for the whole query and override any "intervalSec" values in metric scalars
  # metric directives. If the "timeRange" is not defined the default "intervalSec" value from the schema is used.
  searchGraph(filter: EntityFilterInput, paging: PagingInput, sortBy: EntitySortInput, timeRange: TimeRangeInput, traversal: EntityGraphTraversalInput): SearchEntitiesGraphResult!

  # Search for relationships.
  searchRelationships(filter: RelationshipFilterInput, paging: PagingInput, timeRange: TimeRangeInput): SearchRelationshipsResult!
}

# Query sort definiton. Sort support multiple properties and two sort directions.
input EntitySortInput {
  sorts: [EntitySortItemInput!]!
}

# Single property sort definition.
input EntitySortItemInput {
  direction: SortDirection
  propertyName: String!
}

# Various statistics queries related to a single entity
type EntityTelemetryStatistics {
  # Get number of unique metrics for this entity.
  metricsCount(timeRange: TimeRangeInput!): Int!

  # Get number or unique values for given metric key across all metrics for this entity.
  uniqueMetricKeyValuesCount(key: String!, timeRange: TimeRangeInput!): Int!
}

# Type describing single entity type
type EntityTypeMetadata {
  # List of all base types for this entity type
  baseTypes: [String!]!

  # Special field that returns metadata about available filters for given set of properties, their values and entity counts.
  # It can be narrowed down to a subset of entities via "filter" and "timeRange" argument and value containing query.
  # "timeRange" argument filters by "lastSeenTime" property, entities with empty "lastSeenTime" property will not be filtered out.
  filters(filter: EntityFilterInput, paging: PagingInput, propertyNames: [String!]!, query: String, timeRange: TimeRangeInput): [EntityFilterMetadata!]!

  # Flag telling if the entity type represents an ephemeral entity. Ephemeral entities are entities that can have very short
  # lifetime and can appear and disappear frequently, such as container, DB queries etc.
  isEphemeral: Boolean!

  # List of metrics for this entity type defined in the schema.
  # This list won't contain metrics that are present in the system but not defined in the schema.
  # Kind specifies which metric sources should be used (BUILD_IN - defined in schema, STORED - available in storage)
  metrics(kind: MetricKindInput = BUILD_IN): [MetricMetadata!]!

  # List of all properties with metadata for this entity type
  properties: [PropertyMetadata!]!

  # Name of the entity type
  type: String!
}

type ErrorItem {
  exceptionClassMessageHash: String!
  hostname: String!
  message: String!
  spanId: String!
  spanLayer: String!
  time: String!
}

# Evaluation result types
enum EvalResultType {
  BOOLEAN
  NULL
  NUMBER
  STRING
}

type EvaluatedResult {
  boolean: Boolean
  number: Float
  string: String

  # Defining in which attribute is the value set
  type: EvalResultType
}

# Evaluated condition node
type EvaluatedTreeNode {
  fieldName: String
  operator: String
  query: String
  result: EvaluatedResult
  source: String
  type: String!
}

# Single event
type Event {
  # Event data - key value pairs
  data: [EventKeyValuePair!]

  # Event id
  id: String!

  # Event timestamp in ISO-8601 format
  time: String!
}

# Input type for namespace, namespaceKey and namespaceKeyValue queries
input EventFilterTimeRangeInput {
  # Optional filter definition.
  filter: FilterInput

  # Contextual search query string. If used along with filter, events must match both filters.
  query: String

  # The time range to retrieve the events for
  timeRange: TimeRangeInput!
}

# Single event key-eventCount pair
type EventKeyEventCountPair {
  eventCount: Int!
  key: String!
}

# Single event keyValue-eventCount pair
type EventKeyValueEventCountPair {
  eventCount: Int!
  value: String!
}

# Single event key-value pair
interface EventKeyValuePair {
  key: String!
  value: String! @deprecated(reason: "Kept for backwards compatibility, will be removed in favor of typed values (valueString, valueBytes)")
}

# Response type for event key-values queries
type EventKeyValuesResponse {
  # Key name
  key: String!

  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Namespace name
  namespace: String!

  # Paging information.
  pageInfo: PageInfo

  # List of keyValue-eventCount pairs
  values: [EventKeyValueEventCountPair!]
}

# Response type for event key queries
type EventKeysResponse {
  # List of key-eventCount pairs
  keys: [EventKeyEventCountPair!]

  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Namespace name
  namespace: String!

  # Paging information.
  pageInfo: PageInfo
}

# Response type for event namespace queries, returning list of names
type EventNamespacesResponse {
  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # List of namespace names
  namespaces: [String!]
}

type EventQueries {
  # Obtain a list of values associated with `namespace` and `key` matching `query` + their counts
  namespaceKeyValues(key: String!, namespace: String!, paging: PagingInput, query: EventFilterTimeRangeInput, sortBy: EventSortByKeyValueOrCountInput): EventKeyValuesResponse

  # Obtain a list of keys associated with `namespace` matching `query` + their counts
  namespaceKeys(namespace: String!, paging: PagingInput, query: EventFilterTimeRangeInput, sortBy: EventSortByKeyOrCountInput): EventKeysResponse

  # Obtain a list of event namespaces either expanded or first level only
  # if false it returns dbo.* - meaning there is more namespaces starting with dbo using dot notation
  # if true (default) - it returns all namespaces e.g.: "dbo.checkins", "dbo.features", "dbo.samples"
  namespaces(expand: Boolean = true): EventNamespacesResponse

  # Search for events
  search(paging: PagingInput, query: EventsQueryInput): EventsResponse
}

# Sort by input for namespaceKeys search
input EventSortByKeyOrCountInput {
  direction: SortDirection! = ASC
  sort: EventSortByKeyOrCountItem! = COUNT
}

# Sort either by keys or by counts
enum EventSortByKeyOrCountItem {
  COUNT
  KEY
}

# Sort by input for namespaceKeyValues search
input EventSortByKeyValueOrCountInput {
  direction: SortDirection! = ASC
  sort: EventSortByKeyValueOrCountItem! = COUNT
}

# Sort either by keyValues or by counts
enum EventSortByKeyValueOrCountItem {
  COUNT
  VALUE
}

# Input type for events queries
input EventsQueryInput {
  # List of event fields to retrieve. If empty then only event_id and timestamp are returned.
  fields: [String!]

  # Optional filter definition.
  filter: FilterInput

  # Namespace to search events for
  namespace: String! = "events"

  # Contextual search query string. If used along with filter, events must match both filters.
  query: String

  # The time range to retrieve the metric for
  timeRange: TimeRangeInput!
}

# Response from events queries
type EventsResponse {
  # List of events
  events: [Event!]

  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Paging information.
  pageInfo: PageInfo

  # Total count of events without paging.
  totalEventsCount: Int
}

# ExclusionFilter is a set of regular expressions used to exclude unwanted log messages.
# The filters may be scoped to an entire organization or a single token
type ExclusionFilter {
  description: String
  enabled: Boolean!
  expressions: [ExclusionFilterExpression!]!
  id: ID!
  name: String!
  tokenSignature: String
}

type ExclusionFilterExpression {
  expression: String!
  id: ID!
  kind: ExclusionFilterExpressionKind!
}

enum ExclusionFilterExpressionKind {
  REGEX
  STRING
}

enum ExclusionFilterResponseCode {
  DUPLICATE_ENTRY
  INTERNAL_SERVER_ERROR
  INVALID_REGEX
  INVALID_TOKEN_SIGNATURE
  NOT_FOUND
  OK
}

interface ExclusionFilterResponseInterface {
  code: ExclusionFilterResponseCode!
  message: String!
  success: Boolean!
}

type FeaturePermissions {
  name: String!
  rolePermissions: [RolePermissions!]!
}

type FeatureSupport {
  isTrafficFilterSupported: Boolean!
}

# Members of the group are evaluated based on an entity query with this filter.
type FilterEntityGroupDefinition {
  # String representation of 'EntityFilterInput' used to define the group
  filterExpression: String!

  # Contextual search query string based on conjunction
  # of 'EntityFilterInput.filter' and 'EntityFilterInput.query' used to define the group
  query: String
}

# Input type imported from entity-service schema
input FilterInput {
  children: [FilterInput!]
  operation: FilterOperation! = EQ
  propertyName: String
  propertySource: PropertySource
  propertyValue: String
  propertyValues: [String]
}

# Allowed entity filtering operators
enum FilterOperation {
  AND
  CONTAINS
  EQ
  EXISTS
  GE
  GT
  IN
  LE
  LT
  MATCHES
  NE
  NOT
  OR
}

type FlatAlertConditionExpression {
  # Alert Condition Expression Tree Node ID
  id: ID!

  # List of named child condition node IDs.
  links: [NamedLinks!]

  # Ordered list of expression nodes representing the flatten tree.
  # The first item is the tree root with named links using `operands`.
  value: FlatAlertConditionNode
}

# See https://swicloud.atlassian.net/wiki/spaces/NIT/pages/2700936948/Data+Format+for+storing+alerts.
type FlatAlertConditionNode {
  # Data type for "constantValue" nodes. Supported values: "boolean", "number", "string"
  dataType: String

  # Entity filter for "metricField" nodes
  entityFilter: AlertConditionNodeEntityFilter

  # Entity metric field for "metricField" nodes
  fieldName: String

  # Measurement filter for tags on metrics
  metricFilter: [FlatAlertFilterExpression]

  # Operator for combining operands. Supported values:
  # - For aggregationOperator: "COUNT", "MIN", "MAX", "AVG", "SUM", "LAST"
  # - For binaryOperator: "=", "!=", ">", "<", ">=", "<="
  # - For logicalOperator: "AND", "OR"
  # - For unaryOperator: "!"
  operator: String

  # Query specification for "queryField" nodes.
  query: String

  # Source specification for "queryField" nodes.
  source: String

  # Node (operator) type. Supported values:
  # - "aggregationOperator" (child of "binaryOperator")
  # - "binaryOperator" (root, or child of "logicalOperator", "unaryOperator")
  # - "constantValue" (root, or child of "aggregationOperator", "binaryOperator")
  # - "logicalOperator" (root, or child of "logicalOperator", "unaryOperator")
  # - "metricField" (child of "binaryOperator", "aggregationOperator")
  # - "queryField" (child of "aggregationOperator")
  # - "unaryOperator" (root, or child of "logicalOperator", "unaryOperator")
  type: String!

  # String representation of value for "constantValue" nodes.
  value: String
}

type FlatAlertFilterExpression {
  # Filter Expression Tree Node ID
  id: ID!

  # List of named child condition link IDs
  # Children filters in case of "operator" being one of "OR", "AND", "NOT".
  # In such case the "propertyName" and "propertyValue" are ignored.
  links: [NamedLinks!]

  # Ordered list of expression nodes representing the flatten tree.
  # The first item is the tree root with named links using `operands`.
  value: AlertFilterExpression
}

# Ordered list of evaluated condition nodes representing the flatten condition tree.
# The first item is the tree root with named links using `operands`.
type FlatEvaluatedConditionTreeNode {
  # Evaluated condition Tree Node ID
  id: ID!

  # List of named child condition link IDs
  links: [NamedLinks!]

  # Evaluated tree node
  value: EvaluatedTreeNode
}

type GenerateAwsCloudAccountEditWizardSessionResponse implements MutationResponseInterface {
  awsCloudAccountEditWizardSession: AwsCloudAccountEditWizardSession
  code: String!
  message: String!
  success: Boolean!
}

type GenerateAwsCloudAccountWizardSessionResponse implements MutationResponseInterface {
  awsCloudAccountWizardSession: AwsCloudAccountWizardSession
  code: String!
  message: String!
  success: Boolean!
}

input GenerateAzureAuthenticationUriInput {
  domainOrTenantId: String!
}

type GenerateAzureAuthenticationUriResponse implements MutationResponseInterface {
  code: String!
  message: String!
  sessionId: Guid!
  success: Boolean!
  uri: String!
}

type GenericExclusionFilterMutationResponse implements ExclusionFilterResponseInterface {
  code: ExclusionFilterResponseCode!
  message: String!
  success: Boolean!
}

type GeoCoordinates {
  latitude: Float!
  longitude: Float!
}

type GetAzureSubscriptionsResponse implements MutationResponseInterface {
  code: String!
  message: String!
  subscriptions: [AzureSubscription!]!
  success: Boolean!
  tenantName: String
}

input GetExclusionFilterInput {
  id: ID!
}

enum GroupMappingType {
  ORGANIZATION
  PRODUCT
}

scalar Guid

# Hardware Sensor entity
type HardwareSensor implements AlertingEntity & Entity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Sensor category (e.g. Fan, Temperature, ...).
  category: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity.
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC")

  # Sensor product line.
  model: String @deprecated(reason: "Misplaced property, not related to hardware sensor")

  # Entity name
  name: String

  # Relation: Network Device to HardwareSensor.
  networkDevice: NetworkDevice

  # Operational status
  operationalStatus: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Generic metric of any HW sensor. Its context is given by sensor category (and unit).
  sensorValue: Metric!

  # Sensor service tag.
  serviceTag: String @deprecated(reason: "Misplaced property, not related to hardware sensor")

  # State of HW sensor entity.
  state: State

  # Entity type.
  type: String!

  # Sensor value unit (e.g. RotationsPerMinute, ...).
  unit: String

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion HW Sensor Uri. Serves as natural key for HardwareSensor.
  uri: String!

  # Sensor manufacturer (e.g. Cisco, ...).
  vendor: String @deprecated(reason: "Misplaced property, not related to hardware sensor")
}

type Has implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

# HcoGroup entity represents Hybrid Cloud Observability entity group
type HcoGroup implements Entity {
  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Related EntityGroup
  group: EntityGroup

  # Unique identifier of an entity.
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # HCO Group Uri 
  # Serves as natural key for this group
  uri: String!
}

# The base interface for entities with a health score
interface HealthEntity {
  # Health score of the entity
  healthScore: HealthScore
  id: ID!
}

# Health Score
type HealthScore {
  # Health Score category label
  category: String

  # Health score value from 0 to 100
  score: Int!
}

interface HistoricalAlert {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String!

  # Alert definition severity
  alertDefinitionSeverity: AlertSeverity!

  # Condition type
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityData

  # Resolution reason
  reason: AlertReason!

  # Time when the evaluation was resolved in ISO-8601 date format - 2011-12-03T10:15:30Z
  resolvedAt: String!

  # Time when the evaluation was triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  triggeredAt: String!
}

input HistoricalAlertsFilterInput {
  # List of Alert definition IDs
  alertDefinitionIds: [String!]

  # List of Entity IDs
  entityIds: [String!]

  # List of Entity types
  entityTypes: [String!]

  # String used to search in Alert definition name or Entity display name
  searchString: String

  # List of Alert definition severities
  severities: [AlertSeverity!]

  # Time range for filter
  timeRange: AlertTimeRangeInput!
}

type HistoricalAlertsResult {
  # List of historical alerts
  alerts: [HistoricalAlert!]!

  # Cursor-based paging metadata
  pageInfo: PageInfo!

  # Historical alerts statistics data
  statistics: HistoricalAlertsStatistics!

  # Number of records in data list
  totalRecords: Int
}

type HistoricalAlertsStatistics {
  # List of alert histogram columns
  alertsHistogram: [AlertsHistogramColumn!]!

  # List of alert statistics
  alertsStatistics: [AlertStatistics!]!

  # Mean time to resolution in seconds
  meanTimeToResolveInSeconds: Int
}

type HistoricalLogAlert implements HistoricalAlert {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String!

  # Alert definition severity
  alertDefinitionSeverity: AlertSeverity!

  # Condition type
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityData

  # Resolution reason
  reason: AlertReason!

  # Time when the evaluation was resolved in ISO-8601 date format - 2011-12-03T10:15:30Z
  resolvedAt: String!

  # Time when the evaluation was triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  triggeredAt: String!
}

type HistoricalMetricAlert implements HistoricalAlert {
  # Alert definition ID
  alertDefinitionId: String!

  # Alert definition name
  alertDefinitionName: String!

  # Alert definition severity
  alertDefinitionSeverity: AlertSeverity!

  # Condition type
  conditionType: ConditionType!

  # Entity details
  entity: AlertEntityData

  # Resolution reason
  reason: AlertReason!

  # Time when the evaluation was resolved in ISO-8601 date format - 2011-12-03T10:15:30Z
  resolvedAt: String!

  # Time when the evaluation was triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  triggeredAt: String!
}

# Host entity
type Host implements AlertingEntity & Entity & HealthEntity & StatefulEntity {
  agentVersion: String
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Extension field that adds APM Host fields to the Host entity
  apm: APMHostExtension
  architecture: String
  availabilityZone: String

  # Extension field that adds Azure VM fields to the Host entity
  azureVm: AzureVMHostExtension
  cloudProvider: String
  cpu: String
  cpuCores: Int
  cpuCount: Int

  # Date and time of entity creation in UTC.
  createdTime: String

  # Relation: Host to Service
  deployedServices: [Service!]

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  distro: String

  # Extension field that adds EC2 instance fields to the Host entity
  ec2: EC2HostExtension
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Read-only flag that's 'true' when there is "apm" extension set on the entity
  # and 'false' if there's not.
  hasApm: Boolean!

  # Read-only flag that's 'true' when there is "azureVm" extension set on the entity
  # and 'false' if there's not.
  hasAzureVm: Boolean!

  # Read-only flag that's 'true' when there is "ec2" extension set on the entity
  # and 'false' if there's not.
  hasEc2: Boolean!

  # Read-only flag that's 'true' when there is "uams" extension set on the entity
  # and 'false' if there's not.
  hasUams: Boolean!
  healthScore: HealthScore

  # Host Id
  hostId: String!
  hostType: String

  # Host Name
  hostname: String!

  # Unique identifier of an entity
  id: ID!
  ipAddresses: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  macAddresses: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Original host name. User can add hostname alias in the config of instrumentation lib (which will override observed value). This attribute is used to represent observed/polled name.
  originalHostname: String

  # os description
  osDescription: String

  # Os name
  osName: String

  # Os type
  osType: String

  # Os version
  osVersion: String
  region: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Relation: Websites that are hosted on this host
  relatedWebsites: [Website!]

  # State of Host entity
  state: State
  system: String
  systemVersion: String

  # Trace service host error
  traceServiceHostErrors: Metric!

  # Trace service host request
  traceServiceHostRequests: Metric!

  # Trace service host response time
  traceServiceHostResponseTime: Metric!

  # Entity type.
  type: String!

  # Extension field that adds UAMS Host fields to the Host entity
  uams: UAMSHostExtension

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type HttpHeader {
  name: String
  value: String
}

# Indirect (transitive) relationship. E.g: A -> B -> C gives indirect relationship A -> C
type IndirectRelationship implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

type InstallInstruction {
  script: String
  sessionId: String
}

type InvalidField {
  field: String!
  message: String!
}

# IpAddress entity
type IpAddress implements Entity {
  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity.
  id: ID!

  # Interface index
  ifIndex: Int

  # IpAddress
  ip: String

  # IpAddress type (IPv4, IPv6)
  ipType: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name.
  name: String

  # Relation: Network Device to Ip Address
  networkDevice: NetworkDevice

  # Relation: Network Interface to Ip Address
  networkInterface: NetworkInterface

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion NodeIPAddresses Uri
  uri: String!
}

type IpLookupDetails implements AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
  hostname: String!
  resolvedIp: String!
}

type IsEntitlementSubscribedResponse {
  isSubscribed: Boolean!
  name: String!
}

scalar JSON

input KeyValue {
  key: String!
  value: String!
}

# Tag key and value used when grouping measurement streams
input KeyValuePairInput {
  key: String!
  value: String!
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

enum KubernetesCloudProvider {
  AWS
  Azure
  Other
}

# Kubernetes Cluster entity
type KubernetesCluster implements Entity & HealthEntity {
  cloudProvider: KubernetesCloudProvider

  # Provides current CPU usage.
  clusterCpuUsagePercent: Metric!

  # The Unique Id of the cluster.
  clusterUid: String

  # Provides information about total core count in the cluster.
  cpuCapacity: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Provides information about total cluster memory capacity.
  memoryCapacity: Metric!

  # Provides current cluster memory usage.
  memoryUsagePercent: Metric!

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Provides information about node count during the time.
  nodeCount: Metric!

  # Provides information about pod count during the time.
  podCount: Metric!

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Kubernetes Container entity
type KubernetesContainer implements Entity & StatefulEntity {
  # The unique Id of the cluster.
  clusterUid: String

  # The unique Id of the container
  containerId: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Container image id
  imageId: String

  # Container image name
  imageName: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String
  namespace: String @deprecated(reason: "Use namespaceName instead. This will be removed.")

  # The kubernetes namespace of the container
  namespaceName: String

  # Kubernetes Pod to which this container belongs.
  pod: KubernetesPod

  # Name of the pod.
  podName: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # State of entity
  state: State

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Kubernetes DaemonSet entity
type KubernetesDaemonSet implements Entity {
  # Kubernetes Cluster to which this DaemonSet belongs.
  cluster: KubernetesCluster

  # The Unique Id of the Cluster.
  clusterUid: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Creation time in unix timestamp for a DaemonSet
  creationTime: Int

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Namespace to which this DaemonSet belongs.
  namespace: KubernetesNamespace

  # The kubernetes namespace of the DaemonSet
  namespaceName: String

  # Available amount of pods
  podsAvailableCount: Int

  # Pods that are running
  podsReadyCount: Int

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Kubernetes Deployment entity
type KubernetesDeployment implements Entity {
  # Cluster to whichh this Deployment belongs.
  cluster: KubernetesCluster

  # The Unique Id of the Cluster.
  clusterUid: String

  # Indicating the status of "Available" condition. Possible values are: "true", "false", "unknown"
  conditionAvailable: String

  # Indicating the status of "Progressing" condition. Possible values are: "true", "false", "unknown"
  conditionProgressing: String

  # Indicating the status of "ReplicaFailure" condition. Possible values are: "true", "false", "unknown"
  conditionReplicaFailure: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Creation time in unix timestamp for a Deployment
  creationTime: Int

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Namespace to which this Deployment belongs.
  namespace: KubernetesNamespace

  # The kubernetes namespace of the Deployment
  namespaceName: String

  # Pods that are running
  podsReadyCount: Int

  # Total amount of pods
  podsTotalCount: Int

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Desired number of Replicas from Spec
  replicasCount: Int

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type KubernetesManifest {
  clusterUid: String!
  manifest: String!
}

# Kubernetes Namespace entity
type KubernetesNamespace implements Entity {
  # Cluster to which this Namespace belongs.
  cluster: KubernetesCluster

  # The Unique Id of the Cluster.
  clusterUid: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Creation time in unix timestamp for a Namespace
  creationTime: Int

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Kubernetes Node entity
type KubernetesNode implements Entity & HealthEntity & StatefulEntity {
  # Kubernetes Cluster to which this Node belongs.
  cluster: KubernetesCluster

  # The Unique Id of the cluster.
  clusterUid: String

  # Container runtime version that is installed on the node
  containerRuntimeVersion: String

  # Provides information about total core count in the node.
  cpuCapacity: Metric!

  # Provides current CPU usage.
  cpuUtilization: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Provides information about the number of file system reads and writes.
  fileSystemIops: Metric!

  # Provides information about the throughput volume of file system reads and writes in bytes.
  fileSystemThroughput: Metric!

  # Provides information about the file system usage in bytes.
  fileSystemUsage: Metric!

  # Health score of the entity
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Provides information about total node memory capacity.
  memoryCapacity: Metric!

  # Provides current node memory usage.
  memoryUtilization: Metric!

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Provides information about the network utilization - bytes received.
  networkBytesReceived: Metric!

  # Provides information about the network utilization - bytes transmitted.
  networkBytesTransmitted: Metric!

  # The UID of the Node.
  nodeUid: String

  # Information about the operating system
  osImage: String

  # Provides information about pod count during the time.
  podCount: Metric!

  # Information about the provider that is hosting the node
  providerId: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # State of entity
  state: State

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Kubelet version that is operating the node
  version: String
}

# Kubernetes Pod entity
type KubernetesPod implements Entity & StatefulEntity {
  # Cluster to which this pod belongs.
  cluster: KubernetesCluster

  # The unique Id of the cluster.
  clusterUid: String

  # Completion time in unix timestamp for a pod
  completionTime: Int

  # Provides information about container count.
  containerCount: Metric!

  # Provides current CPU usage.
  cpuUsage: Metric!

  # Type of entity responsible for creating the pod
  createdByKind: String

  # Name of entity responsible for creating the pod
  createdByName: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Creation time in unix timestamp for a pod
  creationTime: Int

  # DaemonSet to which this pod belongs.
  daemonset: KubernetesDaemonSet

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Provides information about the number of file system reads and writes.
  fileSystemIops: Metric!

  # Provides information about the throughput volume of file system reads and writes in bytes.
  fileSystemThroughput: Metric!

  # Provides information about the file system usage in bytes.
  fileSystemUsage: Metric!

  # The current host IP of the pod
  hostIp: String

  # Controls whether the pod may use the node network namespace
  hostNetwork: Boolean

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Provides current memory usage.
  memoryUsage: Metric!

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String
  namespace: String @deprecated(reason: "Use namespaceName instead. This will be removed.")

  # The kubernetes namespace of the pod
  namespaceName: String

  # Provides information about the network utilization - bytes received.
  networkBytesReceived: Metric!

  # Provides information about the network utilization - bytes transmitted.
  networkBytesTransmitted: Metric!

  # Relation: Pod to KubernetesNode
  node: KubernetesNode

  # Pod IP address
  podIp: String

  # The unique Id of the pod.
  podUid: String

  # Name of the priority class assigned to the pod
  priorityClass: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # ReplicaSet to which this pod belongs.
  replicaset: KubernetesReplicaSet

  # Start time in unix timestamp for a pod
  startTime: Int

  # State of entity (status phase of the Pod (Pending, Running, Succeeded, Failed, Unknown))
  state: State

  # StatefulSet to which this pod belongs.
  statefulset: KubernetesStatefulSet

  # Provides the reason of Pending/Unknown/Failure states
  # possible states are Evicted|NodeAffinity|NodeLost|Shutdown|UnexpectedAdmissionError
  # TODO: move this property to native state when we switch from metric ingestion to events ingestion.
  statusReason: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Kubernetes ReplicaSet entity
type KubernetesReplicaSet implements Entity {
  # The Unique Id of the Cluster.
  clusterUid: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Creation time in unix timestamp for a ReplicaSet
  creationTime: Int

  # Deployment to which this ReplicaSet belongs.
  deployment: KubernetesDeployment

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # The kubernetes namespace of the ReplicaSet
  namespaceName: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

# Kubernetes StatefulSet entity
type KubernetesStatefulSet implements Entity {
  # Cluster to which this StatefulSet belongs.
  cluster: KubernetesCluster

  # The Unique Id of the Cluster.
  clusterUid: String

  # Date and time of entity creation in UTC.
  createdTime: String

  # Creation time in unix timestamp for a StatefulSet
  creationTime: Int

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  # Setting the explicit value of this property updates it to that value.
  # Setting empty/null value to this property makes this property returning value of `name` property.
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Namespace to which this StatefulSet belongs.
  namespace: KubernetesNamespace

  # The kubernetes namespace of the StatefulSet
  namespaceName: String

  # Pods that are running
  podsReadyCount: Int

  # Total amount of pods
  podsTotalCount: Int

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Desired number of Replicas from Spec
  replicasCount: Int

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

input LastTriggeredFilterInput {
  # Whether to include never triggered in the result
  neverTriggered: Boolean

  # Time ranges for filter
  timeRanges: [AlertTimeRangeInput!]
}

type Layout {
  height: Int!
  id: String!
  width: Int!
  x: Int!
  y: Int!
}

input LayoutInput {
  height: Int!
  id: String!
  width: Int!
  x: Int!
  y: Int!
}

input ListExclusionFilterInput {
  query: String
}

input ListLogArchivesInput {
  startTimestamp: Int!
}

type LogArchive {
  downloadUrl: String!
  id: ID!
  name: String!
}

enum LogArchiveProvider {
  AWS
  AZURE
  SWO_INTERNAL
}

type LogArchiveProviderStatus {
  id: ID!
  isEnabled: Boolean!
  provider: LogArchiveProvider!
}

enum LogArchiveResponseCode {
  INTERNAL_SERVER_ERROR
  OK
  PROVIDER_UNREACHABLE
}

interface LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  message: String!
  success: Boolean!
}

type LogEvent {
  facility: String
  id: ID!
  isJson: Boolean
  message: String!
  positions: [LogEventPositions!]!
  program: String
  receivedAt: TimestampMs!
  severity: String
  sourceId: ID
  sourceName: String
}

type LogEventPositions {
  length: Int!
  starts: [Int!]!
}

type LogEvents {
  cursor: LogEventsCursor!
  events: [LogEvent!]!
}

type LogEventsCursor {
  maxId: ID!
  maxTimestamp: TimestampMs!
  minId: ID!
  minTimestamp: TimestampMs!
  missedEvents: Boolean!
}

input LogEventsInput {
  direction: Direction!
  entityIds: [ID!]
  groupId: ID
  maxId: ID
  maxTime: TimestampMs
  minId: ID
  minTime: TimestampMs
  query: String
  searchLimit: Int!
  sourceId: ID
  visibleIds: [ID!]
}

type LogFilter {
  createdAt: Timestamp
  deletedAt: Timestamp
  description: String
  enabled: Boolean!
  expressions: [LogFilterExpression!]!
  global: Boolean!
  groups: [LogGroup!]!
  id: ID!
  name: String!
  orgId: String!
  readonly: Boolean!
  updatedAt: Timestamp
}

type LogFilterExpression {
  enabled: Boolean!
  id: ID!
  kind: LogFilterKind!
  operator: LogFilterOperator!
  value: String!
}

input LogFilterExpressionInput {
  enabled: Boolean
  id: ID
  kind: LogFilterKind!
  operator: LogFilterOperator!
  value: String!
}

input LogFilterInput {
  filterId: ID!
}

enum LogFilterKind {
  REGEX
  STRING
}

enum LogFilterOperator {
  CONTAINS
  DOES_NOT_CONTAIN
}

type LogGroup {
  createdAt: Timestamp
  deletedAt: Timestamp
  description: String
  httpHosts: [String!]!
  id: ID!
  name: String!
  orgId: String!
  readonly: Boolean!
  swokenSignature: String
  syslogApps: [String!]!
  syslogHosts: [String!]!
  tags: [String!]!
  updatedAt: Timestamp
}

input LogGroupInput {
  id: ID!
}

type LogGroupPT {
  default: Boolean!
  editable: Boolean!
  id: ID!
  name: String!
}

input LogGroupPTInput {
  groupId: ID!
}

type LogGroupResponse implements MutationResponseInterface {
  code: String!
  logGroup: LogGroup!
  message: String!
  success: Boolean!
}

type LogMetrics {
  maxTimestamp: TimestampMs!
  metrics: [TimeSeriesSampleMs!]!
  minTimestamp: TimestampMs!
}

input LogMetricsInput {
  entityIds: [ID!]
  groupId: ID
  maxTime: TimestampMs
  minTime: TimestampMs
  query: String
  sourceId: ID
}

input LogSearchesInput {
  groupId: ID
}

type LogSource {
  editable: Boolean!
  id: ID!
  name: String!
}

input LogSourceInput {
  id: ID!
}

type LogViewerSettings {
  chromeless: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  density: Density! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  dynamicFavicon: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  font: String! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  highlightMatches: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  id: String! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  tailingEdge: TailingEdge! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  themeId: Int! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  truncate: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  utcTimestamps: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  visibility: VisibilitySettings! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
}

enum LogsCollectionScope {
  EVERYTHING
  PLUGIN
  PLUGIN_INSTANCE
  UAMS_CLIENT
}

# Imported from entity-service-schema
type Measurement {
  time: String!
  value: Float
}

# One metric measurement stream
type MeasurementSeries {
  # Deprecated. Use "bucketSizeInSeconds".
  bucketSizeInS: Int!

  # How large is the aggregation bucket used to calculate this stream.
  bucketSizeInSeconds: Int

  # Array of measurements - data points
  measurements: [Measurement!]!

  # Set of tags and their values for this measurement stream
  tags: [Tag!]
}

# Measurements query result
type Measurements {
  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Paging information. The paging is done across measurement series.
  pageInfo: PageInfo!

  # Measurement series with data point
  series: [MeasurementSeries!]!
}

# Relationship used to assign an entity to an Entity Group.
type MemberOf implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

input MemberRolesInput {
  role: OrganizationRole
}

type MetadataQueries {
  # Get metadata about property name across all entity types, where property name contains given query
  entityPropertyNameMetadata(paging: PagingInput, query: String): PropertyNameMetadataResult!

  # Get metadata about given entity type.
  # limitToExtensions is optional argument, use to filter output only to desired extensions. Null argument means return
  # all extensions, empty array means that metadata will be only for the base type.
  entityTypeMetadata(limitToExtensions: [String!], type: String!): EntityTypeMetadata

  # Get list of all entity types
  entityTypes: [String!]!

  # Get metadata about given relationship type
  relationshipTypeMetadata(type: String!): RelationshipTypeMetadata

  # Get list of all relationship types
  relationshipTypes: [String!]!
}

# Type describing single metric
type Metric {
  displayName: String @deprecated(reason: "Display name should be localized. Use 'name' and map it to localized value in client")

  # Formula for calculating the metric
  formula: String

  # Name of this metric (same as the "name" field)
  id: ID!

  # Obtain a list of values associated with `metric` and `key` containing `query`
  keyValues(key: String!, paging: PagingInput, query: String, timeRange: TimeRangeInput): MetricKeyValuesInfo

  # Obtain a list of keys associated with `metric` containing `query`
  keys(paging: PagingInput, query: String, timeRange: TimeRangeInput): MetricKeysInfo

  # Metric measurements. Can be queried using various filters, aggregations etc.
  # Paging argument is applied to series, not to individual measurements.
  # If you ask for first 3 items you get (at most) first 3 groups according 
  # to "groupBy" definition but each group will have all the metric measurement
  # according to a time range and bucket size.
  measurements(metricInput: MetricQueryInput!, paging: PagingInput): Measurements!
  measurements_old(metricInput: MetricQuery!, timeFilter: TimeFilter!): Measurements!

  # If the metric is defined by formula then this property contains list of all the metrics used in the formula.
  metricsUsedInFormula: [String!]

  # Name of this metric
  name: String!

  # Units for this metric values
  units: String
}

# Available metric aggregation functions
enum MetricAggregationFunction {
  AVG
  COUNT
  LAST
  MAX
  MIN
  SUM
}

# Type representing a desired metric aggregation
input MetricAggregationInput {
  # Secondary aggregation to allow aggregating datapoints inside individual buckets.
  # Has to be set together with `bucketGrouping` and then the data points in each bucket are grouped using `bucketGrouping`
  # tags and aggregated using  this method before sending up to the main aggregation over the whole bucket.
  bucketGroupAggregationMethod: MetricAggregationFunction

  # Secondary grouping to allow aggregating datapoints inside individual buckets.
  # Has to be set together with `bucketGroupAggregationMethod` and then the data points in each bucket are grouped using these
  # tags and aggregated using `bucketGroupAggregationMethod` before sending up to the main aggregation over the whole bucket.
  bucketGrouping: [String!]

  # Deprecated. Use "bucketSizeInSeconds".
  bucketSizeInS: Int

  # Size of an aggregation bucket.
  # The actual returned bucket size may be different if the metric has lower granularity than requested.
  # Caller should always check bucketSizeInS property in the result.
  bucketSizeInSeconds: Int

  # If true and missingDataPointsHandling is other than 'NONE', then if the measurement series would be empty, it is
  # instead filled with values according to missingDataPointsHandling.
  fillIfResultEmpty: Boolean = false

  # How many data points should be returned at most.
  # Service should calculate proper bucketSizeInS to return at most this number of data points.
  # If both "maxDataPoints" and "bucketSizeInSeconds" are set then "maxDataPoints" takes precedence.
  maxDataPoints: Int

  # Aggregation method such as "avg, min, max". The method can be omitted for composite metrics as these can already contain aggregation.
  method: MetricAggregationFunction

  # How the missing values should be handled. If value other than NONE is used, the missing buckets according to
  # "bucketSizeInSeconds" or "maxDataPoints" are filled with value based on specified option.
  missingDataPointsHandling: MissingMeasurementDataPointsHandling = NONE
}

type MetricDataPoint {
  timestamp: Timestamp!
  value: MetricValue
}

# Response type for metric key values requests
type MetricKeyValuesInfo {
  # Metric key.
  key: String!

  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Paging information.
  pageInfo: PageInfo!

  # Metric key values
  values: [String!]!
}

# Response type for metric keys requests
type MetricKeysInfo {
  # Metric keys.
  keys: [String!]!

  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Paging information.
  pageInfo: PageInfo!
}

# Available metric sources
enum MetricKindInput {
  BUILD_IN
  BUILT_IN_AND_STORED
  STORED
}

# Type describing single property
type MetricMetadata {
  # Formula for calculating the metric
  formula: String

  # Obtain a list of values for `key` associated with this `metric` and `EntityType`
  keyValues(key: String!): MetricKeyValuesInfo

  # Obtain a list of keys associated with this `metric` and `EntityType`
  keys: MetricKeysInfo

  # If the metric is defined by formula then this property contains list of all the metrics used in the formula.
  metricsUsedInFormula: [String!]

  # Name of the metric
  name: String!

  # Units for this metric values
  units: String
}

# Response type for metric names requests
type MetricNamesInfo {
  # Metadata for this result. Only used for development.
  metadata: QueryMetadata

  # Metric names
  names: [String!]!

  # Paging information.
  pageInfo: PageInfo!
}

type MetricQueries {
  # Get single metric
  byName(name: String!): Metric

  # Get metrics of given names. If list of names is empty then empty array is returned.
  byNames(names: [String!]!): [Metric!]!

  # Obtain a list of metric names containing `query`
  names(paging: PagingInput, query: String, timeRange: TimeRangeInput): MetricNamesInfo
}

# Input type for a metric time-series query
input MetricQuery {
  aggregationFunction: AggregationFunction!
  filter: TagFilter
  groupBy: [String!]
}

# Input type for generic metric values queries
input MetricQueryInput {
  # Expected metric results aggregation.
  aggregation: MetricAggregationInput!

  # Optional filter definition.
  filter: FilterInput

  # List of tags to group by measurements
  groupBy: [String!]

  # Contextual search query string. If used along with filter, metric must match both filters.
  query: String

  # Sort definition. It's possible to sort by time, "groupBy" tags or by aggregated values.
  # To sort by time use special identifier "<time>".
  # To sort by aggregated value use special identifier "<value>".
  # To sort by tags use the tag name.
  # The default sort is: "<time> ASC"
  # If you specify custom sort then the time is not used, you have to explicitly include it 
  # in your sort definition.
  sortBy: [MetricSortItemInput!]

  # The time range to retrieve the metric for
  timeRange: TimeRangeInput
}

# Single metric key sort definition.
input MetricSortItemInput {
  direction: SortDirection
  key: String!
}

# Metric value may be number or string depending on particular metric
scalar MetricValue

type MfaBackupCode {
  code: String
  used: Boolean
}

input MfaBackupCodesInput {
  password: String!
  userId: String!
}

type MfaSettings {
  enabled: Boolean
  lifespan: Int
}

type MfaSettingsResponse implements MutationResponseInterface {
  code: String!
  enabled: Boolean
  lifespan: Int
  message: String!
  success: Boolean!
}

# Missing metric datapoints handling options
enum MissingMeasurementDataPointsHandling {
  # Fill missing data points with the value of last previous data point.
  LAST_VALUE_FILL

  # Do nothing. Missing data points are not returned.
  NONE

  # Fill missing data points with value 'null'.
  NULL_FILL

  # Fill missing data points with value 0.
  ZERO_FILL
}

type MockAggregationByCategoryRecord {
  aggregatedValue: Float!
  category: String!
}

input MockMetricAggregatedValueInput {
  aggregationMethod: MockMetricAggregationMethod!
  filters: [MockMetricFilterInput!]
  metricName: String!
  timeRange: MockMetricTimeRangeInput!
}

type MockMetricAggregatedValueResponse {
  aggregationMethod: MockMetricAggregationMethod!
  metricName: String!
  value: Float
  valueFromPreviousPeriod: Float
}

enum MockMetricAggregationMethod {
  AVERAGE
  MAX
  MIN
  SUM
}

input MockMetricFilterInput {
  arguments: [String!]
  children: [MockMetricFilterInput!]
  operator: MockMetricFilterOperator!
}

enum MockMetricFilterOperator {
  eq
}

input MockMetricTimeRangeInput {
  endTime: DateTime!
  startTime: DateTime!
}

type MockPerformanceTestMetric {
  averageValueSet: MockPerformanceTestMetricValue!
  latestValues(count: Int!): [MockPerformanceTestMetricValue!]!
  metricAggregatedValue(input: MockMetricAggregatedValueInput!): MockMetricAggregatedValueResponse!
  timeSeries(input: MockTimeSeriesInput!): [MockPerformanceTestMetricValue!]!
}

type MockPerformanceTestMetricValue {
  contentSizesByContentType: [MockAggregationByCategoryRecord!]
  contentSizesByDomain: [MockAggregationByCategoryRecord!]
  loadTimeMs: Int
  pageSizeBytes: Int
  requestsByContentType: [MockAggregationByCategoryRecord!]
  requestsByDomain: [MockAggregationByCategoryRecord!]
  requestsCount: Int
  time: DateTime
  timestamp: Timestamp
}

input MockTimeSeriesAggregationOptions {
  maxDataPoints: Int!
  method: MockMetricAggregationMethod!
}

input MockTimeSeriesInput {
  aggregation: MockTimeSeriesAggregationOptions!
  endTime: DateTime!
  startTime: DateTime!
}

type MonitoringOptions {
  isAvailabilityActive: Boolean
  isRumActive: Boolean
}

input MonitoringOptionsInput {
  isAvailabilityActive: Boolean
  isRumActive: Boolean
}

type Mutation {
  addOtelReceiver(receiver: OtelReceiverInput): OtelReceiverResponse
  addUamsClientRole(clientId: String!, role: String!): Boolean

  # Mutations related to Alerting.
  alertMutations: AlertMutations!
  createAwsCloudAccount(input: CreateAwsCloudAccountInput!): CreateAwsCloudAccountResponse!
  createAzureCloudAccount(input: CreateAzureCloudAccountInput!): CreateAzureCloudAccountResponse!
  createAzureIntegration(input: CreateAzureIntegrationInput!): CreateAzureIntegrationResponse!
  createCategory(input: CreateCategoryInput!): CreateCategoryResponse!
  createDashboard(input: CreateDashboardInput!): CreateDashboardResponse!
  createEmailVerification(email: String): MutationResponse!

  # Creates a new Entity Group.
  createEntityGroup(definition: EntityGroupInput!): CreateEntityGroupResult!
  createExclusionFilter(input: CreateExclusionFilterInput!): CreateExclusionFilterResponse!
  createInstallationSession(osType: OsType, token: String): AgentInstallInstruction
  createKubernetesManifest(input: CreateKubernetesManifestInput!): CreateKubernetesManifestResponse!
  createLogArchiveStorage(input: CreateLogArchiveStorageInput!): CreateLogArchiveStorageResponse!
  createLogFilter(input: CreateLogFilterInput!): CreateLogFilterResponse
  createLogGroup(input: CreateLogGroupInput!): LogGroupResponse
  createLogSearch(input: CreateLogSearchInput!): SavedLogSearchResponse!
  createLogSearchHistory(input: CreateLogSearchHistoryInput!): MutationResponse!
  createNotificationServiceConfiguration(configuration: createNotificationServiceConfigurationInput!): CreateNotificationServiceConfigurationResponse!
  createOrganizationInvitation(input: CreateOrganizationInvitationInput): CreateOrganizationInvitationResponse
  createSamlConfiguration(input: CreateSamlConfigurationInput!): SamlConfigurationResponse!
  createSavedSearch(input: CreateSavedSearchInput!): CreateSavedSearchResponse!
  createToken(input: CreateTokenInput): CreateTokenResponse
  createWebsite(input: CreateWebsiteInput!): CreateWebsiteResult!
  deleteAwsCloudAccounts(input: DeleteCloudAccountsInput!): DeleteCloudAccountsResponse!
  deleteAzureCloudAccounts(input: DeleteCloudAccountsInput!): DeleteCloudAccountsResponse!
  deleteCategory(input: DeleteCategoryInput!): DeleteCategoryResponse!
  deleteClient(clientId: String): Boolean
  deleteDashboard(input: DeleteDashboardInput!): DeleteDashboardResponse!
  deleteDatabase(req: DeleteDatabaseRequest!): DeleteDatabaseResponse!

  # Deletes an Entity Group.
  deleteEntityGroup(id: ID!): DeleteEntityGroupResult!
  deleteExclusionFilter(input: DeleteExclusionFilterInput!): GenericExclusionFilterMutationResponse!
  deleteLogFilter(input: DeleteLogFilterInput!): EmptyLogFilterResponse
  deleteLogGroup(input: LogGroupInput!): EmptyLogGroupResponse
  deleteNotificationServiceConfiguration(input: DeleteNotificationServiceConfigurationInput!): DeleteNotificationServiceConfigurationResponse
  deleteOrganizationInvitation(email: ID!): MutationResponse!
  deleteOrganizationMember(userId: ID!): DeleteOrganizationMemberResponse!
  deleteSamlConfiguration: MutationResponse!
  deleteSavedSearch(input: DeleteSavedSearchInput!): DeleteSavedSearchResponse!
  deleteService(input: DeleteServiceInput!): DeleteServiceResult!
  deleteToken(input: DeleteTokenInput): DeleteTokenResponse
  deleteUserTrustedDevice(input: UpdateUserTrustedDeviceInput!): MutationResponse!
  deleteWebsite(input: DeleteWebsiteInput!): DeleteWebsiteResult!
  downloadDiagnostics(clientId: ID!, diagnosticsType: DiagnosticsType, requestedInstanceDiagnosticsSizeKb: Int, scopeInfo: ScopeInfo!): String
  enableClientAutoUpdate(clientId: String, isAutoUpdateEnabled: Boolean): Boolean
  enableGlobalAutoUpdate(isAutoUpdateEnabled: Boolean): Boolean

  # Mutations related to entities
  entities: EntityMutations!
  generateAwsCloudAccountEditWizardSession(sessionId: Guid): GenerateAwsCloudAccountEditWizardSessionResponse!
  generateAwsCloudAccountWizardSession: GenerateAwsCloudAccountWizardSessionResponse!
  generateAzureAuthenticationUri(input: GenerateAzureAuthenticationUriInput!): GenerateAzureAuthenticationUriResponse!
  getAzureSubscriptions(input: AzureCredentialInput!): GetAzureSubscriptionsResponse!
  getAzureSubscriptionsForIntegration(entityId: String!): GetAzureSubscriptionsResponse!
  nim: NimMutations
  observeDatabase(req: ObserveDatabaseRequest!): ObserveDatabaseResponse!
  regenerateMfaBackupCodes(input: MfaBackupCodesInput): RequestMfaBackupCodesResponse!
  removeUamsClientRole(clientId: String!, role: String!): Boolean
  requestMfaBackupCodes(input: MfaBackupCodesInput): RequestMfaBackupCodesResponse!
  resendOrganizationInvitation(email: ID!): MutationResponse!
  resetMfa(input: ResetMfaInput!): MutationResponse!
  restartPluginInstance(clientId: String, pluginId: String, pluginInstanceId: String): Boolean
  restartUamsClient(clientId: String): Boolean
  setDatabaseCredentials(req: SetDatabaseCredentialsRequest!): SetDatabaseCredentialsResponse!
  slackAuthorizeUrl(url: String!): SlackAuthorizeUrlResponse
  startPluginInstance(clientId: String, pluginId: String, pluginInstanceId: String): Boolean
  stopPluginInstance(clientId: String, pluginId: String, pluginInstanceId: String): Boolean
  testNotificationServiceConfiguration(input: TestNotificationServiceConfigurationInput!): TestNotificationServiceConfigurationResponse!
  toggleLogFilter(input: ToggleLogFilterInput!): EmptyLogFilterResponse
  unobserveDatabase(req: UnobserveDatabaseRequest!): UnobserveDatabaseResponse!
  updateAwsCloudAccount(input: UpdateAwsCloudAccountInput!): UpdateAwsCloudAccountResponse!
  updateAzureCloudAccount(input: UpdateAzureCloudAccountInput!): UpdateAzureCloudAccountResponse!
  updateAzureIntegration(input: UpdateAzureIntegrationInput!): UpdateAzureIntegrationResponse!
  updateCategory(input: UpdateCategoryInput!): UpdateCategoryResponse!
  updateDashboard(input: UpdateDashboardInput!): UpdateDashboardResponse!
  updateDatabase(req: UpdateDatabaseRequest!): UpdateDatabaseResponse!

  # Updates existing Entity Group.
  updateEntityGroup(definition: EntityGroupInput!, id: ID!): UpdateEntityGroupResult!
  updateExclusionFilter(input: UpdateExclusionFilterInput!): GenericExclusionFilterMutationResponse!
  updateLogArchiveProviderStatus(input: UpdateLogArchiveProviderStatusInput!): UpdateLogArchiveProviderStatusResponse!
  updateLogFilter(input: UpdateLogFilterInput!): UpdateLogFilterResponse
  updateLogGroup(input: UpdateLogGroupInput!): LogGroupResponse
  updateLogSearch(input: UpdateLogSearchInput!): SavedLogSearchResponse!
  updateMemberRoles(input: MemberRolesInput!, userId: ID!): UpdateMemberRolesResponse!
  updateMfaSettings(input: UpdateMfaSettingsInput!): MfaSettingsResponse!
  updateNotificationServiceConfiguration(input: UpdateNotificationServiceConfigurationInput!): UpdateNotificationServiceConfigurationResponse
  updateOrganization(input: OrganizationAttributesInput!): UpdateOrganizationAttributesResponse!
  updateOrganizationSessionTimeout(input: UpdateSessionTimeoutInput!): SessionTimeoutResponse
  updateSamlConfiguration(input: UpdateSamlConfigurationInput!): SamlConfigurationResponse!
  updateSamlGroupMapping(input: UpdateSamlGroupMappingInput!): SamlGroupMappingResponse!
  updateSamlServiceAccounts(input: UpdateSamlServiceAccountsInput!): SamlServiceAccountsResponse!
  updateSavedSearch(input: UpdateSavedSearchInput!): UpdateSavedSearchResponse!
  updateToken(input: UpdateTokenInput): UpdateTokenResponse
  updateUser(user: UserAttributesInput!): UpdateUserAttributesResponse!
  updateUserAttribute(input: UpdateUserAttributeInput!): UpdateUserAttributeResponse!
  updateUserEmail(input: UserEmailInput!): UpdateUserEmailResponse!
  updateUserPassword(userPassword: UserPasswordInput!): UpdateUserPasswordResponse!
  updateWebsite(input: UpdateWebsiteInput!): UpdateWebsiteResult!
}

type MutationResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

interface MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

type NamedLinks {
  # Name of the link
  name: String!

  # List of linked node IDs
  values: [ID!]
}

enum NavigationItems {
  ACTIVITY_LOG
  AGENT_MANAGEMENT
  ALERTS
  API_TOKENS
  CLOUD_ACCOUNTS
  DASHBOARDS
  ENTITIES
  GENERAL
  LOGS
  METRICS
  NOTIFICATION_SERVICES
  PERMISSIONS
  SECURITY
  SYNTHETIC_MONITORING_PROBES
  TRACES
  USERS
}

type NavigationItemsResponse {
  items: [navigationItemsPermission!]
}

type Netflows {
  topConversationsByBytes(bucketSizeInSeconds: Int!, entityId: String, limit: Int!, timeFilter: TimeRangeInput!, trafficFilter: TrafficFilter): [ConversationMeasurements!]!
  topSimpleMetrics(entityId: String, limit: Int!, metric: TopNetflowMetric!, timeFilter: TimeRangeInput!, trafficFilter: TrafficFilter): [SimpleNetflowMetrics!]!
  topTimeSeriesByBytes(bucketSizeInSeconds: Int!, entityId: String, limit: Int!, metric: TopTimeSeriesMetric!, timeFilter: TimeRangeInput!, trafficFilter: TrafficFilter): [NetflowsMeasurements!]!
}

type NetflowsMeasurements {
  measurements: [Measurement!]!
  name: String!
}

# Network Device entity as a flat representation of Orion SWIS schema for all statistics related to Node 
# with telemetry mapping condition to all telemetry with existing tags 'Orion.Nodes.Uri' and 'Orion.EntityType'
type NetworkDevice implements AlertingEntity & Entity & HealthEntity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Network device allows 64 bit counters (Node Allow64BitCounters)
  allow64BitCounters: Boolean

  # Availability in percent for Node 
  availability: Metric!

  # Network device Category (Node Category)
  category: String

  # Network device CPU count (Node CPUCount)
  cpuCount: Int

  # CpuLoad in percent for Node
  cpuLoad: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Network device description (Node Description)
  description: String

  # Relation: Device Volumes that are plugged in this Network Device
  deviceVolumes: [DeviceVolume]

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String

  # Network device DNS (Node DNS)
  dns: String

  # Indicates whether Network device Dynamic IP is enabled (Node DynamicIpEnabled)
  dynamicIpEnabled: Boolean
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Relation: Hardware Sensors that are plugged in this Network Device
  hardwareSensors: [HardwareSensor]
  hasRouter: Boolean!
  hasSwitch: Boolean!
  hasWirelessController: Boolean!

  # HealthScore for Node
  healthScore: HealthScore

  # Unique identifier of an entity
  id: ID!

  # Network device IpAddress (Node IpAddress)
  ip: String

  # Relation: Ip Addresses that are plugged in this Network Device
  ipAddresses: [IpAddress]

  # Network device IpAddress type (IPv4, IPv6)
  ipType: String

  # Network device Last Boot (Node LastBoot)
  lastBoot: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Network device location (Node Location)
  location: String

  # Network device machine type (Node machineType)
  machineType: String

  # Network device manufacturer (e.g. Cisco, ...).
  manufacturer: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Network device model.
  model: String

  # Entity name
  name: String

  # Relation: Network Interfaces that are plugged in this Network Device
  networkInterfaces: [NetworkInterface]

  # NetworkDevice polling method (Node ObjectSubType)
  orionPollingMethod: String

  # PercentLoss in percent for Node
  percentLoss: Metric!

  # MemoryUsage in percent for Node 
  percentMemoryUsed: Metric!

  # Relation: Physical Ports that are plugged in this Network Device
  physicalPorts: [PhysicalPort]

  # Network device poll interval in seconds (Node PollInterval)
  pollInterval: Int

  # Network device rediscovery interval in minutes (Node RediscoveryInterval)
  rediscoveryInterval: Int

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Response time in milliseconds for Node 
  responseTime: Metric!

  # Router extension
  router: RouterNetworkDeviceExtension

  # Network device service tag.
  serviceTag: String

  # Network device Software Image (Node IOSImage)
  softwareImage: String

  # Network device software version (Node IOSVersion)
  softwareVersion: String

  # Network device statistics collection interval in minutes (Node StatCollection)
  statCollectionInterval: Int

  # State of Network Device entity.
  state: State

  # Switch extension
  switch: SwitchNetworkDeviceExtension

  # Network device Object ID (Node SysObjectId)
  sysObjectId: String

  # Network device system name (Node SysName)
  # It can be different than the Name as the Name can be changed pretty easily.
  systemName: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion Node Uri 
  # Serves as natural key for NetworkDevice
  uri: String!

  # Network device vendor (Node vendor)
  vendor: String

  # Wireless Controller extension
  wirelessController: WirelessControllerNetworkDeviceExtension
}

type NetworkDevices {
  deleteNetworkDevice(networkDeviceId: ID!): DeleteNetworkDeviceResponse!
}

# Network Interface entity
type NetworkInterface implements AlertingEntity & Entity & StatefulEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Availability in percent for Interface
  availability: Metric!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Input average bps for Interface
  inAverageBps: Metric!

  # Input Discards for Interface
  inDiscards: Metric!

  # Input Errors for Interface
  inErrors: Metric!

  # Input Utilization in percent for Interface
  inPercentUtil: Metric!

  # Input Total Bytes for Interface
  inTotalBytes: Metric! @deprecated(reason: "Misleading value depending on poll interval, use inAverageBps instead")

  # Relation: Ip Addresses that are plugged in this Network Interface
  ipAddresses: [IpAddress]

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Relation: Network Device to Network Interface
  networkDevice: NetworkDevice

  # Output average bps for Interface
  outAverageBps: Metric!

  # Output Discards for Interface
  outDiscards: Metric!

  # Output Errors for Interface
  outErrors: Metric!

  # Output Utilization in percent for Interface
  outPercentUtil: Metric!

  # Output Total Bytes for Interface
  outTotalBytes: Metric! @deprecated(reason: "Misleading value depending on poll interval, use outAverageBps instead")

  # The interface's physical address (MAC). (PhysicalAddress)
  physicalAddress: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Network Interface speed
  speed: String

  # State of Interface entity.
  state: State

  # Entity type.
  type: String!

  # Network Interface type
  typeDescription: String

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion Interfaces Uri 
  # Serves as natural key for NetworkInterface
  uri: String!
}

# This Entity represents Shadow Node, which is a node where we know just the IP address and nothing else. This entity can be important for displaying topology data.  
type NetworkShadowDevice implements AlertingEntity & Entity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion Shadow Node Uri 
  # Serves as natural key for ShadowEntity
  uri: String!
}

type NimInternals {
  id: ID
}

type NimMutations {
  networkDevices: NetworkDevices!
}

type NimQueries {
  _internals: NimInternals
  featureSupport: FeatureSupport!
  netflows: Netflows!
}

type NotificationService {
  # The created time of the NotificationService.
  createdAt: DateTime!

  # The createdBy user ID of the NotificationService.
  createdBy: String!

  # The createdBy user full name of the NotificationService.
  createdByName: String

  # The description of the NotificationService.
  description: String

  # The ID of the NotificationService.
  id: ID!

  # The settings of the NotificationService.
  settings: JSON

  # The title of the NotificationService.
  title: String!

  # The type of the NotificationService.
  type: String!
}

input NotificationServiceFilter {
  type: String
}

type NotificationServicesGroupCount {
  amazonsns: Int
  email: Int
  msTeams: Int
  opsgenie: Int
  pagerduty: Int
  pushover: Int
  servicenow: Int
  slack: Int
  sms: Int
  swsd: Int
  victorops: Int
  webhook: Int
  zapier: Int
}

input ObserveDatabaseRequest {
  bindings: [String!]
  credentials: [KeyValue!]
  databaseInstanceID: String!
  description: String
  name: String!
  options: [KeyValue!]
  type: String!
  uamsClientID: String!
}

type ObserveDatabaseResponse {
  code: String!
  databaseInstanceID: String!
  message: String
}

type ObservedFrom implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

type Organization {
  activeFeatures: [String!]!
  allPermissions: AllPermissionsResponse!
  allResources: [ResourceResponse!]!
  auditTrail(limit: Int): [AuditTrailEntity!]
  entitlements(filter: EntitlementFilterInput): [Entitlement]!
  id: ID!
  invitations: [OrganizationInvitation!]!
  isEntitlementSubscribed(input: EntitlementFilterInput!): IsEntitlementSubscribedResponse
  logEvents(input: LogEventsInput!): LogEvents! @deprecated(reason: "Please use Entity Service for querying log events.")
  logGroupPT(input: LogGroupPTInput!): LogGroupPT!
  logGroupsPT: [LogGroupPT!]!
  logMetrics(input: LogMetricsInput!): LogMetrics!
  logSearchHistory: [RecentLogSearch!]!
  logSearches(input: LogSearchesInput!): [SavedLogSearch!]!
  logSource(input: LogSourceInput!): LogSource!
  logSources: [LogSource!]!
  members(filter: OrganizationMemberFilter): [OrganizationMember!]!
  mfaConfiguration: MfaSettings!
  multiOrgUsers: [User!]
  name: String!
  navigationItems: NavigationItemsResponse!
  notificationServiceConfiguration(configurationId: String, configurationType: String): NotificationService!
  notificationServices(filter: NotificationServiceFilter): [NotificationService!]!
  notificationServicesGroupCount: NotificationServicesGroupCount!
  permission(input: PermissionInput!): PermissionResponse!
  permissions(input: [PermissionInput!]!): [PermissionResponse!]!
  registeredUamsClients(role: String): [UamsClient!]
  retentions: [Retention!]!
  role: OrganizationRole!
  samlConfiguration: SamlConfiguration
  samlGroupMapping: SamlGroupMapping
  samlServiceAccounts: [String!]!
  sessionTimeout: SessionTimeout!
  tenant: Tenant
  tokens(filter: OrganizationTokenFilter): [Token!]
  volumetricsSummary(input: VolumetricsSummaryInput!): VolumetricsSummaryResponse!
  volumetricsTimeseries(input: VolumetricsTimeseriesInput!): VolumetricsTimeseriesResponse!
  volumetricsTotal(input: VolumetricsTotalInput!): VolumetricsTotalResponse!
}

input OrganizationAttributesInput {
  name: String
}

type OrganizationBaseInfo {
  id: ID!
  joinedDate: DateTime!
  name: String!
  role: OrganizationRole!
}

input OrganizationFilter {
  orgId: String
}

type OrganizationInvitation {
  date: DateTime!
  email: ID!
  role: OrganizationRole!
}

type OrganizationMember {
  id: ID!
  role: OrganizationRole!
  user: User!
}

input OrganizationMemberFilter {
  id: String
  role: OrganizationRole
}

enum OrganizationRole {
  ADMIN
  BILLING
  MEMBER
  OWNER
  RESTRICTED_MEMBER
  VIEWER
}

type OrganizationSettings {
  autoUpdateEnabled: Boolean
  orgId: ID!
}

input OrganizationTokenFilter {
  id: String
}

enum OsType {
  LINUX
  WINDOWS
}

input OtelReceiverInput {
  clientId: String!
  instanceName: String!
  parameters: [OtelReceiverParameterInput]
  receiverName: String!
}

input OtelReceiverParameterInput {
  key: String!
  value: String!
}

type OtelReceiverResponse {
  clientId: String!
  pluginId: String!
  pluginInstanceId: String!
}

# Page info returned in results containing collection of items.
# It can be used to page through the results.
type PageInfo {
  # End cursor for this page of items. The value is an opaque string and should be used
  # as PagingInput.before|after argument in following queries.
  endCursor: String

  # True if there are more items after this page. Use `PagingInput.after=endCursor` in the next query to get to the next page.
  hasNextPage: Boolean!

  # True if there are more items before this page. Use `PagingInput.before=startCursor` in the next query to get to the next page.
  hasPreviousPage: Boolean!

  # Start cursor for this page of items. The value is an opaque string and should be used
  # as PagingInput.before|after argument in following queries.
  startCursor: String
}

input PaginationInput {
  limit: Int!
  offset: Int!
}

# Paging input for paginated queries. If not specified the first page of the results is returned and it will contain
# up to X items where X is a value configured in the system.
input PagingInput {
  # Fetch items that exist after this cursor. Cursor can be obtained from PageInfo data returned in previous query.
  after: String

  # Fetch items that exist before this cursor. Cursor can be obtained from PageInfo data returned in previous query.
  before: String

  # Get first X items from the result. This value can be used alone or in combination with "after".
  # Other combinations are invalid and will lead to query error.
  first: Int

  # Get last X items from the result. This value can be used alone or in combination with "before".
  # Other combinations are invalid and will lead to query error.
  last: Int
}

input PermissionInput {
  action: String!
  name: String!
}

enum PermissionName {
  AGENT
  AUDITLOG
  CREDENTIAL
  ENTITY
  MFA
  NAME
  NOTIFICATION
  SAML
  SESSION_TIMEOUT
  TOKEN
  USER
}

type PermissionResponse {
  action: String!
  allowed: Boolean
  name: String!
  reasons: [String]
}

# PhysicalPort entity
type PhysicalPort implements Entity {
  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity.
  id: ID!

  # IsMonitored
  isMonitored: Boolean

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name.
  name: String

  # Relation: Network Device to Physical port
  networkDevice: NetworkDevice

  # OperationalStatus
  operationalStatus: String

  # PortIndex
  portIndex: Int

  # Name
  portName: String

  # PortType
  portType: Int

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Orion UDT Port Uri
  uri: String!
}

type PlatformOptions {
  platforms: [String!]!
  testFromAll: Boolean
}

input PlatformOptionsInput {
  platforms: [String!]!
  testFromAll: Boolean
}

type PluginInfo {
  deploymentStatus: DeploymentStatus
  instances: [PluginInstanceInfo]
  pluginId: String
  version: String
}

enum PluginInstanceHealthStatus {
  HEALTHY
  UNHEALTHY
  UNKNOWN
}

type PluginInstanceInfo {
  healthStatus: PluginInstanceHealthStatus
  instanceId: String
  lastStatusUpdate: DateTime
  startupState: PluginInstanceStartupState
  statusCode: PluginInstanceStatusCode
}

enum PluginInstanceStartupState {
  START
  STOP
  UNKNOWN
}

enum PluginInstanceStatusCode {
  BROKEN
  CONFIGURATION_ISSUE
  FAILED
  HEALTHCHECK_FAILED
  INVALID
  NOT_RESPONDING
  OK
  RESTARTING
  START_FAILED
  STOPPED
  UNSPECIFIED
}

type Probe {
  active: Boolean!
  city: String!
  coordinates: GeoCoordinates!
  country: String!
  id: ID!
  ipv4: String!
  ipv6: String
  name: String!
  platform: String!
  region: String!
}

type ProbeLocation {
  type: ProbeLocationType!
  value: String!
}

input ProbeLocationInput {
  type: ProbeLocationType!
  value: String!
}

enum ProbeLocationType {
  CITY
  COUNTRY
  REGION
}

type ProfileEntry {
  class: String!
  file: String!
  hiddenChildren: [ProfileEntry!]
  id: Int!
  lineNumbers: [Int!]!
  method: String!
  parentId: Int
  percent: Float!
}

# Type describing single property
type PropertyMetadata {
  # True if it's possible to filter entities by this property
  filterable: Boolean

  # True if it's possible to group entities by this property
  groupable: Boolean

  # True if the type is a List
  list: Boolean!

  # Logical type of the property - IpAddress, Status, ...
  logicalType: String

  # Name of the property
  name: String!

  # True if the property is nullable
  nullable: Boolean!

  # Entity or relationship type in which this property exists
  ownerType: PropertyOwnerType!

  # True if the type is a Set
  set: Boolean!

  # True if it's possible to sort entities by this property
  sortable: Boolean

  # Data type of the property - String, Int, ...
  type: String!
}

# Type describing property name
type PropertyNameMetadata {
  # Special field that returns metadata about available filters for this property, its values and entity counts.
  # It can be narrowed down to a subset of entities via "filter" and "timeRange" argument and value containing query.
  # "timeRange" argument filters by "lastSeenTime" property, entities with empty "lastSeenTime" property will not be filtered out.
  filters(filter: EntityFilterInput, paging: PagingInput, query: String, timeRange: TimeRangeInput): EntityFilterMetadata!

  # List of all property occurrences across entity types
  properties: [PropertyMetadata!]!

  # Property name
  propertyName: String!
}

# Result wrapper for property name metadata query
type PropertyNameMetadataResult {
  # Paging information. If there are too many matching properties there may be multiple pages.
  pageInfo: PageInfo!

  # Properties matching given property name query.
  properties: [PropertyNameMetadata!]!
}

# Type union to describe owner type of a property - it can be either entity or relationship.
union PropertyOwnerType = EntityTypeMetadata | RelationshipTypeMetadata

enum PropertySource {
  ENTITY
  EVENT
  METRIC
}

type Query {
  _: String

  # Queries related to Alerting.
  alertQueries: AlertQueries!
  apmConfig: ApmConfig
  awsCloudFormationRedirectUrl: String!
  awsRegions: [AwsRegion!]!
  awsService(id: String!): AwsService
  awsServices: [AwsService!]!
  azureSessionSubscriptions(sessionId: Guid!): [AzureSubscription!]!
  credentials(credentialFilter: CredentialFilter): [Credential]
  dashboards: DashboardQueries
  databaseAgents(databaseInstanceID: String!): [DatabaseAgent!]

  # Profiler root field
  databaseProfiler: DatabaseProfiler!
  databaseQuery(input: DatabaseQueryInput!): DatabaseQuery!
  databaseQueryTraces(input: DatabaseTraceInput!): DatabaseTrace!
  databaseTopQueries(input: DatabaseTopQueriesInput!): [DatabaseTopQueries!]!
  dboQueries: DBOQueries

  # Queries related to entities
  entities: EntityQueries!

  # Search entities based upon the supplied filters
  entities_old(filter: EntityFilter, groupBy: EntityGroupBy, timeFilter: TimeFilter): EntitiesResponse @deprecated(reason: "Use queries in 'entities.*' type.")

  # Get a single entity by ID
  entity(id: ID!): Entity @deprecated(reason: "Use queries in 'entities.*' type.")

  # NOT CURRENTLY IMPLEMENTED
  entityCountByAttribute(attribute: String!): [EntityCounts!] @deprecated(reason: "Use queries in 'entities.*' type.")

  # Queries related to events
  events: EventQueries!
  getAzureAuthenticationState(sessionId: Guid!): AzureAuthenticationStateResponse!
  getExclusionFilter(input: GetExclusionFilterInput!): ExclusionFilter
  healthcheck: Boolean
  installInstructions(osType: OsType, role: String, roles: [String], sessionId: String, token: String): InstallInstruction
  installationStatus(sessionId: String!): AgentInstallationSession
  listExclusionFilters(input: ListExclusionFilterInput!): [ExclusionFilter!]!
  logArchiveProviders: [LogArchiveProviderStatus!]!
  logArchives(input: ListLogArchivesInput!): [LogArchive!]!
  logCollectionDownloadUrl(clientId: String): String

  # Query for logEvents
  logEvents(input: LogEventsInput!): LogEvents!

  # Queries related to metadata
  metadata: MetadataQueries!

  # Fetch a metric by name
  metric(name: String!): Metric @deprecated(reason: "Use queries in 'metrics.*' type.")

  # Obtain a list of values associated with `metric` and `key` containing `query`
  metricKeyValues(after: String, before: String, first: Int, key: String!, last: Int, metric: String!, query: String): AutocompleteResponse @deprecated(reason: "Use queries in 'metrics.*' type.")

  # Obtain a list of keys associated with `metric` containing `query`
  metricKeys(after: String, before: String, first: Int, last: Int, metric: String!, query: String): AutocompleteResponse @deprecated(reason: "Use queries in 'metrics.*' type.")

  # Queries related to metrics
  metrics: MetricQueries!

  # Obtain a list of metrics containing `query`
  metrics_old(after: String, before: String, first: Int, last: Int, query: String): AutocompleteResponse @deprecated(reason: "Use queries in 'metrics.*' type.")
  nim: NimQueries
  organizationSettings: OrganizationSettings
  probes: [Probe!]!
  registeredUamsClients(role: String): [UamsClient!]!
  savedSearches: SavedSearchQueries
  swoUrl: String
  testAwsAccountConnection(input: TestAwsAccountConnectionInput!): AwsTestConnectionResult!
  testAwsAccountExists(arn: String!): Boolean
  testAzureAccountExists(domainOrTenantdId: String!): Boolean
  testExistingAwsAccountConnection(input: TestExistingAwsAccountConnectionInput!): AwsTestConnectionResult!
  trace: Trace
  traceArchive(orderBy: TraceArchiveItemsOrderBy! = {direction: ASC, sort: RELATIVE_START_TIME}, range: TimeRangeInput, spanFilter: TraceArchiveSpanFilter, traceId: ID!): TraceArchive
  traceCacheCallSummary(after: String, before: String, context: TraceContext!, filter: TraceCacheCallSummaryFilter, first: Int, last: Int, orderBy: TraceCacheCallSummaryOrderBy! = {direction: ASC, sort: NAME}): TraceCacheCallSummaryConnection @deprecated(reason: "Use Trace.cacheCallSummary instead")
  traceCacheCalls(after: String, before: String, context: TraceContext!, filter: TraceCacheCallItemsFilter, first: Int, last: Int, orderBy: TraceCacheCallItemsOrderBy! = {direction: DESC, sort: TIME}): TraceCacheCallConnection @deprecated(reason: "Use Trace.cacheCalls instead")
  traceDatabaseQueries(after: String, before: String, context: TraceContext!, filter: TraceDatabaseQueryItemsFilter, first: Int, last: Int, orderBy: TraceDatabaseQueryItemsOrderBy! = {direction: DESC, sort: TIME}): TraceDatabaseQueryConnection @deprecated(reason: "Use Trace.databaseQueries instead")
  traceDatabaseQuerySummary(after: String, before: String, context: TraceContext!, filter: TraceDatabaseQuerySummaryFilter, first: Int, last: Int, orderBy: TraceDatabaseQuerySummaryOrderBy! = {direction: DESC, sort: TOTAL_DURATION}): TraceDatabaseQuerySummaryConnection @deprecated(reason: "Use Trace.databaseQuerySummary instead")
  traceDetails(spanId: ID, traceId: ID!): TraceDetails
  traceExceptionSummary(after: String, before: String, context: TraceContext!, filter: TraceExceptionSummaryFilter, first: Int, last: Int, orderBy: TraceExceptionSummaryOrderBy! = {direction: DESC, sort: FREQUENCY}): TraceExceptionSummaryConnection @deprecated(reason: "Use Trace.exceptionSummary instead")
  traceExceptions(after: String, before: String, context: TraceContext!, filter: TraceExceptionItemsFilter, first: Int, last: Int, orderBy: TraceExceptionItemsOrderBy! = {direction: DESC, sort: TIME}): TraceExceptionConnection @deprecated(reason: "Use Trace.exceptions instead")
  traceHistogram(context: TraceContext!, filter: TraceHistogramFilter, traceType: TraceType! = REQUESTS, verticalCellCount: Int = 30): TraceHistogram
  traceHosts(after: String, before: String, context: TraceContext!, filter: TraceHostSummaryFilter, first: Int, last: Int, orderBy: TraceHostSummaryOrderBy! = {direction: DESC, sort: COUNT}, traceType: TraceType! = REQUESTS): TraceHostSummaryConnection @deprecated(reason: "Use Trace.hosts instead")
  traceHttpMethodSummary(after: String, before: String, context: TraceContext!, filter: TraceHttpMethodSummaryFilter, first: Int, last: Int, orderBy: TraceHttpMethodSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}): TraceHttpMethodSummaryConnection @deprecated(reason: "Use Trace.httpMethodSummary instead")
  traceHttpStatusSummary(after: String, before: String, context: TraceContext!, filter: TraceHttpStatusSummaryFilter, first: Int, last: Int, orderBy: TraceHttpStatusSummaryOrderBy! = {direction: ASC, sort: CODE}): TraceHttpStatusSummaryConnection @deprecated(reason: "Use Trace.httpStatusSummary instead")
  traceProfile(endTimestamp: String!, spanId: ID!, startTimestamp: String!, traceId: ID!): TraceProfile
  traceRemoteServiceCalls(after: String, before: String, context: TraceContext!, filter: TraceRemoteServiceCallItemsFilter, first: Int, last: Int, orderBy: TraceRemoteServiceCallItemsOrderBy! = {direction: DESC, sort: TIME}): TraceRemoteServiceCallConnection @deprecated(reason: "Use Trace.remoteServiceCalls instead")
  traceRemoteServiceSummary(after: String, before: String, context: TraceContext!, filter: TraceRemoteServiceSummaryFilter, first: Int, last: Int, orderBy: TraceRemoteServiceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}): TraceRemoteServiceSummaryConnection @deprecated(reason: "Use Trace.remoteServiceSummary instead")
  traceRequests(after: String, before: String, context: TraceContext!, filter: TraceRequestItemsFilter, first: Int, last: Int, orderBy: TraceRequestItemsOrderBy! = {direction: DESC, sort: TIME}): TraceRequestConnection @deprecated(reason: "Use Trace.requests instead")
  traceServices(after: String, before: String, context: TraceContext!, filter: TraceServiceItemsFilter, first: Int, last: Int, orderBy: TraceServiceItemsOrderBy! = {direction: ASC, sort: NAME}, traceType: TraceType! = REQUESTS): TraceServiceConnection @deprecated(reason: "Use Trace.services instead")
  traceStacktraceSummary(after: String, before: String, context: TraceContext!, filter: StacktraceSummaryFilter, first: Int, last: Int, orderBy: StacktraceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}): StacktraceSummaryConnection @deprecated(reason: "Use Trace.stacktraceSummary instead")
  traceTail(after: String, before: String, context: TraceContext!, filter: TraceTailFilter, first: Int, last: Int, orderBy: TraceTailOrderBy! = {direction: DESC, sort: START_TIME}): TraceItemTailConnection @deprecated(reason: "Use Trace.tail instead")
  traceTransactions(after: String, before: String, context: TraceContext!, filter: TraceTransactionSummaryFilter, first: Int, last: Int, orderBy: TraceTransactionSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, traceType: TraceType! = REQUESTS): TraceTransactionConnection @deprecated(reason: "Use Trace.transactions instead")
  traceWebsites(after: String, before: String, context: TraceContext!, filter: TraceWebsiteSummaryFilter, first: Int, last: Int, orderBy: TraceWebsiteSummaryOrderBy! = {direction: DESC, sort: COUNT}, traceType: TraceType! = REQUESTS): TraceWebsiteSummaryConnection @deprecated(reason: "Use Trace.websites instead")
  user: AuthenticatedUser!
}

type QueryItem {
  averageTime: Float!
  count: Int!
  percentOfTraceDuration: Float
  query: String!
  queryHash: String!
  totalTime: Float!
}

# Measurements result metadata
type QueryMetadata {
  error: String
  plan: String
  planQueries: String
  query: String
  requestId: String
  warnings: [String!]
}

type RecentLogSearch {
  id: ID!
  lastSearchedAt: Timestamp!
  query: String!
}

# Result for related entities queries
type RelatedEntitiesResult {
  # Collection of entities matching given related entities filter
  entities: [Entity!]

  # Paging information. The paging is done across relationships. Entities field then contains all entities that participate in those relationships.
  pageInfo: PageInfo!

  # Collection of relationships that were traversed to get to the related entities.
  relationships: [Relationship!]

  # Total count of entities without paging.
  totalEntitiesCount: Int
}

# Container type exposing related things for entities.
type RelatedEntityFields {
  # List of related entities and/or relationships found by traversing the entities graph according to given filter.
  #
  # Depending on the used traversal `depth` value the supported behavior is slightly different:
  # * `depth <= 1` - Results can be sorted using `sortBy` argument and full paging is supported.
  # * `depth > 1` - Sorting is not supported and paging supports only `first` argument.
  entities(paging: PagingInput, sortBy: EntitySortInput, traversal: EntityGraphTraversalInput): RelatedEntitiesResult!

  # Search for events
  events(paging: PagingInput, query: EventsQueryInput): EventsResponse

  # Get entity metrics of given names. If no names are defined then all relevant metrics are returned.
  metrics(names: [String!], paging: PagingInput): [Metric!]!

  # Various statistics queries to get information about the entity based on telemetry data.
  telemetryStatistics: EntityTelemetryStatistics!
}

type RelatesTo implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!
  to: Entity!
  type: String!
  updatedTime: String
}

# Base interface for all relationships
interface Relationship {
  # Set of contexts in which this relationship was detected or used.
  # Values in the set are Entity IDs of "root" entities from distributed trace from which the
  # trace originated.
  contexts: [String!]

  # Date and time of relationship creation in UTC.
  createdTime: String

  # The relationship is directional and this is the entity from which it starts.
  from: Entity!

  # The relationship is directional and this is the entity to which it leads.
  to: Entity!

  # Should relationship type be an enum? Can enums be extended?
  type: String!

  # Date and time of last relationship update in UTC.
  updatedTime: String
}

enum RelationshipDirection {
  IN
  OUT
}

# Input type for generic relationship queries
input RelationshipFilterInput {
  # Optional filter definition. Filter supports only relationship properties, not related entities.
  filter: FilterInput

  # Contextual search query string. If used along with filter, relationships must match both filters.
  query: String

  # List of relationship types to get. If empty/missing then search is across all relationships.
  types: [String!]
}

# Type describing single relationship type
type RelationshipTypeMetadata {
  # List of all properties with metadata for this relationship type
  properties: [PropertyMetadata!]!

  # Name of the relationship type
  type: String!
}

type RequestDetails implements AnalysisDetailsBase {
  body: String
  durationInMs: Int!
  errorMessage: String
  headers: [HttpHeader!]!
}

type RequestMfaBackupCodesResponse implements MutationResponseInterface {
  code: String!
  message: String!
  mfaBackupCodes: [MfaBackupCode]!
  success: Boolean!
}

input ResetMfaInput {
  userId: String!
}

type ResourceResponse {
  grouping: String!
  label: String!
  name: String!
  visible: Boolean!
}

type ResponseDetails implements AnalysisDetailsBase {
  body: String
  durationInMs: Int!
  errorMessage: String
  headers: [HttpHeader!]!
}

type Retention {
  name: String!
  retentionPeriods: [RetentionPeriod!]!
}

type RetentionPeriod {
  resolution: Int!
  retention: Int!
}

type Role {
  name: String
}

type RolePermissions {
  permissions: [String!]!
  role: String!
}

type RouterNetworkDeviceExtension {
  # Router Name
  caption: String!
}

type RumMonitoring {
  apdexTimeInSeconds: Int
  snippet: String
  spa: Boolean
}

input RumMonitoringInput {
  apdexTimeInSeconds: Int
  spa: Boolean
}

type SamlConfiguration {
  enabled: Boolean
  groupMapping: SamlGroupMappingConfiguration
  identityProvider: SamlIdentityProvider
  serviceProvider: SamlServiceProvider
}

type SamlConfigurationResponse implements MutationResponseInterface {
  code: String!
  invalidFields: [InvalidField!]
  message: String!
  samlConfiguration: SamlConfiguration
  success: Boolean!
}

type SamlGroupMapping {
  orgRoles: [SamlRolesGroups!]
}

type SamlGroupMappingConfiguration {
  enabled: Boolean
}

input SamlGroupMappingConfigurationInput {
  enabled: Boolean
}

type SamlGroupMappingResponse implements MutationResponseInterface {
  code: String!
  message: String!
  orgRoles: [SamlRolesGroups]
  success: Boolean!
}

type SamlIdentityProvider {
  certificate: SamlIdpCertificate
  issuerURI: String
  samlURL: String
  sloURL: String
}

input SamlIdentityProviderInput {
  certificate: String!
  issuerURI: String!
  samlURL: String!
  sloURL: String!
}

type SamlIdpCertificate {
  issuer: String!
  notAfter: DateTime!
  plainText: String!
}

enum SamlOrganizationMapping {
  MAPPING
}

type SamlRole {
  groups: [String!]!
  type: String!
}

input SamlRoleInput {
  groups: [String]
  type: String!
}

input SamlRolesGroupInput {
  id: String!
  roles: [SamlRoleInput]
}

type SamlRolesGroups {
  id: String!
  roles: [SamlRole!]!
}

type SamlServiceAccountsResponse implements MutationResponseInterface {
  code: String!
  message: String!
  serviceAccounts: [String!]
  success: Boolean!
}

type SamlServiceProvider {
  acsURL: String
  audienceURI: String
  sloURL: String
}

type SavedLogSearch {
  editable: Boolean!
  hasAlerts: Boolean!
  id: ID!
  name: String!
  query: String!
}

type SavedLogSearchResponse implements MutationResponseInterface {
  code: String!
  message: String!
  savedSearch: SavedLogSearch
  success: Boolean!
}

type SavedSearch {
  context: SavedSearchContext!
  createdAt: DateTime!
  id: ID!
  isPrivate: Boolean!
  lastSearchedAt: DateTime
  name: String!
  objectId: String
  owner: SavedSearchOwner!
  query: String!
  static: Boolean!
  updatedAt: DateTime!
}

enum SavedSearchContext {
  Agents
  Alerts
  CloudIntegration
  Dashboards
  Entities
  Entity
  Events
  Filters
  Logs
  Metric
  Metrics
  Reports
  Traces
}

input SavedSearchFilter {
  context: SavedSearchContext
  isPrivate: Boolean
  objectId: String
  ownerId: ID
}

type SavedSearchOwner {
  id: ID!
  name: String!
}

type SavedSearchQueries {
  byId(id: ID!): SavedSearch
  search(input: SearchSavedSearchesInput!): SearchSavedSearchesResult!
}

input ScopeInfo {
  pluginId: String
  pluginInstanceId: String
  scope: LogsCollectionScope!
}

type SearchCategoriesResult {
  categories: [CategoryDashboards!]!
  totalCategoriesCount: Int!
}

type SearchDashboard {
  category: DashboardCategory
  createdAt: DateTime!
  description: String
  id: ID!
  isPrivate: Boolean
  name: String!
  owner: DashboardOwner
  systemReference: ID
  updatedAt: DateTime!
}

input SearchDashboardCategoriesInput {
  filter: CategoryFilter
  name: String
  pagination: PaginationInput
}

input SearchDashboardsInput {
  filter: DashboardFilter
  name: String
  pagination: PaginationInput
  sortBy: SortByInput
}

type SearchDashboardsResult {
  dashboards: [SearchDashboard!]!
  totalDashboardsCount: Int!
}

# Response type for entity graph search query
type SearchEntitiesGraphResult {
  # Collection of entities
  entities: [Entity!]

  # Paging information. The paging is done across relationships. Entities field then contains all entities that participate in those relationships.
  pageInfo: PageInfo!

  # Collection of relationships that were traversed during the search.
  relationships: [Relationship!]

  # Total count of entities without paging.
  totalEntitiesCount: Int
}

# Response type for entity search query
type SearchEntitiesResult {
  # Entity groups matching given search filter. If a `groupBy` was not not specified then there is just a single group
  # with all the matching entities in it.
  groups: [EntitiesGroup!]!

  # Paging information. Depending on the grouping setting the paging is done differently.
  #
  # If `groupBy.pagingPerGroup == false` then paging is done across all entities across all groups.
  # For example if there are enough entities in the first group the first page may not contain any other groups.
  # If the single group is large enough then it can span multiple pages.
  #
  # If `groupBy.pagingPerGroup == true` then paging is done in each group separately. Then this top-level 
  # `pageInfo` is empty and each individual group contains own `pageInfo` that can be used to page each group separately.
  pageInfo: PageInfo!

  # Total count of entities without paging.
  totalEntitiesCount: Int
}

input SearchInput {
  query: String!
  timeRange: TimeRangeInput!
}

# Response type for relationship search query
type SearchRelationshipsResult {
  # Paging information.
  pageInfo: PageInfo!

  # Collection of relationships that match given search.
  relationships: [Relationship!]

  # Total count of relationships without paging.
  totalRelationshipsCount: Int
}

input SearchSavedSearchesInput {
  filter: SavedSearchFilter
  name: String
  sortBy: SortByInput
}

type SearchSavedSearchesResult {
  savedSearches: [SavedSearch!]!
}

input SearchWidgetsInput {
  pagination: PaginationInput
}

scalar Seconds

# Service entity
type Service implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!

  # Date and time of entity creation in UTC.
  createdTime: String
  description: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # Service error count
  errors: Metric!

  # List of entity extensions that are currently set on given entity
  extensions: [String!]
  healthScore: HealthScore

  # Relation: Service to Host
  hosts: [Host!]

  # Unique identifier of an entity
  id: ID!

  # Language
  language: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Relation: Service to Service
  relatedServices: [Service!]

  # Relation: Service to Website
  relatedWebsites: [Website!]

  # Service request count
  requests: Metric!

  # Service average response time
  responseTime: Metric!

  # Aggregated value of responseTime for filtering purposes
  responseTimeValue: Float!

  # Count of sampled requests
  sampleCount: Metric!
  tags: String
  technology: String

  # Count of traces generated from requests
  traceCount: Metric!

  # Trace service error ratio
  traceServiceErrorRatio: Metric!

  # Aggregated value of traceServiceErrorRatio for filtering purposes
  traceServiceErrorRatioValue: Float!

  # Trace service reqest rate
  traceServiceRequestRate: Metric!

  # Aggregated value of traceServiceRequestRate for filtering purposes
  traceServiceRequestRateValue: Float!

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
}

type SessionTimeout {
  # number of seconds until session is expired
  timeout: Int
}

type SessionTimeoutResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!

  # number of seconds until session is expired
  timeout: Int
}

input SetDatabaseCredentialsRequest {
  credentials: [KeyValue!]
  databaseInstanceID: String!
}

type SetDatabaseCredentialsResponse {
  code: String!
  message: String
}

union SetEntityDisplayNameResult = EntityMutationError | SetEntityDisplayNameSuccess

type SetEntityDisplayNameSuccess {
  # New entity display name
  displayName: String

  # Updated entity ID
  id: ID!
}

type SimpleNetflowMetrics {
  bytes: Float!
  metricKey: String!
}

type SlackAuthorizeUrlResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
  url: String!
}

input SortByInput {
  direction: SortDirection!
  key: String!
}

# Sort direction for query result sorting.
enum SortDirection {
  ASC
  DESC
}

# Query sort definition. Sort support multiple properties and two sort directions.
input SortInput {
  sorts: [SortItemInput!]!
}

# Single property sort definition.
input SortItemInput {
  direction: SortDirection
  propertyName: String!
}

type SpanSummary {
  action: String
  controller: String
  duration: String!
  errorCount: Int!
  host: String
  hostEntity: String
  hostEntityName: String
  id: ID!
  method: String
  service: String!
  serviceEntity: String
  startTime: String!
  status: String
  transaction: String
  websiteEntity: String
  websiteEntityName: String
}

type SslCertificate {
  certificate: String!
  name: String!
  validTo: String!
}

type SslCertificates implements Validation {
  certificates: SslCertificatesByStatus
  minTimeValid: Int!
  status: ValidationStatus!
  type: ValidationType!
}

type SslCertificatesByStatus {
  expired: [SslCertificate!]!
  expiring: [SslCertificate!]!
  valid: [SslCertificate!]!
}

type SslMonitoring {
  daysPriorToExpiration: Int
  enabled: Boolean
}

input SslMonitoringInput {
  daysPriorToExpiration: Int
  enabled: Boolean
}

type StacktraceSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  classMessageBacktraceHash: String!
  count: String!
  exceptionClass: String!
  exceptionClassMessageHash: String!
  exceptionMessage: String!
  frequency: TraceFrequency!
  id: ID!
  lastOccurred: String!
  lastTraceId: String!
  lastTraceSpanId: String!
  name: String
  stacktrace: String!
  totalDuration: TraceDuration!
  transaction: String!
}

type StacktraceSummaryConnection {
  edges: [StacktraceSummaryEdge!]
  pageInfo: PageInfo!
}

type StacktraceSummaryEdge {
  cursor: String!
  node: StacktraceSummary!
}

input StacktraceSummaryFilter {
  exceptionClass: String
  exceptionClassMessageBacktraceHash: String
  exceptionClassMessageHash: String
  id: String
  transaction: String
}

input StacktraceSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: StacktraceSummarySort! = AVERAGE_DURATION
}

enum StacktraceSummarySort {
  AVERAGE_DURATION
  COUNT
  FREQUENCY
  NAME
  TOTAL_DURATION
}

# State of entity
type State {
  # State of the entity as it is reported (as opposed to normalizedState which will be added later)
  nativeState: String
}

# The base interface for entities with state
interface StatefulEntity {
  id: ID!

  # State of entity
  state: State
}

# The group will contain only the entities listed here.
type StaticEntityGroupDefinition {
  staticMemberIds: [ID!]!
}

# String representation of the value.
type StringKeyValuePair implements EventKeyValuePair {
  key: String!
  value: String! @deprecated(reason: "Only for backwards compatibility, will be removed in favor of typed values (valueString)")
  valueString: String!
}

interface SwicusUser {
  email: String!
  emailVerified: Boolean!
  firstName: String
  id: ID!
  lastLogin: DateTime
  lastName: String
}

type SwitchNetworkDeviceExtension {
  # Switch name
  name: String
}

# Tag key and value used when grouping measurement streams
type Tag {
  key: String!
  value: String!
}

# A tree data structure describing one or more key-value pair filters
input TagFilter {
  args: [String!]
  children: [TagFilter!]
  op: FilterOperation!
}

# A key-value pair
type TagPair {
  key: String!
  value: String!
}

# Input type for a key-value pair
input TagPairInput {
  key: String!
  value: String!
}

enum TailingEdge {
  Bottom
  Top
}

# Enum defining how the telemetry mapping condition should be evaluated.
enum TelemetryMappingConditionEvaluationMethod {
  # Condition means that telemetry should contain given key. This is the default.
  CONTAINS

  # Condition means that telemetry should NOT contain given key.
  DOESNT_CONTAIN
}

# Condition used to match an entity type to a telemetry attributes.
input TelemetryMappingConditionInput {
  # Property defining how the telemetry mapping condition should be evaluated.
  evaluationMethod: TelemetryMappingConditionEvaluationMethod = CONTAINS

  # Key of telemetry resource attribute to check.
  key: String!

  # Allowed values of given telemetry resource attribute. Multiple values are used in OR relation.
  # Example: my.key=["value1", "value2"] => my.key="value1" OR my.key="value2".
  # If the values are empty then the condition is evaluated as "if there is a resource attribute with this key then it's a match".
  values: [String!]
}

type Tenant {
  status: TenantStatus!
  statusEnd: Timestamp!
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
  TRIAL
}

input TestAwsAccountConnectionInput {
  arn: String!
  externalId: String!
}

input TestExistingAwsAccountConnectionInput {
  arn: String!
  entityId: String!
}

input TestNotificationServiceConfigurationInput {
  description: String
  id: String
  settings: JSON
  template: JSON
  type: String!
}

type TestNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

# Thin Access Point
type ThinAccessPoint implements Entity & WirelessAccessPoint {
  # Relation: Network Device (WirelessController) to Thin Access Point
  controller: NetworkDevice

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Relation: Wireless Interfaces of Access Point
  interfaces: [WirelessInterface]

  # Access Point IP Address
  ipAddress: String

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Universal Resource Identifier of Access Point within Orion
  uri: String!
}

# Set the bounds for a time-series query
input TimeFilter {
  endTime: String

  # For metrics, interval shall be floored to the minimum interval for the window width
  # Non-zero, positive intervals will result in the window being aligned with the interval
  # An interval of 0 indicates that the entire window should be aggregated to a single data point
  interval: Int
  startTime: String!
}

input TimeRangeInput {
  endTime: String
  startTime: String
}

type TimeSeriesSample {
  time: Timestamp!
  value: Float!
}

type TimeSeriesSampleMs {
  time: TimestampMs!
  value: Float!
}

scalar Timestamp

scalar TimestampMs

input ToggleLogFilterInput {
  enabled: Boolean!
  filterId: ID!
}

type Token {
  # The access level of the Token. Available access levels must be one of read, record, or full.
  accessLevel: TokenAccessLevel

  # The date of when the Token was created.
  createdAt: DateTime

  # The SWICUS user that did create this token.
  createdBy: String

  # The SWICUS user name that did create this token.
  createdByName: String

  # The enabled state of the Token.
  enabled: Boolean

  # The ID of the Token. Known internally to Swoken as "signature".
  id: ID!

  # The name of the Token. Generated from user input.
  name: String

  # The obfuscated token of the Token.
  obfuscatedToken: String

  # The Organization ID of the Token.
  orgId: String

  # The secure state of the Token. Secure tokens are only revealed to the user once at creation and cannot be unobfuscated.
  secure: Boolean

  # The plain-text token of the Token.
  token: String

  # The type of the Token. Internal field in Swoken to support multiple types of tokens, e.g. admin, azure_integration, etc.
  type: String

  # The date of when the Token was last updated.
  updatedAt: DateTime

  # The date of when the Token was last used.
  usedAt: DateTime
}

enum TokenAccessLevel {
  FULL
  READ
  RECORD
}

enum TopNetflowMetric {
  TopAdvancedApplications
  TopApplications
  TopCountries
  TopEndpoints
  TopProtocols
}

enum TopTimeSeriesMetric {
  TopAdvancedApplications
  TopApplications
  TopEndpoints
}

# The topology connection relation type used in topology data processing in the Topology service.
# Represents a connection on L2 layer of the OSI model.
type TopologyConnectionL2 implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!

  # Array of interface ids of the 'from' connection.
  fromInterfaceIdArray: [String]
  to: Entity!

  # Array of interface ids of the 'to' connection.
  toInterfaceIdArray: [String]
  type: String!

  # UAMS Client IDs of topology data sources.
  # Topology data sources are Network collector UAMS client plugins.
  uamsClients: [String!]!
  updatedTime: String
}

# The topology connection relation type used in topology data processing in the Topology service.
# Represents a connection on L3 layer of the OSI model.
type TopologyConnectionL3 implements Relationship {
  contexts: [String!]
  createdTime: String
  from: Entity!

  # Array of interface ids of the 'from' connection.
  fromInterfaceIdArray: [String]
  to: Entity!

  # Array of interface ids of the 'to' connection.
  toInterfaceIdArray: [String]
  type: String!

  # UAMS Client IDs of topology data sources.
  # Topology data sources are Network collector UAMS client plugins.
  uamsClients: [String!]!
  updatedTime: String
}

type Trace {
  cacheCallSummary(context: TraceQueryContext!, filter: TraceCacheCallSummaryFilter, orderBy: TraceCacheCallSummaryOrderBy! = {direction: ASC, sort: NAME}, paging: PagingInput, search: SearchInput!): TraceCacheCallSummaryConnection
  cacheCalls(context: TraceQueryContext!, filter: TraceCacheCallItemsFilter, orderBy: TraceCacheCallItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput, search: SearchInput!): TraceCacheCallConnection
  databaseQueries(context: TraceQueryContext!, filter: TraceDatabaseQueryItemsFilter, orderBy: TraceDatabaseQueryItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput, search: SearchInput!): TraceDatabaseQueryConnection
  databaseQuerySummary(context: TraceQueryContext!, filter: TraceDatabaseQuerySummaryFilter, orderBy: TraceDatabaseQuerySummaryOrderBy! = {direction: DESC, sort: TOTAL_DURATION}, paging: PagingInput, search: SearchInput!): TraceDatabaseQuerySummaryConnection
  exceptionSummary(context: TraceQueryContext!, filter: TraceExceptionSummaryFilter, orderBy: TraceExceptionSummaryOrderBy! = {direction: DESC, sort: FREQUENCY}, paging: PagingInput, search: SearchInput!): TraceExceptionSummaryConnection
  exceptions(context: TraceQueryContext!, filter: TraceExceptionItemsFilter, orderBy: TraceExceptionItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput, search: SearchInput!): TraceExceptionConnection
  histogram(context: TraceQueryContext!, filter: TraceHistogramFilter, search: SearchInput!, traceType: TraceType! = REQUESTS, verticalCellCount: Int = 30): TraceHistogram
  hosts(context: TraceQueryContext!, filter: TraceHostSummaryFilter, orderBy: TraceHostSummaryOrderBy! = {direction: DESC, sort: COUNT}, paging: PagingInput, search: SearchInput!, traceType: TraceType! = REQUESTS): TraceHostSummaryConnection
  httpMethodSummary(context: TraceQueryContext!, filter: TraceHttpMethodSummaryFilter, orderBy: TraceHttpMethodSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput, search: SearchInput!): TraceHttpMethodSummaryConnection
  httpStatusSummary(context: TraceQueryContext!, filter: TraceHttpStatusSummaryFilter, orderBy: TraceHttpStatusSummaryOrderBy! = {direction: ASC, sort: CODE}, paging: PagingInput, search: SearchInput!): TraceHttpStatusSummaryConnection
  noop: String
  remoteServiceCalls(context: TraceQueryContext!, filter: TraceRemoteServiceCallItemsFilter, orderBy: TraceRemoteServiceCallItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput, search: SearchInput!): TraceRemoteServiceCallConnection
  remoteServiceSummary(context: TraceQueryContext!, filter: TraceRemoteServiceSummaryFilter, orderBy: TraceRemoteServiceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput, search: SearchInput!): TraceRemoteServiceSummaryConnection
  requests(context: TraceQueryContext!, filter: TraceRequestItemsFilter, orderBy: TraceRequestItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput, search: SearchInput!): TraceRequestConnection
  services(context: TraceQueryContext!, filter: TraceServiceItemsFilter, orderBy: TraceServiceItemsOrderBy! = {direction: ASC, sort: NAME}, paging: PagingInput, search: SearchInput!, traceType: TraceType! = REQUESTS): TraceServiceConnection
  stacktraceSummary(context: TraceQueryContext!, filter: StacktraceSummaryFilter, orderBy: StacktraceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput, search: SearchInput!): StacktraceSummaryConnection
  tail(context: TraceQueryContext!, filter: TraceTailFilter, orderBy: TraceTailOrderBy! = {direction: DESC, sort: START_TIME}, paging: PagingInput, search: SearchInput!): TraceItemTailConnection
  transactions(context: TraceQueryContext!, filter: TraceTransactionSummaryFilter, orderBy: TraceTransactionSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput, search: SearchInput!, traceType: TraceType! = REQUESTS): TraceTransactionConnection
  websites(context: TraceQueryContext!, filter: TraceWebsiteSummaryFilter, orderBy: TraceWebsiteSummaryOrderBy! = {direction: DESC, sort: COUNT}, paging: PagingInput, search: SearchInput!, traceType: TraceType! = REQUESTS): TraceWebsiteSummaryConnection
}

type TraceArchive {
  bucketCapacity: Int
  bucketRate: Float
  endTime: String
  eventSummary: TraceArchiveEventSummary
  layerCounts: TraceArchiveLayerCounts
  profilingSupported: Boolean
  sampleRate: Float
  sampleSource: Int
  service: String
  startTime: String
  traceId: ID!
  traceSpans(after: String, before: String, first: Int, last: Int): TraceSpanConnection
  transaction: String
}

type TraceArchiveEventSummary {
  eventSummaryItems: [TraceArchiveEventSummaryItem]!
}

type TraceArchiveEventSummaryItem {
  eventId: String!
  label: String
  layer: String
  service: String
  spanId: String
}

input TraceArchiveItemsOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceArchiveItemsSort! = RELATIVE_START_TIME
}

enum TraceArchiveItemsSort {
  DURATION
  LABEL
  RELATIVE_START_TIME
}

type TraceArchiveLayerCounts {
  layerCountItems: [TraceArchiveLayerCountsItem]!
}

type TraceArchiveLayerCountsItem {
  entry: Int!
  error: Int!
  exit: Int!
  info: Int!
  layer: String!
}

input TraceArchiveSpanFilter {
  exceptionClassMessageHash: String
  id: String
  label: String
  queryHash: String
}

type TraceBreakdownItem {
  duration: Float!
  errorCount: Int!
  layer: String!
  percentOfTraceDuration: Float
  spanCount: Int!
}

enum TraceBreakdownItemsSort {
  DURATION
  ERROR_COUNT
  LAYER
  PERCENT_OF_TRACE_DURATION
  SPAN_COUNT
}

input TraceBreakdownOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceBreakdownItemsSort! = LAYER
}

type TraceCacheCall implements TraceSpanItem {
  cache: String!
  cacheHost: String!
  cacheOp: String!
  duration: TraceDuration!
  hostEntityId: String
  hostEntityName: String
  hostname: String
  id: ID!
  service: String!
  serviceEntityId: String!
  spanDuration: TraceDuration!
  spanId: String
  time: String!
  traceDuration: TraceDuration!
  traceId: String!
  transaction: String
  websiteEntityName: String
  websiteId: String
}

type TraceCacheCallConnection {
  edges: [TraceCacheCallEdge!]
  pageInfo: PageInfo!
}

type TraceCacheCallEdge {
  cursor: String!
  node: TraceCacheCall!
}

input TraceCacheCallItemsFilter {
  cacheHosts: [String!]
  cacheOps: [String!]
  caches: [String!]
  maxResponseTime: Int
  minResponseTime: Int
  transactions: [String!]
}

input TraceCacheCallItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceCacheCallItemsSort! = TIME
}

enum TraceCacheCallItemsSort {
  DURATION
  SPAN_DURATION
  TIME
  TRACE_DURATION
}

type TraceCacheCallSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  cacheHost: String
  cacheOp: String
  count: String!
  frequency: TraceFrequency!
  id: ID!
  name: String
  relativeCountPercentage: String!
  totalDuration: TraceDuration!
}

type TraceCacheCallSummaryConnection {
  edges: [TraceCacheCallSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceCacheCallSummaryEdge {
  cursor: String!
  node: TraceCacheCallSummary!
}

input TraceCacheCallSummaryFilter {
  cacheHosts: [String!]
  cacheOps: [String!]
  caches: [String!]
  searchText: String
  transactions: [String!]
}

input TraceCacheCallSummaryOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceCacheCallSummarySort! = NAME
}

enum TraceCacheCallSummarySort {
  AVERAGE_DURATION
  CACHE_HOST
  CACHE_OP
  COUNT
  FREQUENCY
  NAME
  RELATIVE_COUNT_PERCENTAGE
  TOTAL_DURATION
}

type TraceClientCacheSpan implements TraceSpan {
  cacheEntityId: String
  cacheHit: Boolean
  cacheHostEntityId: String
  cacheHostname: String
  cacheKey: String
  cacheName: String
  cacheOperation: String
  cacheVendor: String
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceClientHttpRequestSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  peerDomain: String
  peerDomainEntityId: String
  peerHostEntityId: String
  peerHostname: String
  peerService: String
  peerServiceEntityId: String
  relativeStartTime: Int!
  requestAction: String
  requestController: String
  requestMethod: String
  requestOperation: String
  requestProtocol: String
  requestUri: String
  responseCode: String!
  responseMessage: String
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceClientProtocolRequestSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  peerDomain: String
  peerDomainEntityId: String
  peerHostEntityId: String
  peerHostname: String
  peerService: String
  peerServiceEntityId: String
  relativeStartTime: Int!
  requestAction: String
  requestController: String
  requestOperation: String
  requestProtocol: String
  requestUri: String
  responseCode: String!
  responseMessage: String
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceClientQuerySpan implements TraceSpan {
  cpuDuration: TraceDuration
  databaseCallConsistency: String
  databaseClusterId: String
  databaseClusterName: String
  databaseColumnSet: String
  databaseConnectionPool: String
  databaseEntityId: String
  databaseHostEntityId: String
  databaseHostname: String
  databaseKeyspace: String
  databaseName: String
  databaseOperation: String
  databasePartition: String
  databaseQuery: String
  databaseQueryArguments: String
  databaseQueryHash: String
  databaseTable: String
  databaseVendor: String
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceConsumerSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  queueCoordinationGroup: String
  queueEntityId: String
  queueHost: String
  queueHostEntityId: String
  queueItemIdentifier: String
  queueItemPartition: String
  queueItemTransaction: String
  queueName: String
  queuePort: Int
  queueVendor: String!
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

input TraceContext {
  hostEntityIds: [String!]
  range: TimeRangeInput!
  serviceEntityIds: [String!]
  serviceNames: [String!]
  websiteIds: [String!]
}

type TraceDatabaseQuery implements TraceSpanItem {
  database: String!
  databaseEntityId: String
  databaseHostEntityId: String
  databaseHostname: String!
  duration: TraceDuration!
  hostEntityId: String
  hostEntityName: String
  hostname: String
  id: ID!
  queryOp: String!
  queryTable: String!
  service: String!
  serviceEntityId: String!
  spanDuration: TraceDuration!
  spanId: String
  time: String!
  traceDuration: TraceDuration!
  traceId: String!
  transaction: String
  websiteEntityName: String
  websiteId: String
}

type TraceDatabaseQueryConnection {
  edges: [TraceDatabaseQueryEdge!]
  pageInfo: PageInfo!
}

type TraceDatabaseQueryEdge {
  cursor: String!
  node: TraceDatabaseQuery!
}

input TraceDatabaseQueryItemsFilter {
  databaseHosts: [String!]
  databases: [String!]
  maxResponseTime: Int
  minResponseTime: Int
  queryOps: [String!]
  queryTables: [String!]
  transactions: [String!]
}

input TraceDatabaseQueryItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceDatabaseQueryItemsSort! = DURATION
}

enum TraceDatabaseQueryItemsSort {
  DURATION
  SPAN_DURATION
  TIME
  TRACE_DURATION
}

type TraceDatabaseQuerySummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  count: String!
  databaseHost: String
  frequency: TraceFrequency!
  id: ID!
  name: String
  queryOp: String
  queryTable: String
  relativeCountPercentage: String!
  totalDuration: TraceDuration!
}

type TraceDatabaseQuerySummaryConnection {
  edges: [TraceDatabaseQuerySummaryEdge!]
  pageInfo: PageInfo!
}

type TraceDatabaseQuerySummaryEdge {
  cursor: String!
  node: TraceDatabaseQuerySummary!
}

input TraceDatabaseQuerySummaryFilter {
  databaseHosts: [String!]
  databases: [String!]
  queryOps: [String!]
  queryTables: [String!]
  searchText: String
  transactions: [String!]
}

input TraceDatabaseQuerySummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceDatabaseQuerySummarySort! = TOTAL_DURATION
}

enum TraceDatabaseQuerySummarySort {
  AVERAGE_DURATION
  COUNT
  DATABASE_HOST
  FREQUENCY
  NAME
  QUERY_OPERATION
  QUERY_TABLE
  RELATIVE_COUNT_PERCENTAGE
  TOTAL_DURATION
}

type TraceDetails {
  action: String
  allErrors(orderBy: TraceErrorOrderBy! = {direction: ASC, sort: LAYER}): [ErrorItem!]
  allQueries(orderBy: TraceQueryOrderBy! = {direction: ASC, sort: QUERY}): [QueryItem!]
  controller: String
  duration: String!
  originSpan: SpanSummary!
  selectedSpan: SpanSummary
  spanCount: Int!
  time: String!
  traceBreakdown(orderBy: TraceBreakdownOrderBy! = {direction: ASC, sort: LAYER}): [TraceBreakdownItem!]
  traceId: ID!
  transaction: String!
  waterfall: [WaterfallRow!]!
}

type TraceDuration {
  units: TraceTimeScale!
  value: String!
}

type TraceError {
  backtrace: String
  exceptionClassMessageHash: String
  message: String
  timestamp: String
  type: String
}

enum TraceErrorItemsSort {
  HOSTNAME
  LAYER
  MESSAGE
  TIME
}

input TraceErrorOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceErrorItemsSort! = LAYER
}

type TraceEvent {
  eventId: ID!
  properties: [TracePair!]
}

type TraceEventConnection {
  edges: [TraceEventEdge!]
  pageInfo: PageInfo!
}

type TraceEventEdge {
  cursor: String!
  node: TraceEvent
}

type TraceException implements TraceSpanItem {
  duration: TraceDuration!
  eventId: String!
  exceptionClass: String!
  exceptionClassMessageHash: String!
  exceptionMessage: String!
  hostEntityId: String
  hostEntityName: String
  hostname: String
  httpMethod: String!
  httpStatus: String!
  id: ID!
  service: String!
  serviceEntityId: String!
  spanId: String
  time: String!
  traceId: String!
  transaction: String
  websiteEntityName: String
  websiteId: String
}

type TraceExceptionConnection {
  edges: [TraceExceptionEdge!]
  pageInfo: PageInfo!
}

type TraceExceptionEdge {
  cursor: String!
  node: TraceException!
}

input TraceExceptionItemsFilter {
  exceptionClassMessageHashes: [String!]
  exceptionClasses: [String!]
  maxDurationTime: Int
  minDurationTime: Int
  transactions: [String!]
}

input TraceExceptionItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceExceptionItemsSort! = DURATION
}

enum TraceExceptionItemsSort {
  DURATION
  EXCEPTION_CLASS
  EXCEPTION_MESSAGE
  HTTP_METHOD
  HTTP_STATUS
  TIME
  TRANSACTION
}

type TraceExceptionSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  count: String!
  exceptionClass: String!
  exceptionClassMessageHash: String!
  exceptionMessage: String!
  firstOccurred: String
  frequency: TraceFrequency!
  id: ID!
  lastOccurred: String
  lastTraceId: String
  lastTraceSpanId: String
  name: String
  relativeCountPercentage: String!
  totalDuration: TraceDuration!
  transactions: [String!]
}

type TraceExceptionSummaryConnection {
  edges: [TraceExceptionSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceExceptionSummaryEdge {
  cursor: String!
  node: TraceExceptionSummary!
}

input TraceExceptionSummaryFilter {
  exceptionClassMessageHash: String
  exceptionClasses: [String!]
  id: String
  searchText: String
  transactions: [String!]
}

input TraceExceptionSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceExceptionSummarySort! = FREQUENCY
}

enum TraceExceptionSummarySort {
  AVERAGE_DURATION
  COUNT
  EXCEPTION_CLASS
  EXCEPTION_MESSAGE
  FIRST_OCCURRED
  FREQUENCY
  LAST_OCCURRED
  NAME
  RELATIVE_COUNT_PERCENTAGE
  TOTAL_DURATION
}

enum TraceFileOperation {
  CLOSE
  COMPOUND
  DELETE
  OPEN
  READ
  READ_METADATA
  WRITE
  WRITE_METADATA
}

enum TraceFileType {
  DIRECTORY
  FILE
  HARDLINK
  NAMED_PIPE
  SHARED_MEMORY
  SOCKET
  SYMLINK
}

type TraceFrequency {
  units: TraceTimeScale!
  value: Float!
}

type TraceHistogram {
  maxCount: Int!
  maxDuration: Int!
  series: [TraceHistogramColumn!]!
}

type TraceHistogramColumn {
  histogram: [TraceHistogramEntry!]!
  timestamp: String!
  timestampEnd: String!
}

type TraceHistogramEntry {
  count: Int!
  duration: Int!
  durationUpperBound: Int!
}

input TraceHistogramFilter {
  cacheHosts: [String!]
  cacheOps: [String!]
  caches: [String!]
  databaseHosts: [String!]
  databases: [String!]
  exceptionClassMessageHashes: [String!]
  httpMethod: String
  httpStatus: String
  queryOps: [String!]
  queryTables: [String!]
  remoteServiceOps: [String!]
  remoteServiceTypes: [String!]
  remoteServices: [String!]
  transactions: [String!]
}

type TraceHost {
  count: String!
  hostEntityId: String!
  hostEntityName: String!
}

type TraceHostSummaryConnection {
  edges: [TraceHostSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceHostSummaryEdge {
  cursor: String!
  node: TraceHost!
}

input TraceHostSummaryFilter {
  transactions: [String!]
}

input TraceHostSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceHostSummarySort! = COUNT
}

enum TraceHostSummarySort {
  COUNT
}

type TraceHttpMethodSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  count: String!
  frequency: TraceFrequency!
  id: ID!
  name: String
  totalDuration: TraceDuration!
}

type TraceHttpMethodSummaryConnection {
  edges: [TraceHttpMethodSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceHttpMethodSummaryEdge {
  cursor: String!
  node: TraceHttpMethodSummary!
}

input TraceHttpMethodSummaryFilter {
  name: String
}

input TraceHttpMethodSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceHttpMethodSummarySort! = AVERAGE_DURATION
}

enum TraceHttpMethodSummarySort {
  AVERAGE_DURATION
  COUNT
  FREQUENCY
  NAME
  TOTAL_DURATION
}

type TraceHttpStatusSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  code: Int
  codeWithText: String
  count: String!
  frequency: TraceFrequency!
  id: ID!
  name: String
  text: String
  totalDuration: TraceDuration!
}

type TraceHttpStatusSummaryConnection {
  edges: [TraceHttpStatusSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceHttpStatusSummaryEdge {
  cursor: String!
  node: TraceHttpStatusSummary!
}

input TraceHttpStatusSummaryFilter {
  code: String
}

input TraceHttpStatusSummaryOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceHttpStatusSummarySort! = CODE
}

enum TraceHttpStatusSummarySort {
  AVERAGE_DURATION
  CODE
  COUNT
  FREQUENCY
  NAME
  TOTAL_DURATION
}

type TraceIOSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  ioDevice: String
  ioFileName: String!
  ioFileType: TraceFileType!
  ioOperation: TraceFileOperation!
  ioPath: String!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceInternalSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceItemTailConnection {
  edges: [TraceItemTailEdge!]
  pageInfo: PageInfo!
}

type TraceItemTailEdge {
  cursor: String!
  node: TraceRecord!
}

type TracePair {
  key: String
  value: String
}

type TraceProducerSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  queueEntityId: String
  queueHost: String
  queueHostEntityId: String
  queueItemIdentifier: String
  queueItemPartition: String
  queueItemTransaction: String
  queueName: String
  queuePort: Int
  queueVendor: String!
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceProfile {
  entries: [ProfileEntry!]!
}

type TraceProfileSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  profileStacks: [[TraceProfileStackEntry!]!]
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceProfileStackEntry {
  encapsulation: String
  file: String
  function: String
  lineNumber: Int
}

input TraceQueryContext {
  hostEntityIds: [String!]
  serviceEntityIds: [String!]
  serviceNames: [String!]
  websiteIds: [String!]
}

enum TraceQueryItemsSort {
  AVERAGE_TIME
  COUNT
  QUERY
  TOTAL_TIME
}

input TraceQueryOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceQueryItemsSort! = QUERY
}

type TraceRecord {
  duration: TraceDuration!
  id: ID!
  time: String!
  traceId: String!
  transaction: String
}

type TraceRemoteServiceCall implements TraceSpanItem {
  duration: TraceDuration!
  hostEntityId: String
  hostEntityName: String
  hostname: String
  id: ID!
  remoteService: String!
  remoteServiceOp: String!
  remoteServiceType: String!
  service: String!
  serviceEntityId: String!
  spanDuration: TraceDuration!
  spanId: String
  time: String!
  traceDuration: TraceDuration!
  traceId: String!
  transaction: String
  websiteEntityName: String
  websiteId: String
}

type TraceRemoteServiceCallConnection {
  edges: [TraceRemoteServiceCallEdge!]
  pageInfo: PageInfo!
}

type TraceRemoteServiceCallEdge {
  cursor: String!
  node: TraceRemoteServiceCall!
}

input TraceRemoteServiceCallItemsFilter {
  maxResponseTime: Int
  minResponseTime: Int
  remoteServiceOps: [String!]
  remoteServiceTypes: [String!]
  remoteServices: [String!]
  transactions: [String!]
}

input TraceRemoteServiceCallItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceRemoteServiceCallItemsSort! = DURATION
}

enum TraceRemoteServiceCallItemsSort {
  DURATION
  SPAN_DURATION
  TIME
  TRACE_DURATION
}

type TraceRemoteServiceSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  count: String!
  frequency: TraceFrequency!
  id: ID!
  name: String
  relativeCountPercentage: String!
  remoteServiceOp: String
  remoteServiceType: String
  totalDuration: TraceDuration!
}

type TraceRemoteServiceSummaryConnection {
  edges: [TraceRemoteServiceSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceRemoteServiceSummaryEdge {
  cursor: String!
  node: TraceRemoteServiceSummary!
}

input TraceRemoteServiceSummaryFilter {
  remoteServiceOps: [String!]
  remoteServiceTypes: [String!]
  remoteServices: [String!]
  searchText: String
  transactions: [String!]
}

input TraceRemoteServiceSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceRemoteServiceSummarySort! = AVERAGE_DURATION
}

enum TraceRemoteServiceSummarySort {
  AVERAGE_DURATION
  COUNT
  FREQUENCY
  NAME
  RELATIVE_COUNT_PERCENTAGE
  REMOTE_SERVICE_OP
  REMOTE_SERVICE_TYPE
  TOTAL_DURATION
}

type TraceRequest implements TraceSpanItem {
  duration: TraceDuration!
  hostEntityId: String
  hostEntityName: String
  hostname: String
  httpMethod: String
  httpStatus: String
  id: ID!
  service: String!
  serviceEntityId: String!
  serviceUrlDomain: String
  serviceUrlPath: String
  spanId: String
  time: String!
  traceId: String!
  traceUrlDomain: String
  traceUrlPath: String
  transaction: String
  websiteEntityName: String
  websiteId: String
}

type TraceRequestConnection {
  edges: [TraceRequestEdge!]
  pageInfo: PageInfo!
}

type TraceRequestEdge {
  cursor: String!
  node: TraceRequest!
}

input TraceRequestItemsFilter {
  exceptionClassMessageHash: String
  host: String
  httpStatus: String
  id: String
  maxResponseTime: Int
  minResponseTime: Int
  serviceUrlDomain: String
  serviceUrlPath: String
  traceUrPath: String
  traceUrlDomain: String
  transactions: [String!]
}

input TraceRequestItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceRequestItemsSort! = TIME
}

enum TraceRequestItemsSort {
  DURATION
  HTTP_STATUS
  TIME
}

type TraceServerHttpSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  requestAction: String
  requestCommand: String
  requestController: String
  requestMethod: String
  requestOriginalUri: String
  requestProtocol: String
  requestTraceMetadata: [TracePair!]
  requestUrl: String
  requestUrlPath: String
  requestUrlQueryString: String
  responseCode: String!
  responseMessage: String
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceServerProtocolSpan implements TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  requestAction: String
  requestCommand: String
  requestController: String
  requestHostname: String
  requestMethod: String
  requestOriginalUri: String
  requestProtocol: String
  requestTraceMetadata: [TracePair!]
  requestUrl: String
  requestUrlPath: String
  requestUrlQueryString: String
  responseCode: String!
  responseMessage: String
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceService {
  count: String!
  id: ID!
  lastSeen: String
  name: String!
}

type TraceServiceConnection {
  edges: [TraceServiceEdge!]
  pageInfo: PageInfo!
}

type TraceServiceEdge {
  cursor: String!
  node: TraceService!
}

input TraceServiceItemsFilter {
  name: String
  nameStartsWith: String
}

input TraceServiceItemsOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceServiceItemsSort! = NAME
}

enum TraceServiceItemsSort {
  COUNT
  LAST_SEEN
  NAME
}

enum TraceSortDirection {
  ASC
  DESC
}

interface TraceSpan {
  cpuDuration: TraceDuration
  duration: TraceDuration!
  durationPercent: Float
  end: String!
  errorPropagated: Boolean!
  errorRaised: Boolean!
  errors: [TraceError!]!
  events: [TraceEvent!]!
  hostEntityId: String!
  hostname: String!
  id: ID!
  label: String!
  language: String
  parentSpanId: String
  relativeStartTime: Int!
  selfDurationPercent: Float!
  selfDurationTime: Int!
  service: String!
  serviceEntityId: String!
  spanId: String!
  spanType: String!
  start: String!
  traceId: String!
  transaction: String
}

type TraceSpanConnection {
  edges: [TraceSpanEdge!]
  pageInfo: PageInfo!
}

type TraceSpanEdge {
  cursor: String!
  node: TraceSpan!
}

interface TraceSpanItem {
  duration: TraceDuration!
  hostEntityId: String
  hostname: String
  id: ID!
  service: String!
  serviceEntityId: String!
  spanId: String
  time: String!
  traceId: String!
  transaction: String
  websiteId: String
}

interface TraceSpanSummary {
  averageDuration: TraceDuration!
  count: String!
  frequency: TraceFrequency!
  id: ID!
  name: String
  totalDuration: TraceDuration!
}

input TraceTailFilter {
  transaction: String
}

input TraceTailOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceTailSort! = START_TIME
}

enum TraceTailSort {
  END_TIME
  START_TIME
}

enum TraceTimeScale {
  DAYS
  HOURS
  MICROSECONDS
  MILLISECONDS
  MINUTES
  MONTHS
  NANOSECONDS
  SECONDS
  YEARS
}

type TraceTransactionConnection {
  edges: [TraceTransactionSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceTransactionSummary implements TraceSpanSummary {
  averageDuration: TraceDuration!
  count: String!
  frequency: TraceFrequency!
  id: ID!
  name: String
  totalDuration: TraceDuration!
}

type TraceTransactionSummaryEdge {
  cursor: String!
  node: TraceTransactionSummary!
}

input TraceTransactionSummaryFilter {
  id: String
  name: String
}

input TraceTransactionSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceTransactionSummarySort! = AVERAGE_DURATION
}

enum TraceTransactionSummarySort {
  AVERAGE_DURATION
  COUNT
  FREQUENCY
  NAME
  TOTAL_DURATION
}

enum TraceType {
  CACHE_CALLS
  EXCEPTIONS
  QUERIES
  REMOTE_CALLS
  REQUESTS
}

type TraceWebsite {
  count: String!
  websiteEntityId: String!
  websiteEntityName: String!
}

type TraceWebsiteSummaryConnection {
  edges: [TraceWebsiteSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceWebsiteSummaryEdge {
  cursor: String!
  node: TraceWebsite!
}

input TraceWebsiteSummaryFilter {
  transactions: [String!]
}

input TraceWebsiteSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceWebsiteSummarySort! = COUNT
}

enum TraceWebsiteSummarySort {
  COUNT
}

enum TrafficFilter {
  All
  EastWest
  NorthSouth
  NotClassified
}

type TrustedDevice {
  countryName: String
  deviceId: String
  ipAddress: String
  lastUsedAt: DateTime
  userAgent: String
  userId: String
}

# UAMS entity extension for Host
type UAMSHostExtension {
  # Average CPU Load over 1 minute
  cpuLoadAverage1m: Metric!

  # Average CPU Load over 5 minutes
  cpuLoadAverage5m: Metric!

  # Average CPU Load over 15 minutes
  cpuLoadAverage15m: Metric!

  # Total CPU seconds broken down by different states
  cpuTime: Metric!

  # Percentage of CPU time broken down by different states
  cpuUtilization: Metric!

  # Disk bytes transferred
  diskIo: Metric!

  # Time disk spent activated. On Windows, this is calculated as the inverse of disk idle time.
  diskIoTime: Metric!

  # Disk operations count
  diskOperations: Metric!

  # Time spent in disk operations
  diskOperationsTime: Metric!

  # The queue size of pending I/O operations
  diskPendingOperations: Metric!

  # Filesystem bytes used
  filesystemUsage: Metric!

  # Host Id
  hostId: String

  # Bytes of memory in use
  memoryUsage: Metric!

  # Percentage of memory bytes in use
  memoryUtilization: Metric!

  # Entity name
  name: String!

  # The number of connections
  networkConnections: Metric!

  # The number of packets dropped
  networkDropped: Metric!

  # The number of errors encountered
  networkErrors: Metric!

  # The number of bytes transmitted and received
  networkIo: Metric!

  # The number of packets transferred
  networkPackets: Metric!

  # Os type
  osType: String

  # The number of paging operations
  pagingOperations: Metric!

  # Swap (unix) or pagefile (windows) usage
  pagingUsage: Metric!

  # UAMS client Id
  uamsClientId: String!
}

type UamsClient {
  architecture: String
  autoUpdateEnabled: Boolean
  cloudInstanceId: String
  cloudInstanceZone: String
  cloudProvider: String
  containerId: String
  deploymentStatus: DeploymentStatus
  environmentInfo: String
  hostName: String
  id: ID!
  installedPlugins: [PluginInfo]
  isConnected: Boolean
  lastErrorMessage: String
  lastSeenOffset: Seconds
  lastSeenUtc: DateTime
  listOfMacAddresses: [String]
  logCollectionStatus: UamsClientLogCollectionStatus
  orgId: String
  osVersion: String
  registeredOnUtc: DateTime
  roles: [Role]
  serialNumber: String
  version: String
}

enum UamsClientLogCollectionStatus {
  NONE
  PENDING
  READY
  TIMED_OUT
}

input UnobserveDatabaseRequest {
  databaseInstanceID: String!
}

type UnobserveDatabaseResponse {
  code: String!
  message: String
}

input UpdateAwsCloudAccountConfigurationInput {
  arn: String
  enabled: Boolean
  metricsTag: String
  regions: [String!]
  services: [String!]
}

input UpdateAwsCloudAccountInput {
  configuration: UpdateAwsCloudAccountConfigurationInput
  displayName: String
  entityId: String!
  sessionId: Guid
}

type UpdateAwsCloudAccountResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

input UpdateAzureCloudAccountConfigurationInput {
  enabled: Boolean
  metricsTag: String
  subscriptions: [AzureSubscriptionInput!]
}

input UpdateAzureCloudAccountInput {
  configuration: UpdateAzureCloudAccountConfigurationInput
  displayName: String
  entityId: String!
}

type UpdateAzureCloudAccountResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

input UpdateAzureIntegrationInput {
  credential: AzureCredentialInput
  displayName: String
  enabled: Boolean
  entityId: String!
  metricsTag: String
  subscription: AzureSubscriptionInput
}

type UpdateAzureIntegrationResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
}

input UpdateCategoryInput {
  id: ID!
  name: String!
}

type UpdateCategoryResponse {
  category: DashboardCategory
  code: String!
  message: String!
  success: Boolean!
}

input UpdateDashboardInput {
  categoryId: ID
  description: String
  id: ID!
  isPrivate: Boolean
  layout: [LayoutInput!]!
  name: String!
  widgets: [WidgetInput!]!
}

type UpdateDashboardResponse {
  code: String!
  dashboard: Dashboard
  message: String!
  success: Boolean!
}

input UpdateDatabaseRequest {
  bindings: [String!]
  credentials: [KeyValue!]
  databaseInstanceID: String!
  description: String
  name: String
  options: [KeyValue!]
}

type UpdateDatabaseResponse {
  code: String!
  message: String
}

union UpdateEntityGroupResult = EntityGroupMutationError | UpdateEntityGroupSuccess

type UpdateEntityGroupSuccess {
  # Updated entity group
  entityGroup: EntityGroup!
}

input UpdateExclusionFilterExpressionInput {
  expression: String!
  kind: ExclusionFilterExpressionKind!
}

input UpdateExclusionFilterInput {
  description: String!
  enabled: Boolean!
  expressions: [UpdateExclusionFilterExpressionInput!]!
  id: ID!
  name: String!
}

input UpdateLogArchiveProviderStatusInput {
  isEnabled: Boolean!
  provider: LogArchiveProvider!
}

type UpdateLogArchiveProviderStatusResponse implements LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  message: String!
  success: Boolean!
}

input UpdateLogFilterInput {
  description: String
  expressions: [LogFilterExpressionInput!]!
  global: Boolean!
  groupIds: [ID!]!
  id: ID!
  name: String!
}

type UpdateLogFilterResponse implements MutationResponseInterface {
  code: String!
  logFilter: LogFilter
  message: String!
  success: Boolean!
}

input UpdateLogGroupInput {
  description: String
  httpHosts: [String!]
  id: ID!
  name: String!
  syslogApps: [String!]
  syslogHosts: [String!]
  tags: [String!]
}

input UpdateLogSearchInput {
  id: ID!
  query: String!
}

type UpdateMemberRolesResponse implements MutationResponseInterface {
  code: String!
  member: OrganizationMember
  message: String!
  success: Boolean!
}

input UpdateMfaSettingsInput {
  enabled: Boolean!
  lifespan: Int
  logoutUsers: Boolean
}

input UpdateNotificationServiceConfigurationInput {
  description: String
  id: ID!
  settings: JSON
  title: String
}

type UpdateNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  configuration: NotificationService
  message: String!
  success: Boolean!
}

type UpdateOrganizationAttributesResponse implements MutationResponseInterface {
  code: String!
  invalidFields: [InvalidField!]
  message: String!
  organization: Organization
  success: Boolean!
}

input UpdateSamlConfigurationInput {
  enabled: Boolean
  groupMapping: SamlGroupMappingConfigurationInput
  identityProvider: SamlIdentityProviderInput
}

input UpdateSamlGroupMappingInput {
  orgRoles: [SamlRolesGroupInput]
}

input UpdateSamlServiceAccountsInput {
  serviceAccounts: [String!]!
}

input UpdateSavedSearchInput {
  id: ID!
  isPrivate: Boolean
  name: String
  objectId: String
  query: String
  updateLastSearchAt: Boolean!
}

type UpdateSavedSearchResponse {
  code: String!
  message: String!
  savedSearch: SavedSearch
  success: Boolean!
}

input UpdateSessionTimeoutInput {
  # number of seconds until session is expired
  timeout: Int!
}

input UpdateTokenInput {
  accessLevel: TokenAccessLevel
  enabled: Boolean
  id: ID!
  name: String
  type: String
}

type UpdateTokenResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
  token: Token
}

input UpdateUserAttributeInput {
  id: String!
  value: String!
}

type UpdateUserAttributeResponse implements MutationResponseInterface {
  code: String!
  message: String!
  success: Boolean!
  userAttribute: UserAttribute
}

type UpdateUserAttributesResponse implements MutationResponseInterface {
  code: String!
  invalidFields: [InvalidField!]
  message: String!
  success: Boolean!
  user: User
}

type UpdateUserEmailResponse implements MutationResponseInterface {
  code: String!
  invalidField: String
  message: String!
  success: Boolean!
  user: User
}

type UpdateUserPasswordResponse implements MutationResponseInterface {
  code: String!
  invalidField: String
  message: String!
  success: Boolean!
}

input UpdateUserTrustedDeviceInput {
  deviceId: String!
  userId: String!
}

input UpdateWebsiteInput {
  availability: AvailabilityMonitoringInput!
  customHeaders: [CustomHeaderInput!]
  id: ID!
  name: String!
  options: MonitoringOptionsInput!
  rum: RumMonitoringInput
  url: String!
}

union UpdateWebsiteResult = UpdateWebsiteSuccess | WebsiteInputValidationError

type UpdateWebsiteSuccess {
  website: Website!
}

type User implements SwicusUser {
  email: String!
  emailVerified: Boolean!
  firstName: String
  id: ID!
  lastLogin: DateTime
  lastName: String
  timezone: String
}

union UserAttribute = AttributeBool | AttributeFloat | AttributeInt | AttributeJson | AttributeString

input UserAttributesInput {
  firstName: String
  lastName: String
  timezone: String
}

input UserEmailInput {
  email: String!
  password: String!
}

input UserPasswordInput {
  currentPassword: String!
  newPassword: String!
}

interface Validation {
  status: ValidationStatus!
  type: ValidationType!
}

# Error that occurred during validation.
type ValidationResult {
  # Value of the property that caused the error
  invalidValue: String

  # Validation message
  message: String!

  # Name of property that caused the error
  propertyName: String
}

enum ValidationStatus {
  FAILURE
  SKIPPED
  SUCCESS
  WARNING
}

enum ValidationType {
  CERTIFICATES
  CONTAINS_STRING
  NOT_CONTAINS_STRING
}

enum Visibility {
  Collapse
  Hide
  Show
}

type VisibilitySettings {
  program: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  severity: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  source: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  time: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
}

enum VolumetricsField {
  CATEGORY
  ENTITY_TYPE
  LOG_TYPE
  NAMESPACE
  TAG
}

input VolumetricsFilterBy {
  kind: VolumetricsField!
  value: String!
}

enum VolumetricsMeasurementType {
  COUNT
  LATENCY_MILLIS
  VOLUME_BYTES
}

type VolumetricsResponse {
  results: [VolumetricsResult!]!
  totalResults: Int!
}

type VolumetricsResult {
  categories: [String!]
  entityTypes: [String!]
  logTypes: [String!]
  name: String!
  namespace: String
  summary: TimeSeriesSample!
  timeseries: [TimeSeriesSample!]!
}

input VolumetricsSummaryInput {
  category: String!
  endTimestamp: Timestamp!
  filterBy: [VolumetricsFilterBy!]!
  groupBy: [VolumetricsField!]!
  groupIds: [ID!]
  limit: Int
  measurementType: VolumetricsMeasurementType!
  startTimestamp: Timestamp!
}

type VolumetricsSummaryResponse {
  results: [VolumetricsSummaryResult!]!
}

type VolumetricsSummaryResult {
  categories: [String!]
  entityTypes: [String!]
  logTypes: [String!]
  name: String!
  namespace: String
  summary: TimeSeriesSample!
}

input VolumetricsTimeseriesInput {
  category: String!
  endTimestamp: Timestamp!
  filterBy: [VolumetricsFilterBy!]!
  groupBy: [VolumetricsField!]!
  groupIds: [ID!]
  limit: Int
  measurementType: VolumetricsMeasurementType!
  startTimestamp: Timestamp!
  zeroFill: Boolean
}

type VolumetricsTimeseriesResponse {
  results: [VolumetricsTimeseriesResult!]!
}

type VolumetricsTimeseriesResult {
  categories: [String!]
  entityTypes: [String!]
  logTypes: [String!]
  name: String!
  namespace: String
  timeseries: [TimeSeriesSample!]!
}

input VolumetricsTotalInput {
  endTimestamp: Timestamp!
  groupBy: VolumetricsField!
  startTimestamp: Timestamp!
}

type VolumetricsTotalResponse {
  totalResults: Int!
}

type WaterfallErrorItem {
  exceptionClassMessageHash: String
  message: String!
  spanId: ID!
  timestamp: String!
}

type WaterfallItem {
  async: Boolean!
  endTime: String!
  error: [WaterfallErrorItem!]!
  layer: String!
  service: String!
  spanId: ID!
  startTime: String!
}

type WaterfallRow {
  items: [WaterfallItem!]
  parentId: ID
}

# Website entity
type Website implements AlertingEntity & Entity & HealthEntity {
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
  availabilityTestAnalysis: AvailabilityTestAnalysisQueries
  availabilityTestValidations: AvailabilityTestValidationsQueries

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Collection of website features e.g. [Synthetic, RUM]
  features: [String!]
  healthScore: HealthScore
  httpResponseTime: Metric!
  httpsResponseTime: Metric!

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")
  mockPerformanceTests: MockPerformanceTestMetric
  monitoring: WebsiteMonitoring

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Relation: Website to Service
  services: [Service!]
  synthetics: WebsiteSynthetics

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String
  url: String!
}

type WebsiteInputValidationError {
  nameExists: Boolean
}

type WebsiteMonitoring {
  availability: AvailabilityMonitoring
  customHeaders: [CustomHeader!]
  options: MonitoringOptions
  rum: RumMonitoring
}

enum WebsiteProtocol {
  HTTP
  HTTPS
}

# Aggregated metrics for Website availability
type WebsiteSynthetics {
  # Aggregated count of performed availability tests
  attempts: Int!

  # Aggregated percentage of successful availability tests
  availability: Float!

  # Aggregated average value of httpResponseTime for filtering purposes
  avgHttpResponseTime: Float!

  # Aggregated average value of httpsResponseTime for filtering purposes
  avgHttpsResponseTime: Float!

  # Aggregated percentage of failed availability tests
  errorRate: Float!

  # Aggregated count of failed availability tests
  errors: Int!

  # Aggregated percentage of successful availability tests
  successRate: Float!

  # Aggregated count of successful availability tests
  successes: Int!
}

type Widget {
  id: ID!
  properties: JSON
  title: String
  type: String!
}

input WidgetInput {
  id: ID!
  properties: JSON
  title: String
  type: String!
}

type WidgetQueries {
  search(inputs: SearchWidgetsInput!): [Widget!]!
}

# Base interface for Access Point entities
interface WirelessAccessPoint {
  # Relation: Wireless Interfaces of Access Point
  interfaces: [WirelessInterface]

  # IP address
  ipAddress: String

  # Universal Resource Identifier of Access Point within Orion. Serves as a natural key.
  uri: String!
}

# Thin Access Point
type WirelessClient implements Entity {
  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Relation: Parent Wireless Interface where the client is connected to
  interface: WirelessInterface

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Universal Resource Identifier of Wireless Client within Orion
  uri: String!
}

type WirelessControllerNetworkDeviceExtension {
  # Relation: Thin Access Points managed by this controller
  thinAccessPoints: [ThinAccessPoint]

  # Number of thin access points
  thinAccessPointsCount: Int
}

# Thin Access Point
type WirelessInterface implements Entity {
  # Wireless channel
  channel: Int

  # Relation: Clients connected to interface
  clients: [WirelessClient]

  # Date and time of entity creation in UTC.
  createdTime: String

  # Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  displayName: String
  edges(edgeType: String): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges2(inDepth: Int, inEdgeTypes: [String!], outDepth: Int, outEdgeTypes: [String!], types: [String!]): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")
  edges3(edgeFilter: EdgeFilter): [Entity!] @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.entities' field instead.")

  # List of entity extensions that are currently set on given entity
  extensions: [String!]

  # Unique identifier of an entity
  id: ID!

  # Date and time when the entity has last received telemetry in UTC.
  lastSeenTime: String

  # Physical address
  mac: String

  # Other properties required by Entity Interface
  metric(name: String!): Metric @deprecated(reason: "Old field from Oct-15 demo PoC. Use 'related.metrics' field instead.")

  # Entity name
  name: String

  # Radio type (802.11g, ...)
  radioType: String

  # Set of fields to get to things related to a given entity
  related: RelatedEntityFields

  # Wireless network name
  ssid: String

  # Entity type.
  type: String!

  # Date and time of last entity update in UTC.
  updatedTime: String

  # Universal Resource Identifier of Wireless Interface within Orion
  uri: String!
}

input createNotificationServiceConfigurationInput {
  description: String
  settings: JSON!
  title: String!
  type: String!
}

type navigationItemsPermission {
  allowed: Boolean!
  permission: NavigationItems!
}