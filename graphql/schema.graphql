input AcknowledgementTargetInput {
  triggerId: String!
  userId: String
}

input ActiveAlertsFilterInput {
  """List of entity IDs"""
  entityIds: [String!]

  """List of entity types"""
  entityTypes: [String!]

  """List of parent Alert definition severities"""
  severities: [AlertSeverity!]

  """List of parent Alert definition IDs"""
  definitionIds: [String!]

  """Activity within time range in minutes"""
  activeTimeRangeInMinutes: AlertIntRangeInput

  """Mute status"""
  muted: Boolean

  """String used to search in Alert definition name or Entity display name"""
  searchString: String

  """List of condition types"""
  conditionTypes: [ConditionType!]

  """Alert acknowledgement status"""
  acknowledgementStatus: AlertAcknowledgementStatusFilterInput

  """Alert filter expression"""
  filter: AlertFilterExpressionInput
}

"""Add new NetPath endpoint input."""
input AddNetPathEndpointInput {
  """Hostname or IP address of endpoint."""
  hostnameOrAddress: String!

  """Port of endpoint."""
  port: Int

  """Polling/probing interval."""
  pollInterval: Int

  """Entity ID"""
  entityId: ID

  """UAMS client ID."""
  uamsClientId: String!
}

"""Add new NetPath endpoint response."""
type AddNetPathEndpointResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
}

"""Input used to define dynamic filters on allowed properties"""
input AdvancedNetflowFilter {
  """
  List of nested filters which will be evaluated together based on the current operation
  """
  nestedFilters: [AdvancedNetflowFilter!]

  """
  Operation used to evaluate current property, or the list of nested filters
  """
  operation: String!

  """
  Contains property on which the result should be filtered based on operation
  """
  property: String

  """Expected value of the property"""
  propertyValue: String
}

type AgentInstallAlternativeMethod {
  linkAddress: String
  command: String
  packageManager: AgentInstallPackageManager
}

type AgentInstallationSession {
  uamsClientId: String
  installationStatus: AgentInstallationStatus!
}

enum AgentInstallationStatus {
  UNKNOWN
  REQUESTED
  CLIENT_INSTALLED
  ERROR
}

type AgentInstallInstruction {
  script: String
  sessionId: ID!
  alternativeMethods: [AgentInstallAlternativeMethod!]
  instrumentedMethod: AgentInstallInstrumentedMethod
}

type AgentInstallInstrumentedMethod {
  token: String
  swoUrl: String
  metadata: String
  ansibleLink: String
  chefLink: String
}

enum AgentInstallPackageManager {
  UNSPECIFIED
  DPKG
  DNF
  RPM
  YUM
  ZYPPER
}

"""Alert acknowledgement status possibilities for filtering"""
enum AlertAcknowledgementStatus {
  ACKNOWLEDGED
  ACKNOWLEDGED_BY_MYSELF
  NOT_ACKNOWLEDGED
}

input AlertAcknowledgementStatusFilterInput {
  """Alert acknowledgement status"""
  acknowledgementStatus: [AlertAcknowledgementStatus!]

  """Acknowledged by user IDs"""
  acknowledgedByUserIds: [String!]
}

type AlertAction {
  """Type of a notification service"""
  type: String!

  """List of notification configuration IDs"""
  configurationIds: [ID!]!
}

type AlertActionDeletedByCnsEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
  cnsConfigurationId: String!
  cnsConfigurationType: String!
}

input AlertActionInput {
  """Type of a notification service"""
  type: String!

  """List of notification configuration IDs"""
  configurationIds: [ID!]!
}

"""
Defines what is the data source the condition is evaluated against (metrics, logs, ...).
"""
enum AlertConditionDataSource {
  METRIC
  LOG
  EVENT
  UNKNOWN
}

"""
Defines additional narrowing down of the data source (e.g. `events` could be further limited to `anomaly-events`).
"""
enum AlertConditionDataType {
  ANOMALY
}

interface AlertConditionEvaluationFlat {
  """Alert definition ID"""
  alertDefinitionId: String!

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

interface AlertConditionEvaluationV2 {
  """Alert definition related to this evaluation"""
  alertDefinition: AlertDefinition

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityEvaluationData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

type AlertConditionMatchFieldRule {
  """Field name to apply filtering rule on"""
  fieldName: String!

  """Rules to apply - multiple rules are joined by OR"""
  rules: [AlertConditionMatchRule!]!
}

input AlertConditionMatchFieldRuleInput {
  """Field name to apply filtering rule on"""
  fieldName: String!

  """Rules to apply - multiple rules are joined by `OR`"""
  rules: [AlertConditionMatchRuleInput!]!
}

type AlertConditionMatchRule {
  type: AlertConditionMatchRuleType!

  """Negate match (wraps in NOT)"""
  negate: Boolean!

  """Value match match"""
  value: String!
}

input AlertConditionMatchRuleInput {
  type: AlertConditionMatchRuleType!

  """Negate match (wraps in `NOT`)"""
  negate: Boolean! = false

  """Value match match"""
  value: String!
}

"""Alert definition condition matching rule types"""
enum AlertConditionMatchRuleType {
  EQ
  NE
  CONTAINS
  MATCHES
}

type AlertConditionMetadata {
  scopes: [AlertConditionScope!]!
  dataSource: AlertConditionDataSource!
  dataTypes: [AlertConditionDataType!]
}

"""
See [docs](https://github.com/solarwindscloud/nighthawk-alerting/blob/develop/docs/how-to-build-condition.md) on how to work with condition nodes.
"""
type AlertConditionNode {
  """Condition node ID."""
  id: Int!

  """
  Node (operator) type. Supported values:
  - `aggregationOperator` (child of `binaryOperator`)
  - `binaryOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  - `constantValue` (root, or child of `aggregationOperator`, `binaryOperator`)
  - `logicalOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  - `metricField` (child of `binaryOperator`, `aggregationOperator`)
  - `queryField` (child of `aggregationOperator`)
  - `unaryOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  """
  type: String!

  """
  Operator for combining operands. Supported values:
  - For aggregationOperator: `COUNT`, `MIN`, `MAX`, `AVG`, `SUM`, `LAST`
  - For binaryOperator: `=`, `!=`, `>`, `<`, `>=`, `<=`
  - For logicalOperator: `AND`, `OR`
  - For unaryOperator: `!`
  """
  operator: String

  """Ordered list of child condition node IDs."""
  operandIds: [Int!]

  """Entity filter for `metricField` nodes"""
  entityFilter: AlertConditionNodeEntityFilter

  """Entity metric field for `metricField` nodes"""
  fieldName: String

  """Measurement filter for tags on metrics"""
  metricFilter: [FlatAlertFilterExpression]

  """
  Data type for `constantValue` nodes. Supported values: `boolean`, `number`, `string`
  """
  dataType: String

  """String representation of value for `constantValue` nodes."""
  value: String

  """Source specification for `queryField` nodes."""
  source: String @deprecated(reason: "Field is deprecated, `source` is now defined by `namespace`.")

  """Query specification for `queryField` nodes."""
  query: String

  """Events/logs namespace (in Chainsaw) for `queryField` nodes."""
  namespace: String
}

type AlertConditionNodeEntityFilter {
  """Entity types"""
  types: [String!]

  """Entity IDs"""
  ids: [ID!]

  """Contextual (smart) search query"""
  query: String

  """List of alert condition field rules"""
  fields: [AlertConditionMatchFieldRule!]
}

input AlertConditionNodeEntityFilterInput {
  """**DEPRECATED:** Use the `types` field instead"""
  type: String!

  """Filter by Entity types"""
  types: [String!]

  """Filter by Entity IDs"""
  ids: [ID!]

  """Contextual (smart) search query"""
  query: String

  """Filter by Entity fields - multiple fields are joined by `AND`"""
  fields: [AlertConditionMatchFieldRuleInput!]
}

"""
See [docs](https://github.com/solarwindscloud/nighthawk-alerting/blob/develop/docs/how-to-build-condition.md) on how to work with condition nodes.
"""
input AlertConditionNodeInput {
  """Condition node ID."""
  id: Int!

  """
  Node (operator) type. Supported values:
  - `aggregationOperator` (child of `binaryOperator`)
  - `binaryOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  - `constantValue` (root, or child of `aggregationOperator`, `binaryOperator`)
  - `logicalOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  - `metricField` (child of `binaryOperator`, `aggregationOperator`)
  - `queryField` (child of `aggregationOperator`)
  - `unaryOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  """
  type: String!

  """
  Operator for combining operands. Supported values:
  - For aggregationOperator: `COUNT`, `MIN`, `MAX`, `AVG`, `SUM`, `LAST`
  - For binaryOperator: `=`, `!=`, `>`, `<`, `>=`, `<=`
  - For logicalOperator: `AND`, `OR`
  - For unaryOperator: `!`
  """
  operator: String

  """Ordered list of child condition nodes IDs."""
  operandIds: [Int!]

  """
  Entity filter for `metricField` and `queryField` nodes. When defined (not null), node is scoped to entity.
  """
  entityFilter: AlertConditionNodeEntityFilterInput

  """Measurement filter for metric tags"""
  metricFilter: AlertFilterExpressionInput

  """Entity metric field for `metricField` nodes"""
  fieldName: String

  """
  Data type for `constantValue` nodes. Supported values: `boolean`, `number`, `string`
  """
  dataType: String

  """String representation of value for `constantValue` nodes."""
  value: String

  """
  *DEPRECATED:* Field is deprecated, `source` is now defined by `namespace`.
  Source specification for `queryField` nodes.
  """
  source: String

  """Query specification for `queryField` nodes."""
  query: String

  """Events/logs namespace (in Chainsaw) for `queryField` nodes."""
  namespace: String
}

"""
Defines what is the alert condition scoped to. Some combinations are allowed, such as `[ENTITY, TAG]`.
"""
enum AlertConditionScope {
  ENTITY
  TAG
  WHOLE_SYSTEM
}

"""Alert definition condition evaluation states"""
enum AlertConditionState {
  FIRING
  OK
}

type AlertDefinition {
  """Alert definition ID in UUID format"""
  id: ID!

  """Organization ID"""
  organizationId: ID!

  """User ID"""
  userId: ID!

  """Alert definition name"""
  name: String!

  """Alert definition description"""
  description: String

  """Alert definition severity"""
  severity: AlertSeverity!

  """Enabled whether Alert definition shall be evaluated"""
  enabled: Boolean!

  """Information about any pending mutes on the Alert definition"""
  muteInfo: AlertDefinitionMuteInfo!

  """Indication whether alert is triggered"""
  triggered: Boolean!

  """
  Ordered list of condition nodes representing the flatten condition tree.
  The first item is the tree root.
  """
  flatCondition: [FlatAlertConditionExpression!]!

  """Alert definition condition type"""
  conditionType: ConditionType! @deprecated(reason: "Field is deprecated, `conditionType` should be derived from `conditionMetadata`.")

  """
  Provides key properties of alert condition in easy to access format.
  Such metadata is useful for filtering as well as many parts of internal application logic.
  """
  conditionMetadata: AlertConditionMetadata

  """The time stamp that identifies when the condition was updated."""
  conditionUpdatedAt: String!

  """
  A flag indicating whether to send a notification when active alert returns to normal.
  """
  triggerResetActions: Boolean!

  """List of alert actions that shall be triggered in case of alert FIRING"""
  actions: [AlertAction!]!

  """List of alert evaluations"""
  conditionEvaluations: [AlertConditionEvaluationV2!]!

  """List of targeted Entity types"""
  targetEntityTypes: [String!]

  """
  Time when the Alert definition was triggered in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  triggeredTime: String
}

input AlertDefinitionBulkInput {
  """Enabled whether given Alert definitions shall be evaluated"""
  enabled: Boolean
}

type AlertDefinitionCreatedEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
  configuration: AlertDefinitionEventData!
}

type AlertDefinitionDeletedEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
}

type AlertDefinitionDisabledEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
}

type AlertDefinitionEnabledEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
}

type AlertDefinitionEventData {
  """Alert definition name"""
  name: String!

  """Alert definition description"""
  description: String

  """Alert definition severity"""
  severity: AlertSeverity!

  """
  Ordered list of condition nodes representing the flatten condition tree.
  The first item is the tree root.
  """
  flatCondition: [FlatAlertConditionExpression!]!

  """
  List of alert actions that shall be triggered in case of alert **FIRING**
  """
  actions: [AlertAction!]!

  """List of targeted Entity types"""
  targetEntityTypes: [String!]
}

input AlertDefinitionInput {
  """Alert definition name"""
  name: String!

  """Alert definition description"""
  description: String

  """Alert definition severity"""
  severity: AlertSeverity!

  """Enabled whether Alert definition shall be evaluated"""
  enabled: Boolean!

  """
  Ordered list of condition nodes representing the flatten condition tree.
  The first item is the tree root.
  """
  condition: [AlertConditionNodeInput!]!

  """
  List of alert actions that shall be triggered in case of alert **FIRING**
  """
  actions: [AlertActionInput!]

  """
  A flag indicating whether to send a notification when active alert returns to normal.
  It will be set to *false* if not specified.
  """
  triggerResetActions: Boolean
}

type AlertDefinitionManualResetEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
}

type AlertDefinitionMutedEvent implements AlertManagementEvent & AlertEntityTrait {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
  expiresAt: String!
  entity: AlertEntityData!
}

"""
Alert definitions can be muted for certain period of time or muted until resolved.

If the muted is set to *true* and until attribute is not set meaning no notification will be sent until
all of the evaluations are set to **OK** state or alert definition is reset
"""
type AlertDefinitionMuteInfo {
  """When muted no notifications are sent"""
  muted: Boolean!

  """
  Time until the mute expires in ISO-8601 date format - `2011-12-03T10:15:30Z` or `null` - muted until resolved
  """
  until: String
}

input AlertDefinitionPatchInput {
  """Alert definition ID"""
  id: String!

  """Alert definition name"""
  name: String

  """Alert definition description"""
  description: String

  """Alert definition severity"""
  severity: AlertSeverity

  """Enabled whether Alert definition shall be evaluated"""
  enabled: Boolean

  """
  Ordered list of condition nodes representing the flatten condition tree.
  The first item is the tree root.
  """
  condition: [AlertConditionNodeInput!]

  """List of Alert Actions that shall be triggered in case of alert FIRING"""
  actions: [AlertActionInput!]

  """
  A flag indicating whether to send a notification when active alert returns to normal.
  It will be set to *false* if not specified.
  """
  triggerResetActions: Boolean
}

type AlertDefinitionsResult {
  """List of Alert definitions"""
  alertDefinitions: [AlertDefinition!]!

  """Cursor-based paging metadata"""
  pageInfo: PageInfo!

  """Number of records in data list"""
  totalRecords: Int
}

"""Alert definition statistics categories"""
enum AlertDefinitionStatisticsCategory {
  CONDITION_TYPE
  ENABLED
  ENTITY_TYPE
  SEVERITY
  TRIGGERED
}

type AlertDefinitionUnmutedEvent implements AlertManagementEvent & AlertEntityTrait {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String
  entity: AlertEntityData!
}

type AlertDefinitionUpdatedEvent implements AlertManagementEvent {
  eventId: String!
  timestamp: String!
  alertDefinitionId: String!
  alertDefinitionName: String
  userId: String!
  originalConfiguration: AlertDefinitionEventData!
  newConfiguration: AlertDefinitionEventData!
}

type AlertEntitiesFilter {
  """
  List of Entity types to get. If empty/missing then search is across all Entities.
  """
  type: String!
}

input AlertEntitiesFilterInput {
  """
  List of Entity types to get. If empty/missing then search is across all Entities.
  """
  type: String!
}

type AlertEntityData {
  """Entity ID"""
  id: ID!

  """Entity name"""
  name: String

  """Displayed name"""
  displayName: String

  """Type of Entity"""
  type: String

  """HealthScore"""
  healthScore: Int
}

type AlertEntityEvaluationData {
  """Entity ID"""
  entityId: ID!

  """Evaluation condition state"""
  currentState: AlertConditionState!
}

interface AlertEntityTrait {
  entity: AlertEntityData!
}

input AlertEvaluationFilterInput {
  """By active"""
  active: Boolean

  """By mute status"""
  muted: Boolean

  """By list of entity IDs"""
  entityIds: [String!]

  """By list of entity types"""
  entityTypes: [String!]

  """By list of parent Alert definition severities"""
  severities: [AlertSeverity!]

  """By alert acknowledgement status"""
  acknowledgementStatus: AlertAcknowledgementStatusFilterInput
}

"""
"
If the muted detail is listed and until attribute is not set meaning no notification will be sent until
all of the evaluations are set to **OK** state or alert definition is reset
"""
type AlertEvaluationMuteDetail {
  """
  Time until the mute expires in ISO-8601 date format - `2011-12-03T10:15:30Z` or `null` - muted until resolved
  """
  until: String

  """Type of the mute origin"""
  reason: AlertEvaluationMuteReason!
}

type AlertEvaluationMuteInfo {
  """When muted no notifications are sent"""
  muted: Boolean!

  """List of mute details"""
  details: [AlertEvaluationMuteDetail]
}

"""Evaluation mute reasons"""
enum AlertEvaluationMuteReason {
  ALERT_DEFINITION
  ENTITY
  ENTITY_PER_ALERT_DEFINITION
}

input AlertEvaluationsFilterInput {
  """By list of Entity IDs"""
  entityIds: [String!]

  """By alert status"""
  state: AlertConditionState

  """By last triggered filter"""
  lastTriggered: LastTriggeredFilterInput

  """By mute status"""
  muted: Boolean

  """By string in Alert definition name or Entity display name"""
  searchString: String

  """By list of condition types"""
  conditionTypes: [ConditionType!]

  """Alert acknowledgement status"""
  acknowledgementStatus: AlertAcknowledgementStatusFilterInput
}

type AlertEvaluationsResult {
  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  conditionEvaluations: [AlertConditionEvaluationFlat!]!

  """Cursor-based paging metadata"""
  pageInfo: PageInfo!

  """Number of records in data list"""
  totalRecords: Int
}

"""Alert evaluation statistics categories"""
enum AlertEvaluationStatisticsCategory {
  ACKNOWLEDGEMENT_STATUS
  ACTIVE
  ENTITY_TYPE
  MUTED
  SEVERITY
}

"""
Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
"""
type AlertEvaluationTarget {
  """ID of target entity"""
  entityId: String

  """Metric tag(s) in name:value format"""
  tags: [AlertKeyValueStringPair!]
}

type AlertEventConditionEvaluation implements AlertConditionEvaluationV2 {
  """Alert definition"""
  alertDefinition: AlertDefinition

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """Evaluated condition containing values"""
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityEvaluationData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

type AlertEventConditionEvaluationFlat implements AlertConditionEvaluationFlat {
  """Alert definition ID"""
  alertDefinitionId: String!

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

type AlertFilterExpression {
  """Name of the property to filter on."""
  propertyName: String

  """
  Value of the property for operations that expect single value such as EQ, NE, GT, ...
  """
  propertyValue: String

  """
  Values of the property for operations expecting multiple values, such as IN.
  """
  propertyValues: [String]

  """
  Operation to use for the evaluation. Default: "EQ"
  """
  operation: FilterOperation!
}

"""Input type for filtering"""
input AlertFilterExpressionInput {
  """Name of the property to filter on."""
  propertyName: String

  """
  Value of the property for operations that expect single value such as EQ, NE, GT, ...
  """
  propertyValue: String

  """
  Values of the property for operations expecting multiple values, such as IN.
  """
  propertyValues: [String]

  """
  Operation to use for the evaluation. Default: "EQ"
  """
  operation: FilterOperation! = EQ

  """
  Children filters in case of "operator" being one of "OR", "AND", "NOT".
  In such case the "propertyName" and "propertyValue" are ignored.
  """
  children: [AlertFilterExpressionInput!]
}

input AlertFilterInput {
  """By Alert definition ID"""
  id: ID

  """By user ID"""
  userId: ID

  """By Alert definition name"""
  name: String

  """By list of Alert definition severities"""
  severities: [AlertSeverity!]

  """By Alert definition enablement"""
  enabled: Boolean

  """By trigger status"""
  triggered: Boolean

  """By list of Entity IDs"""
  entities: [String!]

  """By list of Entity types"""
  entityTypes: [String!]

  """By alert filter expression"""
  filter: AlertFilterExpressionInput

  """By action configuration ID"""
  actionConfigurationId: ID

  """By list of condition types"""
  conditionTypes: [ConditionType!]

  """By swi-query expression"""
  query: String
}

"""
This is temporary workaround for bug in currently used version of
Apollo GraphQL Federated Gateway (probably https://github.com/apollographql/federation/issues/336).
"""
interface AlertingEntity {
  """Unique identifier of the Entity."""
  id: ID!

  """
  Evaluations of the Entity in individual Alert definitions. Details of each Alert definition can be fetched through
  the nested type.
  """
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

input AlertIntRangeInput {
  """Integer value from how many minutes ago to look for."""
  from: Int!

  """
  Integer value from how many minutes ago end the search in. If not defined it looks up till now.
  """
  to: Int
}

"""Simple string key-value pair structure"""
type AlertKeyValueStringPair {
  key: String!
  value: String!
}

type AlertLogConditionEvaluation implements AlertConditionEvaluationV2 {
  """Alert definition"""
  alertDefinition: AlertDefinition

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """Evaluated condition containing values"""
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityEvaluationData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

type AlertLogConditionEvaluationFlat implements AlertConditionEvaluationFlat {
  """Alert definition ID"""
  alertDefinitionId: String!

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

interface AlertManagementEvent {
  """Event ID"""
  eventId: String!

  """Time in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)"""
  timestamp: String!

  """Alert definition ID"""
  alertDefinitionId: String!

  """Alert definition name"""
  alertDefinitionName: String

  """User ID"""
  userId: String
}

input AlertManagementEventsFilterInput {
  """Time range"""
  timeRange: AlertTimeRangeInput!

  """List of event types"""
  types: [AlertManagementEventType!]

  """List of Alert definition IDs"""
  alertDefinitionIds: [String!]

  """User ID"""
  userId: String

  """Event ID"""
  eventId: String
}

type AlertManagementEventsResult {
  """List of alert management events"""
  events: [AlertManagementEvent!]!

  """Cursor-based paging metadata"""
  pageInfo: PageInfo!
}

"""Alert management event types"""
enum AlertManagementEventType {
  ALERT_DEFINITION_CREATED
  ALERT_DEFINITION_DELETED
  ALERT_DEFINITION_DISABLED
  ALERT_DEFINITION_ENABLED
  ALERT_DEFINITION_MANUAL_RESET
  ALERT_DEFINITION_MUTED
  ALERT_DEFINITION_UNMUTED
  ALERT_DEFINITION_UPDATED
  ALERT_ACTION_DELETED_BY_CNS
}

type AlertMetricConditionEvaluation implements AlertConditionEvaluationV2 {
  """Alert definition"""
  alertDefinition: AlertDefinition

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityEvaluationData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

type AlertMetricConditionEvaluationFlat implements AlertConditionEvaluationFlat {
  """Alert definition ID"""
  alertDefinitionId: String!

  """
  Defines subject of given evaluation which might be (for example) an entity, entity combined with metric tag(s),
  metric tag(s) alone or the whole system (in case of the target not being defined - empty or `null`).
  """
  target: AlertEvaluationTarget

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Ordered list of flat evaluated tree nodes representing the flattened condition tree.
  The first item is the tree root.
  """
  evaluatedCondition: [FlatEvaluatedConditionTreeNode!]!

  """Current state of evaluation"""
  state: AlertConditionState!

  """
  Time of a last state change in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  changedAt: String!

  """
  Time when the evaluation was last triggered in ISO-8601 date format - 2011-12-03T10:15:30Z
  """
  lastTriggeredAt: String

  """
  Information about pending mute configurations related to this evaluation
  """
  muteInfo: AlertEvaluationMuteInfo!

  """Type of the condition"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData

  """Trigger id in cas of firing alert"""
  triggerId: String

  """
  UserId of user who acknowledged the evaluation, applicable only to FIRING state
  """
  acknowledgedByUserId: String
}

type AlertMutations {
  """
  Creates a new Alert definition and returns it on success, or null on error.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  createAlertDefinition(definition: AlertDefinitionInput!): AlertDefinition

  """
  Updates an Alert definition by ID and returns the alert on success, or null when no such Alert definition exists.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  updateAlertDefinition(id: ID!, definition: AlertDefinitionInput!): AlertDefinition

  """
  Patches an Alert definition and returns the Alert definition on success, or null
  when no such alert definition exists.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  patchAlertDefinition(alertDefinitionPatch: AlertDefinitionPatchInput!): AlertDefinition

  """
  Updates an Alert definitions by bulkDefinition and returns the Alert definitions on success, or null when no such
  Alert definition exists.
  Bulk definition updates only fields that are specified within the request of no value is sent field is left within
  Alert definition as it was before bulk update.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  bulkUpdateAlertDefinitions(ids: [ID!]!, bulkDefinition: AlertDefinitionBulkInput!): [AlertDefinition!]!

  """
  Resets evaluations for a given Alert definition ID.
  Return value is now deprecated.
  (Resetting evaluations means that all entities associated with the Alert definition are put back to the **OK** state,
  and a new notification will be sent if the alert fires again.)
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  resetAlertEvaluation(id: ID!): Int

  """
  Resets evaluations for a given list of Alert definition IDs and returns the total number of affected entries.
  (Resetting evaluations means that all entities associated with the Alert definition are put back to the **OK** state,
  and a new notification will be sent if the alert fires again.)
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  resetAlertEvaluations(ids: [ID!]!): Int!

  """
  Deletes an Alert definition by ID and returns the ID on success, or null when no such Alert definition exists.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  deleteAlertDefinition(id: ID!): ID

  """
  Deletes Alert definitions by IDs and returns the list of IDs.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  deleteAlertDefinitions(ids: [ID!]!): [ID!]!

  """
  Mutes given alerting targets until given timestamp or 'until resolved' when no timestamp is specified.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  muteAlerts(targets: [AlertMuteOrUnmuteTargetInput!]!, until: String): Boolean

  """
  Unmutes given alerting targets.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  unmuteAlerts(targets: [AlertMuteOrUnmuteTargetInput!]!): Boolean

  """
  Deletes all alert actions with given configuration IDs from every Alert definition that contains any of them and
  returns the list of IDs of affected Alert definitions. If no such definitions were found, empty list is returned.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  deleteAlertActionByConfigurationId(id: ID!): [ID!]

  """
  Acknowledges alert by current user. Alert is acknowledged per triggerId.
  """
  acknowledgeAlert(acknowledgementTarget: AcknowledgementTargetInput): ID
}

"""What should be muted - one or both fields must be specified."""
input AlertMuteOrUnmuteTargetInput {
  """Alert definition ID"""
  alertDefinitionId: String

  """Entity ID"""
  entityId: String
}

type AlertQueries {
  """
  Returns all Alert definitions with given Filter, Paging and Sorting.
  Filtering can be performed either using dedicated fields in the `filter` input, or using a generic `filter.filter`
  field. The latter one can be also used to filter Alert definitions with no configured actions/condition evaluations
  using `propertyName: "actions:`/`propertyName: "conditionEvaluations"` and 'operation: EXISTS'.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  alertDefinitions(filter: AlertFilterInput!, paging: PagingInput, sortBy: SortInput): AlertDefinitionsResult!

  """
  Returns firing alert instances (also referred as objects or evaluations) for given Filter, Paging and Sorting.
  Sorting is supported for `alertDefinitionName`, `alertDefinitionSeverity`, `entityDisplayName`, `source`, `changedAt` and `lastTriggeredAt`.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  activeAlerts(filter: ActiveAlertsFilterInput!, paging: PagingInput, sortBy: SortInput): AlertEvaluationsResult!

  """
  Returns all past firing alert instances (also referred as objects or evaluations) for given Filter, Paging and Sorting.
  Sorting is supported for `alertDefinitionName`, `alertDefinitionSeverity`, `triggeredAt`, `resolvedAt`, `entityDisplayName` and `source`.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  
  @param categories list of categories that should the statistics be calculated for, if not specified, all categories
  are counted
  """
  historicalAlerts(filter: HistoricalAlertsFilterInput!, paging: PagingInput, sortBy: SortInput, categories: [HistoricalAlertsStatisticsCategory!]): HistoricalAlertsResult!

  """
  Returns all alert instances (also referred as objects or evaluations) for given alert definition with given Filter, Paging and Sorting.
  Sorting is supported for `entityDisplayName`, `state`, `changedAt`, and `lastTriggeredAt`.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  alertEvaluationsV2(id: ID!, filter: AlertEvaluationsFilterInput!, paging: PagingInput, sortBy: SortInput): AlertEvaluationsResult!

  """
  Returns alert definition statistics, both for all definitions and for definitions complying with the given filter.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  
  @param categories list of categories that should the statistics be calculated for, if not specified, all categories
  are counted
  """
  alertStatistics(filter: AlertFilterInput!, categories: [AlertDefinitionStatisticsCategory!]): [AlertStatistics!]!

  """
  Returns alert evaluation statistics, both for all evaluations and for evaluations complying with the given filter.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  
  @param categories list of categories that should the statistics be calculated for, if not specified, all categories
  are counted
  """
  evaluationStatistics(filter: AlertEvaluationFilterInput!, categories: [AlertEvaluationStatisticsCategory!]): [AlertStatistics!]!

  """
  Evaluates the alert condition and returns the result, or null on error.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  
  @param condition the ordered list of condition nodes representing the flatten condition tree.
  The first item is the tree root.
  """
  evaluateAlertConditionV2(condition: [AlertConditionNodeInput!]!): [AlertConditionEvaluationV2!]!

  """
  Returns alert management events with for given Filter and Paging.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  alertManagementEvents(filter: AlertManagementEventsFilterInput!, paging: PagingInput): AlertManagementEventsResult!

  """
  Returns 5 most triggered entities for given alert definition within given time range.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  mostTriggeredEntities(id: ID!, timeRange: AlertTimeRangeInput!): [EntityTriggerCount!]!
}

"""Alert resolution reasons"""
enum AlertReason {
  AUTO_RESET
  MANUAL_RESET
  ENTITY_DELETED
  ALERT_DEFINITION_DELETED
}

"""Alert Definition severities"""
enum AlertSeverity {
  INFO
  WARNING
  CRITICAL
}

type AlertsHistogramColumn {
  """Start time from which the histogram is represented"""
  startTime: String!

  """End time from which the histogram is represented"""
  endTime: String!

  """Number of alerts triggered within start to end period"""
  newAlerts: Int!

  """Carry on alerts from previous periods"""
  ongoingAlerts: Int!
}

type AlertStatistics {
  """Category"""
  category: AlertStatisticsCategory!

  """List of statistics items"""
  items: [AlertStatisticsItem!]!
}

"""Alerting statistics categories"""
enum AlertStatisticsCategory {
  ACKNOWLEDGEMENT_STATUS
  ACTIVE
  ALERT_DEFINITION
  CONDITION_TYPE
  ENABLED
  ENTITY
  MEAN_TIME_TO_RESOLVE
  MUTED
  REASON
  SEVERITY
  TRIGGERED
  TRIGGERING_OBJECT
}

type AlertStatisticsItem {
  """Name of statistics item"""
  name: String!

  """Number of items matching current filter"""
  countForFilter: Int!

  """Total number of items"""
  countForAll: Int!
}

input AlertTimeRangeInput {
  """
  Start time of the time range, accepts: UNIX timestamp, ISO format and `2 days ago` formats.
  """
  startTime: String!

  """
  End time of the time range, accepts: UNIX timestamp, ISO format and `1 day ago` formats.
  """
  endTime: String
}

"""
Contains properties that can be used to filter data
TrafficFilter - NorthSouth, EastWest or Undefined. Specifies whether the traffic is external, internal, or undefined
              - Option 'All' is no longer supported
NetworkEntityId - string id of network entity
IngressInterfaceId - string id of a network interface
EgressInterfaceId - string id of a network interface
Rest - self explanatory
"""
enum AllowedFilterProperty {
  TrafficFilter
  NetworkEntityId
  IngressInterfaceId
  EgressInterfaceId
  ProtocolName
  ApplicationName
  AdvancedApplicationName
  EndpointName
  CountryName
}

type AllPermissionsResponse {
  roleNames: [String!]!
  featurePermissions: [FeaturePermissions!]!
}

interface AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
}

type AnalysisRedirect {
  url: String!
  durationInMs: Int!
  ipLookupDetails: IpLookupDetails
  connectionDetails: ConnectionDetails
  requestDetails: RequestDetails
  responseDetails: ResponseDetails
}

type AnalysisTraceroute {
  durationInMs: Int!
  rawOutput: String!
}

type ApacheInstance implements Entity & HealthEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type"""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state.
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Host name"""
  hostName: String

  """Host id"""
  hostId: String

  """UAMS agent id"""
  uamsClientId: String

  """UAMS agent plugin instance id"""
  uamsPluginInstanceId: String

  """Apache requests rate"""
  requestsRate: Metric!

  """Apache traffic rate"""
  trafficRate: Metric!

  """Apache average processing time per request (latency)"""
  timePerRequest: Metric!
}

type ApmConfig {
  collectorUrl: String
}

type ApmContainerExtension {
  """Entity name"""
  name: String

  """Container id"""
  containerId: String

  """Container runtime"""
  runtime: String

  """Container image name"""
  imageName: String

  """Container image tag"""
  imageTag: String
}

"""APM entity extension for Host"""
type APMHostExtension {
  """Host Id"""
  hostId: String!

  """Entity name"""
  name: String

  """Host Name"""
  hostname: String!

  """Os name"""
  osName: String

  """Os version"""
  osVersion: String

  """Os type"""
  osType: String

  """os description"""
  osDescription: String

  """
  Original host name. User can add hostname alias in the config of instrumentation lib (which will override observed value). This attribute is used to represent observed/polled name.
  """
  originalHostname: String

  """Trace service host error"""
  traceServiceHostErrors: Metric!

  """Trace service host request"""
  traceServiceHostRequests: Metric!

  """Trace service host response time"""
  traceServiceHostResponseTime: Metric!
}

interface Attribute {
  id: ID!
  type: AttributeType!
  name: String!
  description: String!
}

type AttributeBool implements Attribute {
  id: ID!
  type: AttributeType!
  name: String!
  description: String!
  defaultValue: Boolean
  value: Boolean
}

type AttributeFloat implements Attribute {
  id: ID!
  type: AttributeType!
  name: String!
  description: String!
  defaultValue: Float
  value: Float
}

type AttributeInt implements Attribute {
  id: ID!
  type: AttributeType!
  name: String!
  description: String!
  defaultValue: Int
  value: Int
}

type AttributeJson implements Attribute {
  id: ID!
  type: AttributeType!
  name: String!
  description: String!
  defaultValue: JSON
  value: JSON
}

type AttributeString implements Attribute {
  id: ID!
  type: AttributeType!
  name: String!
  description: String!
  defaultValue: String
  value: String
}

enum AttributeType {
  STRING
  INT
  FLOAT
  BOOL
  JSON
}

type AuditTrailEntity {
  id: ID!
  label: String!
  timestamp: DateTime!
  event: String!
  data: JSON
}

type AuthenticatedUser implements SwicusUser {
  id: ID!
  email: String!
  firstName: String
  lastName: String
  lastLogin: DateTime
  emailVerified: Boolean!
  timezone: String
  currentOrganization: Organization!
  auditTrail(limit: Int): [AuditTrailEntity]
  organizations: [OrganizationBaseInfo!]!
  userAttribute(id: String!): UserAttribute
  trustedDevices: [TrustedDevice]!
}

input AvailabilityCheckSettingsInput {
  """
  Use this field to configure whether availability tests should check for presence or absence of a
  particular string on a page.
  
  If the `operator` is DOES_NOT_CONTAIN and the `value` is found on the page, the availability test
  will fail.
  
  Likewise, if the `operator` is CONTAINS and the `value` is not found on the page, the
  availability test will fail.
  
  If set to null, the string checking functionality will be disabled.
  
  If omitted, the previous configuration (if any) will stay in effect.
  """
  checkForString: CheckForStringInput

  """
  Configure how often availability tests should be performed.
  
  Provide a number of seconds that is divisible by 60 and no greater than 14400 (4 hours).
  """
  testIntervalInSeconds: Int!

  """
  Configure which protocols need availability tests to be performed. At least one protocol must
  be provided.
  """
  protocols: [WebsiteProtocol!]!

  """
  Configure cloud platforms of the synthetic availability test probes.
  
  If set to null, no particular cloud platform will be enforced.
  
  If omitted, the previous configuration (if any) will stay in effect.
  """
  platformOptions: ProbePlatformOptionsInput

  """
  Configure locations of the synthetic availability test probes.
  
  Acceptable `values` depend on the selected `type` and actual values of existing probes.
  
  To find out all possible `values` of each type, run the following query:
  ```
  query {
    dem {
      probes {
        region
        country
        city
      }
    }
  }
  ```
  """
  testFrom: ProbeLocationInput!

  """
  Configure monitoring of SSL/TLS certificates validity. This option is relevant for HTTPS
  protocol only.
  
  If set to null, SSL monitoring will be disabled and its previous configuration discarded.
  
  If omitted, the previous configuration (if any) will stay in effect.
  """
  ssl: SslMonitoringInput

  """
  Configure custom request headers to be sent with each availability test. It is possible to
  provide multiple headers with the same name.
  
  If set to null or an empty array, no custom headers will be sent.
  
  If omitted, the previous configuration (if any) will stay in effect.
  """
  customHeaders: [CustomHeaderInput!]
}

type AvailabilityMonitoring {
  checkForString: CheckForStringType
  ssl: SslMonitoring
  protocols: [WebsiteProtocol!]!
  testFromLocation: ProbeLocationType
  testIntervalInSeconds: Int
  locationOptions: [ProbeLocation!]!
  platformOptions: PlatformOptions
}

input AvailabilityMonitoringInput {
  checkForString: CheckForStringInput
  testIntervalInSeconds: Int!
  protocols: [WebsiteProtocol!]!
  platformOptions: PlatformOptionsInput
  testFrom: [InternalProbeLocationInput!]!
  ssl: SslMonitoringInput
}

type AvailabilityTestAnalysis {
  analysisId: ID!
  durationInMs: Int!
  errorMessage: String
  redirects: [AnalysisRedirect!]!
  traceroute: AnalysisTraceroute
}

type AvailabilityTestAnalysisQueries {
  byId(analysisId: ID!, testResultTime: DateTime!): AvailabilityTestAnalysis
}

type AvailabilityTestValidations {
  sslCertificates: SslCertificates
  checkForString: CheckForString
}

type AvailabilityTestValidationsQueries {
  byId(validationId: ID!, testResultTime: DateTime!): AvailabilityTestValidations
}

"""AWS API GATEWAY"""
type AwsApiGateway implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """API GATEWAY APINAME."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Cloud Account to which this API GATEWAY belongs to."""
  cloudAccount: CloudAccount

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """API Gateway API name."""
  apiName: String

  """API Gateway API ID."""
  apiId: String

  """API Gateway Stage"""
  stage: String

  """API Gateway Method"""
  method: String

  """API Gateway Resource"""
  resource: String

  """API Gateway Route"""
  route: String

  """AWS API Gateway Type (Like: Rest. Http, Websocket)."""
  gatewayType: String

  """
  The number of HTTP 4xx client error status code requests made to an Amazon API GATEWAY.
  """
  numberOf4xxErrors: Metric!

  """
  The number of HTTP 5xx client error status code requests made to an Amazon API GATEWAY.
  """
  numberOf5xxErrors: Metric!

  """The number of requests served from the API cache in a given period."""
  cacheHitCount: Metric!

  """
  The number of requests served from the backend in a given period, when API caching is enabled.
  """
  cacheMissCount: Metric!

  """The number of client-side errors captured in a given period."""
  numberOf4xx: Metric!

  """The number of server-side errors captured in a given period."""
  numberOf5xx: Metric!

  """The total number API requests in a given period."""
  requestCount: Metric!

  """
  The time between when API Gateway relays a request to the backend and when it receives a response from the backend.
  """
  integrationLatency: Metric!

  """
  The time between when API Gateway receives a request from a client and when it returns a response to the client. The latency includes the integration latency and other API Gateway overhead.
  """
  latency: Metric!

  """The amount of data processed in bytes."""
  dataProcessed: Metric!

  """The number of messages sent to the $connect route integration."""
  connectCount: Metric!

  """
  The number of messages sent to the WebSocket API, either from or to the client.
  """
  messageCount: Metric!

  """
  The number of requests that return a 4XX/5XX response from the integration.
  """
  integrationError: Metric!

  """
  The number of requests that have a 4XX response returned by API Gateway before the integration is invoked.
  """
  clientError: Metric!

  """Errors that occurred when calling the integration."""
  executionError: Metric!

  """
  Rate of 5xx error against total request count for Rest based AWS Api Gateway.
  """
  rest5xxErrorRate: Metric!

  """
  Rate of 5xx error against total request count for Http based AWS Api Gateway.
  """
  http5xxErrorRate: Metric!

  """
  Rate of Execution error against message count for Websocket based AWS Api Gateway.
  """
  websocketExecutionErrorRate: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS Application load balancer"""
type AwsApplicationELB implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Application load balancer name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Application load balancer"""
  loadBalancer: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Application load balancer target group"""
  targetGroup: String

  """The Availability Zone of the instance."""
  availabilityZone: String

  """DNS name of Application load balancer"""
  dnsName: String

  """This field represents the ALB state."""
  state: State

  """
  This field represents the type of load balancer (application | gateway | network).
  """
  loadBalancerType: String

  """This field represents the ID of the VPC for the load balancer."""
  vpcId: String

  """This field represents schema of load balancer."""
  scheme: String

  """This field represents the ip address for the load balancer."""
  ipaddress: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String

  """
  The cloudaccountId of the cloudAccount to which this load balacer belongs.
  """
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ALB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """
  The total number of concurrent TCP connections active from clients to the load balancer and from the load balancer to targets.
  """
  activeConnectionCount: Metric!

  """
  The number of TLS connections initiated by the client that did not establish a session with the load balancer due to a TLS error.
  """
  clientTlsNegotiationErrorCount: Metric!

  """
  The number of load balancer capacity units (LCU) used by your load balancer.
  """
  consumedLcus: Metric!

  """The number of requests that do not comply with RFC 7230."""
  desyncMitigationModeNonCompliantRequestCount: Metric!

  """
  The number of requests where the load balancer removed HTTP headers with header fields that are not valid before routing the request.
  """
  droppedInvalidHeaderRequestCount: Metric!

  """
  The number of requests routed by the load balancer that had HTTP headers with header fields that are not valid.
  """
  forwardedInvalidHeaderRequestCount: Metric!

  """The number of gRPC requests processed over IPv4 and IPv6."""
  grpcRequestCount: Metric!

  """The number of fixed-response actions that were successful."""
  httpFixedResponseCount: Metric!

  """The number of redirect actions that were successful."""
  httpRedirectCount: Metric!

  """
  The number of redirect actions that couldn't be completed because the URL in the response location header is larger than 8K.
  """
  httpRedirectUrlLimitExceededCount: Metric!

  """
  The number of HTTP 3XX redirection codes that originate from the load balancer.
  """
  httpCodeElb3xxCount: Metric!

  """
  The number of HTTP 4XX client error codes that originate from the load balancer.
  """
  httpCodeElb4xxCount: Metric!

  """
  The number of HTTP 5XX server error codes that originate from the load balancer.
  """
  httpCodeElb5xxCount: Metric!

  """
  The number of HTTP 500 error codes that originate from the load balancer.
  """
  httpCodeElb500Count: Metric!

  """
  The number of HTTP 502 error codes that originate from the load balancer.
  """
  httpCodeElb502Count: Metric!

  """
  The number of HTTP 503 error codes that originate from the load balancer.
  """
  httpCodeElb503Count: Metric!

  """
  The number of HTTP 504 error codes that originate from the load balancer.
  """
  httpCodeElb504Count: Metric!

  """
  The total number of bytes processed by the load balancer over IPv6. This count is included in ProcessedBytes.
  """
  ipv6ProcessedBytes: Metric!

  """The number of IPv6 requests received by the load balancer."""
  ipv6RequestCount: Metric!

  """
  The total number of new TCP connections established from clients to the load balancer and from the load balancer to targets.
  """
  newConnectionCount: Metric!

  """
  The number of requests where the load balancer chose a new target because it couldn't use an existing sticky session.
  """
  nonStickyRequestCount: Metric!

  """
  The total number of bytes processed by the load balancer over IPv4 and IPv6.
  """
  processedBytes: Metric!

  """
  The number of connections that were rejected because the load balancer had reached its maximum number of connections.
  """
  rejectedConnectionCount: Metric!

  """
  The number of requests processed over IPv4 and IPv6. This metric is only incremented for requests where the load balancer node was able to choose a target.
  """
  requestCount: Metric!

  """
  The number of rules processed by the load balancer given a request rate averaged over an hour.
  """
  ruleEvaluations: Metric!

  """The number of targets that are considered healthy."""
  healthyHostCount: Metric!

  """The number of HTTP 2XX response codes generated by the targets"""
  httpCodeTarget2xxCount: Metric!

  """The number of HTTP 3XX response codes generated by the targets"""
  httpCodeTarget3xxCount: Metric!

  """The number of HTTP 4XX response codes generated by the targets"""
  httpCodeTarget4xxCount: Metric!

  """The number of HTTP 5XX response codes generated by the targets"""
  httpCodeTarget5xxCount: Metric!

  """
  The average number of requests received by each target in a target group. 
  """
  requestCountPerTarget: Metric!

  """
  The number of connections that were not successfully established between the load balancer and target.
  """
  targetConnectionErrorCount: Metric!

  """
  The time elapsed, in seconds, after the request leaves the load balancer until a response from the target is received.
  """
  targetResponseTime: Metric!

  """
  The number of TLS connections initiated by the load balancer that did not establish a session with the target.
  """
  targetTlsNegotiationErrorCount: Metric!

  """The number of targets that are considered unhealthy."""
  unHealthyHostCount: Metric!

  """
  The number of requests to a Lambda function that failed because of an issue internal to the load balancer or AWS Lambda. 
  """
  lambdaInternalError: Metric!

  """
  The total number of bytes processed by the load balancer for requests to and responses from a Lambda function.
  """
  lambdaTargetProcessedBytes: Metric!

  """
  The number of requests to a Lambda function that failed because of an issue with the Lambda function.
  """
  lambdaUserError: Metric!

  """
  The number of user authentications that could not be completed because an authenticate action was misconfigured, the load balancer couldn't establish a connection with the IdP, or the load balancer couldn't complete the authentication flow due to an internal error.
  """
  elbAuthError: Metric!

  """
  The number of user authentications that could not be completed because the IdP denied access to the user or an authorization code was used more than once.
  """
  elbAuthFailure: Metric!

  """
  The time elapsed, in milliseconds, to query the IdP for the ID token and user info.
  """
  elbAuthLatency: Metric!

  """
  The number of times the load balancer successfully refreshed user claims using a refresh token provided by the IdP.
  """
  elbAuthRefreshTokenSuccess: Metric!

  """The number of authenticate actions that were successful."""
  elbAuthSuccess: Metric!

  """
  The number of times that a configured IdP returned user claims that exceeded 11K bytes in size.
  """
  elbAuthUserClaimsSizeExceeded: Metric!

  """
  The UnHealthyHost rate metric is used in health score for AWS ALB, which is sum of UnHealthyHostCount by total number of UnHealthyHostCount and HealthyHostCount.
  """
  unHealthyHostRate: Metric!

  """
  The HealthyHostRate metric provides percentage of healthy hosts over all the hosts(healthy & unhealthy)
  """
  healthyHostRate: Metric!

  """50th Target response time percentile"""
  targetResponseTimeP50: Metric!

  """90th Target response time percentile"""
  targetResponseTimeP90: Metric!

  """99th Target response time percentile"""
  targetResponseTimeP99: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS Aurora Cluster"""
type AwsAuroraCluster implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Aurora Cluster name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this Aurora Cluster belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """The current state of the Aurora DB Cluster."""
  state: State

  """Aurora Cluster Database Name"""
  databaseName: String

  """Aurora Cluster Engine Name"""
  engineName: String

  """
  Aurora Cluster Engine Mode (provisioned | serverless | parallelquery | global | multimaster)
  """
  engineMode: String!

  """Aurora Cluster Engine Version"""
  engineVersion: String

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """Cloud provider Name"""
  cloudProvider: String!

  """
  The cloudaccountId of the cloudAccount to which this Aurora Cluster belongs.
  """
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """
  In an Aurora Global Database, the amount of redo log data transferred from the master AWS Region to a secondary AWS Region.
  """
  auroraGlobalDBDataTransferBytes: Metric!

  """
  In an Aurora Global Database, the measure of how far the secondary cluster is behind the primary cluster for both user transactions and system transactions.
  """
  auroraGlobalDBProgressLag: Metric!

  """
  In an Aurora Global Database, the number of write I/O operations replicated from the primary AWS Region to the cluster volume in a secondary AWS Region.
  """
  auroraGlobalDBReplicatedWriteIO: Metric!

  """
  For an Aurora Global Database, the amount of lag when replicating updates from the primary AWS Region.
  """
  auroraGlobalDBReplicationLag: Metric!

  """
  In an Aurora Global Database, the recovery point objective (RPO) lag time. This metric measures how far the secondary cluster is behind the primary cluster for user transactions.
  """
  auroraGlobalDBRPOLag: Metric!

  """
  The remaining available space for the cluster volume. As the cluster volume grows, this value decreases. If it reaches zero, the cluster reports an out-of-space error.
  """
  auroraVolumeBytesLeftTotal: Metric!

  """
  The number of backtrack change records created over 5 minutes for your DB cluster.
  """
  backtrackChangeRecordsCreationRate: Metric!

  """The number of backtrack change records used by your DB cluster."""
  backtrackChangeRecordsStored: Metric!

  """
  The total amount of backup storage used to support the point-in-time restore feature within the Aurora DB cluster's backup retention window. 
  """
  backupRetentionPeriodStorageUsed: Metric!

  """The current capacity of an Aurora Serverless DB cluster."""
  ServerlessDatabaseCapacity: Metric!

  """
  The total amount of backup storage consumed by all Aurora snapshots for an Aurora DB cluster outside its backup retention window.
  """
  snapshotStorageUsed: Metric!

  """
  The total amount of backup storage in bytes for which you are billed for a given Aurora DB cluster.
  """
  totalBackupStorageBilled: Metric!

  """The amount of storage used by your Aurora DB instance."""
  volumeBytesUsed: Metric!

  """
  The number of billed read I/O operations from a cluster volume within a 5-minute interval.
  """
  volumeReadIOPs: Metric!

  """The number of write disk I/O operations to the cluster volume."""
  volumeWriteIOPs: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS Aurora Instance"""
type AwsAuroraInstance implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Aurora Instance name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this Aurora Instance belongs"""
  cloudAccount: CloudAccount

  """Relation: Cluster to which this Aurora Instance belongs"""
  auroraCluster: AwsAuroraCluster
  healthScore: HealthScore

  """The current state of the Aurora DB Instance."""
  state: State

  """Aurora Instance Database Name"""
  databaseName: String

  """Aurora Instance Engine Name"""
  engineName: String

  """Aurora Instance Engine Version"""
  engineVersion: String

  """Aurora Cluster to which Instance belongs"""
  clusterId: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """Cloud provider Name"""
  cloudProvider: String!

  """
  The cloudaccountId of the cloudAccount to which this Aurora Cluster belongs.
  """
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """The number of client connections that have not been closed properly."""
  abortedClients: Metric!

  """
  The average number of current transactions executing on an Aurora database instance per second.
  """
  activeTransactions: Metric!

  """
  The amount of time that a binary log replica DB cluster running on Aurora MySQL-Compatible Edition lags behind the binary log replication source.
  """
  auroraBinlogReplicaLag: Metric!

  """
  For an Aurora replica, the amount of lag when replicating updates from the primary instance.
  """
  auroraReplicaLag: Metric!

  """
  The maximum amount of lag between the primary instance and each Aurora DB instance in the DB cluster.
  """
  auroraReplicaLagMaximum: Metric!

  """
  The minimum amount of lag between the primary instance and each Aurora DB instance in the DB cluster.
  """
  auroraReplicaLagMinimum: Metric!

  """
  The difference between the target backtrack window and the actual backtrack window.
  """
  backtrackWindowActual: Metric!

  """
  The number of times that the actual backtrack window is smaller than the target backtrack window for a given period of time.
  """
  backtrackWindowAlert: Metric!

  """
  The average number of transactions in the database that are blocked per second.
  """
  blockedTransactions: Metric!

  """The percentage of requests that are served by the buffer cache."""
  bufferCacheHitRatio: Metric!

  """The average duration of commit operations."""
  commitLatency: Metric!

  """The average number of commit operations per second."""
  commitThroughput: Metric!

  """
  The number of attempts to connect to an instance, whether successful or not.
  """
  connectionAttempts: Metric!

  """
  The number of CPU credits that an instance has accumulated, reported at 5-minute intervals.
  """
  cpuCreditBalance: Metric!

  """
  The number of CPU credits consumed during the specified period, reported at 5-minute intervals.
  """
  cpuCreditUsage: Metric!

  """The percentage of CPU used by an Aurora DB instance."""
  cpuUtilization: Metric!

  """The number of client network connections to the database instance."""
  databaseConnections: Metric!

  """
  The average duration of requests such as example, create, alter, and drop requests.
  """
  ddlLatency: Metric!

  """The average number of DDL requests per second."""
  ddlThroughput: Metric!

  """The average number of deadlocks in the database per second."""
  deadlocks: Metric!

  """The average duration of delete operations."""
  deleteLatency: Metric!

  """The average number of delete queries per second."""
  deleteThroughput: Metric!

  """
  The number of outstanding read/write requests waiting to access the disk.
  """
  diskQueueDepth: Metric!

  """The average duration of inserts, updates, and deletes."""
  dmlLatency: Metric!

  """The average number of inserts, updates, and deletes per second."""
  dmlThroughput: Metric!

  """The amount of time that the instance has been running."""
  engineUptime: Metric!

  """The amount of available random access memory."""
  freeableMemory: Metric!

  """The amount of local storage available."""
  freeLocalStorage: Metric!

  """The average number of insert operations per second."""
  insertLatency: Metric!

  """The average number of failed login attempts per second."""
  insertThroughput: Metric!

  """The average number of failed login attempts per second."""
  loginFailures: Metric!

  """The age of the oldest unvacuumed transaction ID, in transactions."""
  maximumUsedTransactionIDs: Metric!

  """
  The amount of network throughput received from clients by each instance in the Aurora MySQL DB cluster.
  """
  networkReceiveThroughput: Metric!

  """
  The amount of network throughput both received from and transmitted to clients by each instance in the Aurora MySQL DB cluster.
  """
  networkThroughput: Metric!

  """
  The amount of network throughput sent to clients by each instance in the Aurora DB cluster. 
  """
  networkTransmitThroughput: Metric!

  """The number of binlog files generated."""
  numBinaryLogFiles: Metric!

  """The average number of queries executed per second."""
  queries: Metric!

  """
  The lag when replicating updates from the primary RDS PostgreSQL instance to other nodes in the cluster.
  """
  rdsToAuroraPostgreSQLReplicaLag: Metric!

  """The average number of disk I/O operations per second."""
  readIOPS: Metric!

  """The average amount of time taken per disk I/O operation."""
  readLatency: Metric!

  """The average number of bytes read from disk per second."""
  readThroughput: Metric!

  """The amount of disk space consumed by replication slot files."""
  replicationSlotDiskUsage: Metric!

  """The percentage of requests that are served by the Resultset cache."""
  resultSetCacheHitRatio: Metric!

  """
  The undo logs that record committed transactions with delete-marked records
  """
  rollbackSegmentHistoryListLength: Metric!

  """The total time spent acquiring row locks for InnoDB tables."""
  rowLockTime: Metric!

  """The average amount of time for select operations."""
  selectLatency: Metric!

  """The average number of select queries per second."""
  selectThroughput: Metric!

  """
  The amount of network throughput received from the Aurora storage subsystem by each instance in the DB cluster.
  """
  storageNetworkReceiveThroughput: Metric!

  """
  The amount of network throughput received from and sent to the Aurora storage subsystem by each instance in the Aurora MySQL DB cluster.
  """
  storageNetworkThroughput: Metric!

  """
  The amount of network throughput sent to the Aurora storage subsystem by each instance in the Aurora MySQL DB cluster.
  """
  storageNetworkTransmitThroughput: Metric!

  """The total size of the binlog files."""
  sumBinaryLogSize: Metric!

  """
  The amount of swap space used. This metric is available for the Aurora PostgreSQL DB instance classes 
  """
  swapUsage: Metric!

  """
  The amount of disk space consumed by transaction logs on the Aurora PostgreSQL DB instance.
  """
  transactionLogsDiskUsage: Metric!

  """The average amount of time taken for update operations."""
  updateLatency: Metric!

  """The average number of updates per second."""
  updateThroughput: Metric!

  """The number of Aurora storage write records generated per second. """
  writeIOPS: Metric!

  """The average amount of time taken per disk I/O operation."""
  writeLatency: Metric!

  """
  The average number of bytes written to persistent storage every second.
  """
  writeThroughput: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS Auto Scaling Group entity"""
type AwsAutoScalingGroup implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Cloud Account to which this CloudFront belongs."""
  cloudAccount: CloudAccount

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """The minimum size of the Auto Scaling group."""
  groupMinSize: Metric!

  """The maximum size of the Auto Scaling group."""
  groupMaxSize: Metric!

  """
  The number of instances that the Auto Scaling group attempts to maintain.
  """
  groupDesiredCapacity: Metric!

  """
  The number of instances that are running as part of the Auto Scaling group. This metric does not include instances that are pending or terminating.
  """
  groupInServiceInstances: Metric!

  """
  The number of instances that are pending. A pending instance is not yet in service. This metric does not include instances that are in service or terminating.
  """
  groupPendingInstances: Metric!

  """
  The number of instances that are in a Standby state. Instances in this state are still running but are not actively in service.
  """
  groupStandbyInstances: Metric!

  """
  The number of instances that are in the process of terminating. This metric does not include instances that are in service or pending.
  """
  groupTerminatingInstances: Metric!

  """
  The total number of instances in the Auto Scaling group. This metric identifies the number of instances that are in service, pending, and terminating.
  """
  groupTotalInstances: Metric!

  """
  The groupInServiceInstancesPercent metric provides percentage of instances in service over desired number of instances.
  """
  groupInServiceInstancesPercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AwsCloudAccount {
  entityId: ID!
  displayName: String!
}

type AwsCloudAccountConfiguration implements CloudAccountConfigurationInterface {
  metricsTag: String
  enabled: Boolean!
  accountId: ID!
  externalIdMasked: String!
  arn: String!
  regions: [AwsRegion!]!
  services: [AwsService!]!
}

input AwsCloudAccountConfigurationInput {
  metricsTag: String!
  arn: String!
  regions: [String!]!
  services: [String!]!
}

type AwsCloudAccountEditWizardSession {
  sessionId: Guid!
  externalId: Guid!
}

type AwsCloudAccountWizardSession {
  sessionId: Guid!
  externalId: Guid!
  accountId: ID!
}

"""AWS CloudFront entity"""
type AwsCloudFrontDistribution implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name """
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """The current status of AWS CloudFront entity."""
  state: State

  """Cloud provider Name"""
  cloudProvider: String

  """Distribution ID."""
  distributionId: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Domain name."""
  domainName: String

  """Cloud Account to which this CloudFront belongs."""
  cloudAccount: CloudAccount

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """
  The total number of viewer requests received by CloudFront, for all HTTP methods and for both HTTP and HTTPS requests.
  """
  requests: Metric!

  """
  The total number of bytes downloaded by viewers for GET, HEAD, and OPTIONS requests.
  """
  bytesDownloaded: Metric!

  """
  The total number of bytes that viewers uploaded to your origin with CloudFront, using POST and PUT requests.
  """
  bytesUploaded: Metric!

  """
  The percentage of all viewer requests for which the responses HTTP status code is 4xx.
  """
  rateOf4xxErrors: Metric!

  """
  The percentage of all viewer requests for which the responses HTTP status code is 5xx.
  """
  rateOf5xxErrors: Metric!

  """
  The percentage of all viewer requests for which the responses HTTP status code is 4xx or 5xx.
  """
  totalErrorRate: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""EBS entity """
type AwsEBS implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name """
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """EBS volume ID"""
  volumeId: String!

  """EBS volume name"""
  volumeName: String

  """This field represents the EBS volume type"""
  volumeType: String

  """This field represents the EBS volume size."""
  size: Int

  """This field represents the EBS volume state"""
  state: State

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """The Availability Zone of the volume."""
  availabilityZone: String

  """The metricsTag of the volume."""
  metricsTag: String

  """The cloudaccountId of the cloudAccount to which this volume belongs."""
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Cloud Account to which this EBS volume belongs."""
  cloudAccount: CloudAccount

  """Relation: List of ec2Host to which this ebsVolume is attached."""
  ec2Host: [Host!]

  """
  Provides information about the percentage of I/O credits (for gp2) or throughput credits (for st1 and sc1) remaining in the burst bucket.
  """
  burstBalance: Metric!

  """
  Provides information on the read operations in a specified period of time.
  """
  volumeReadBytes: Metric!

  """
  Provides information on the write operations in a specified period of time. 
  """
  volumeWriteBytes: Metric!

  """The total number of read operations in a specified period of time."""
  volumeReadOps: Metric!

  """The total number of write operations in a specified period of time. """
  volumeWriteOps: Metric!

  """
  The total number of seconds in a specified period of time when no read or write operations were submitted.
  """
  volumeIdleTime: Metric!

  """
  The number of read and write operation requests waiting to be completed in a specified period of time.
  """
  volumeQueueLength: Metric!

  """
  The percentage of I/O operations per second (IOPS) delivered of the total IOPS provisioned for an Amazon EBS volume.
  """
  volumeThroughputPercentage: Metric!

  """
  The total amount of read and write operations (normalized to 256K capacity units) consumed in a specified period of time.
  For example, a 1024K I/O would count as 4 consumed IOPS.
  """
  volumeConsumedReadWriteOps: Metric!

  """
  The total number of read and write operations in a specified period of time.
  """
  volumeTotalOps: Metric!

  """
  The total number of seconds spent by all read operations that completed in a specified period of time. 
  """
  volumeTotalReadTime: Metric!

  """
  The total number of seconds spent by all write operations that completed in a specified period of time.
  """
  volumeTotalWriteTime: Metric!

  """
  Avg Read Latency- The average time is taken to complete one read operation.(ms/Operation)
  """
  averageReadLatency: Metric!

  """
  Avg Write Latency- The average time is taken to complete one write operation.(ms/Operation)
  """
  averageWriteLatency: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""ElasticFileSystem """
type AwsEFS implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """EFS name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Filesystem ID of EFS."""
  fileSystemId: String!

  """Cloud provider Name"""
  cloudProvider: String

  """
  The amount of provisioned throughput, measured in MiB/s, for the file system. Valid for file systems using ThroughputMode set to provisioned.
  """
  provisionedThroughputInMibps: Float

  """The deprecated lifecycle phase of the file system."""
  lifecycleState: String @deprecated(reason: "State object is introduced, hence state attributes are changed to State Type")

  """The lifecycle phase of the file system."""
  state: State

  """Cloud Account to which this EFS service belongs."""
  cloudAccount: CloudAccount

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Relation: Service to Host (EFS mounted on which EC2 instance)"""
  hosts: [Host!]

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Region where EFS file system has been mounted from AWS instance"""
  region: String!

  """Performance Mode: General Purpose or Max I/O """
  performanceMode: String

  """
  Metric Shows the amount of time that has passed since the last successful sync to the destination file system in a replication configuration.
  """
  timeSinceLastSync: Metric!

  """
  Metric Shows how close a file system is to reaching the I/O limit of the General Purpose performance mode.
  """
  percentIOLimit: Metric!

  """The number of burst credits that a file system has."""
  burstCreditBalance: Metric!

  """The maximum amount of throughput that a file system can drive."""
  permittedThroughput: Metric!

  """
  The number of metered bytes for each file system operation, including data read, data write, and metadata operations, with read operations metered at one-third the rate of other operations.
  """
  meteredIOBytes: Metric!

  """
  The actual number of bytes for each file system operation, including data read, data write, and metadata operations.
  """
  totalIOBytes: Metric!

  """The number of bytes for each file system read operation ."""
  dataReadIOBytes: Metric!

  """The number of bytes for each file write operation."""
  dataWriteIOBytes: Metric!

  """The number of bytes for each metadata operation."""
  metadataIOBytes: Metric!

  """The number of client connections to a file system."""
  clientConnections: Metric!

  """
  TThe size of the file system in bytes, including the amount of data stored in the EFS Standard and EFS Standard-Infrequent Access (EFS Standard-IA) storage classes.
  """
  storageBytes: Metric!

  """Percentage of MetadataIOBytes through PermittedThroughput"""
  ioPercentage: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AwsElasticBeanstalkEnvironment entity"""
type AwsElasticBeanstalkEnvironment implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """
  The current status of AWS Beanstalk entity. Possible values are - 'Aborting'|'Launching'|'Updating'|'LinkingFrom'|'LinkingTo'|'Ready'|'Terminating'|'Terminated'
  """
  state: State

  """Cloud provider Name"""
  cloudProvider: String

  """Unique identifier of the AwsElasticBeanstalkEnvironment instance."""
  distributionId: String

  """Unique identifier of the AwsElasticBeanstalkEnvironment entity."""
  environmentId: String!

  """Name of the application in elastic beanstalk environment."""
  applicationName: String

  """
  Health of the elastic beanstalk environment. Possible values are - 'Green'|'Yellow'|'Red'|'Grey'.
  """
  health: String

  """
  Health status of the elastic beanstalk environment. Possible values are - 'NoData'|'Unknown'|'Pending'|'Ok'|'Info'|'Warning'|'Degraded'|'Severe'|'Suspended'.
  """
  healthStatus: String

  """Cloud Account to which this AwsElasticBeanstalkEnvironment belongs."""
  cloudAccount: CloudAccount

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """
  Number of requests handled by the web server per second over the last 10 seconds. Shown as an average r/sec (requests per second) in the EB CLI and Environment health page.
  """
  requestCount: Metric!

  """
  Number of requests that resulted in 2xx status code over the last 10 seconds.
  For example, successful requests return a 200 OK.
  """
  status2xx: Metric!

  """
  Number of requests that resulted in 3xx status code over the last 10 seconds.
  For example, redirects are a 301.
  """
  status3xx: Metric!

  """
  Number of requests that resulted in 4xx status code over the last 10 seconds.
  For example, 404 is returned if the URL entered doesn't match any resources in the application.
  """
  status4xx: Metric!

  """
  Number of requests that resulted in 5xx status code over the last 10 seconds.
  For example, 503 is returned if the web server responds with this status code when it is currently unable to handle
  the request due to a temporary overloading or maintenance of the server.
  """
  status5xx: Metric!

  """
  Average latency for the slowest x percent of requests over the last 10 seconds, where x is the difference between
  the number and 100. For example, p99 1.403 indicates the slowest 1% of requests over the last 10 seconds had an
  average latency of 1.403 seconds.
  """
  p999: Metric!

  """
  The status5xxPercent metric provides percentage of requests that returned 5XX errors over total number of requests.
  """
  status5xxPercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS Elastic load balancer (Classic Load Balancer)"""
type AwsELB implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """ELB name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ELB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """
  The cloudaccountId of the cloudAccount to which this load balacer belongs.
  """
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """The Availability Zone of the instance."""
  availabilityZone: String

  """DNS name of ELB"""
  dnsName: String

  """ELB healthcheck timeout """
  healthcheckTimeout: String

  """ELB healthcheck interval """
  healthcheckInterval: String

  """ELB healthcheck unhealthythreshold """
  healthcheckUnhealthyThreshold: String

  """ELB healthcheck healthythreshold """
  healthcheckHealthyThreshold: String

  """ELB healthcheck target """
  healthcheckTarget: String

  """
  This field represents type of Elastic load balancer. Valid only for load balancers in a VPC.
  """
  scheme: String

  """
  The number of connections that were not successfully established between the load balancer and the registered instances.
  """
  backendConnectionErrors: Metric!

  """The number of requests that do not comply with RFC 7230."""
  desyncMitigationModeNonCompliantRequestCount: Metric!

  """The number of healthy instances registered with your load balancer."""
  healthyHostCount: Metric!

  """
  The number of HTTP 2XX response codes generated by registered instances.
  """
  httpCodeBackend2xx: Metric!

  """
  The number of HTTP 3XX response codes generated by registered instances.
  """
  httpCodeBackend3xx: Metric!

  """
  The number of HTTP 4XX response codes generated by registered instances.
  """
  httpCodeBackend4xx: Metric!

  """
  The number of HTTP 5XX response codes generated by registered instances.
  """
  httpCodeBackend5xx: Metric!

  """
  The number of HTTP 4XX client error codes generated by the load balancer.
  """
  httpCodeELB4xx: Metric!

  """
  The number of HTTP 5XX client error codes generated by the load balancer.
  """
  httpCodeELB5xx: Metric!

  """
  The total time elapsed, in seconds, from the time the load balancer sent the request to a registered instance until the instance started to send the response headers.
  """
  latency: Metric!

  """
  The number of requests completed or connections made during the specified interval (1 or 5 minutes).
  """
  requestCount: Metric!

  """
  The total number of requests that were rejected because the surge queue is full.
  """
  spilloverCount: Metric!

  """
  The total number of requests (HTTP listener) or connections (TCP listener) that are pending routing to a healthy instance. 
  """
  surgeQueueLength: Metric!

  """The number of unhealthy instances registered with your load balancer. """
  unHealthyHostCount: Metric!

  """
  The HealthyHostPercent metric provides percentage of healthy hosts over all the hosts(healthy & unhealthy)
  """
  healthyHostPercent: Metric!

  """
  The backendConnectionErrorsRate metric provides percentage of backendconnection erros over total request count
  """
  backendConnectionErrorsRate: Metric!

  """
  The httpCodeELB5xxRate metric provides percentage of 5xx erros over total request count
  """
  httpCodeELB5xxRate: Metric!

  """50th Latency percentile"""
  latencyP50: Metric!

  """90th Latency percentile"""
  latencyP90: Metric!

  """99th Latency percentile"""
  latencyP99: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS FSx"""
type AwsFsx implements Entity & HealthEntity & StatefulEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this FSx belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """
  State of FSx(AVAILABLE | CREATING | FAILED | DELETING | MISCONFIGURED | UPDATING | MISCONFIGURED_UNAVAILABLE)
  """
  state: State

  """File System name"""
  fileSystemName: String

  """IDs of the file systems"""
  fileSystemId: String!

  """IDs of Volume which the file system belongs to"""
  volumeId: String

  """The Domain Name System (DNS) name for the file system"""
  dnsName: String

  """The ID of the primary virtual private cloud (VPC) for the file system"""
  vpcId: String

  """The type of Amazon FSx file system(WINDOWS | LUSTRE | ONTAP | OPENZFS)"""
  fileSystemType: String

  """The type of storage the file system is using (SSD | HDD)"""
  storageType: String

  """
  Specifies the file system deployment type(SCRATCH_1 | SCRATCH_2 | PERSISTENT_1 | PERSISTENT_2 | MULTI_AZ_1 | SINGLE_AZ_1 | SINGLE_AZ_2)
  """
  deploymentType: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String!

  """Event Source as seen in logs eg: fsx.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """The number of bytes for file system read operations."""
  dataReadBytes: Metric!

  """The number of bytes for file system write operations"""
  dataWriteBytes: Metric!

  """The number of read operations"""
  dataReadOperations: Metric!

  """The number of write operations """
  dataWriteOperations: Metric!

  """The number of metadata operations"""
  metadataOperations: Metric!

  """The amount of available storage capacity"""
  freeDataStorageCapacity: Metric!

  """The amount of logical data stored (uncompressed)"""
  logicalDiskUsage: Metric!

  """
  The amount of storage physically occupied by file system data (compressed)
  """
  physicalDiskUsage: Metric!

  """The amount of available storage capacity"""
  freeStorageCapacity: Metric!

  """The number of active connections between clients and the file server"""
  clientConnections: Metric!

  """
  The network throughput for clients accessing the file system, as a percentage of the provisioned limit.
  """
  networkThroughputUtilization: Metric!

  """The percentage utilization of your file servers CPU resources"""
  cpuUtilization: Metric!

  """The percentage utilization of your file servers memory resources"""
  memoryUtilization: Metric!

  """
  The disk throughput between your file server and its storage volumes, as a percentage of the provisioned limit determined by throughput capacity
  """
  fileServerDiskThroughputUtilization: Metric!

  """
  The percentage of available burst credits for disk throughput between your file server and its storage volumes
  """
  fileServerDiskThroughputBalance: Metric!

  """
  The disk IOPS between your file server and storage volumes, as a percentage of the provisioned limit determined by throughput capacity
  """
  fileServerDiskIopsUtilization: Metric!

  """
  The percentage of available burst credits for disk IOPS between your file server and its storage volumes
  """
  fileServerDiskIopsBalance: Metric!

  """The number of bytes for read operations that access storage volumes"""
  diskReadBytes: Metric!

  """The number of bytes for write operations that access storage volumes"""
  diskWriteBytes: Metric!

  """
  The number of read operations for the file server accessing storage volumes
  """
  diskReadOperations: Metric!

  """
  The number of write operations for the file server accessing storage volumes
  """
  diskWriteOperations: Metric!

  """
  The disk throughput between your le server and its storage volumes, as a percentage of the provisioned limit determined by the storage volumes
  """
  diskThroughputUtilization: Metric!

  """
  The percentage of available burst credits for disk throughput for the storage volumes
  """
  diskThroughputBalance: Metric!

  """
  The disk IOPS between your le server and storage volumes, as a percentage of the provisioned IOPS limit determined by the storage volumes
  """
  diskIopsUtilization: Metric!

  """
  The amount of storage space saved by data deduplication, if it is enabled
  """
  deduplicationSavedStorage: Metric!

  """
  Used physical storage capacity as a percentage of total storage capacity
  """
  storageCapacityUtilization: Metric!

  """
  The total amount of physical data stored on the file system, on both the primary (SSD) tier and the capacity pool tier
  """
  storageUsed: Metric!

  """
  The total amount of logical data stored on the file system, considering both the SSD tier and the capacity pool tier
  """
  logicalDataStored: Metric!

  """The total storage capacity of the primary (SSD) tier"""
  storageCapacity: Metric!

  """
  The sum of total time spent within the file system for read operations (network I/O) from clients accessing data in the volume
  """
  dataReadOperationTime: Metric!

  """
  The sum of total time spent within the file system for fulfilling write operations (network I/O) from clients accessing data in the volume
  """
  dataWriteOperationTime: Metric!

  """
  The sum of total time spent within the file system for fulfilling metadata operations (network I/O) from clients that are accessing data in the volume
  """
  metadataOperationTime: Metric!

  """The used files (number of files or inodes) on the volume"""
  filesUsed: Metric!

  """The total number of inodes that can be created on the volume"""
  filesCapacity: Metric!

  """Amount of storage used"""
  usedStorageCapacity: Metric!

  """Ratio of compressed storage usage to uncompressed storage usage"""
  compressionRatio: Metric!

  """
  Number of calls rejected by NFS server Remote Procedure Call (RPC) mechanism
  """
  nfsBadCalls: Metric!

  """Read throughput Percentage of AWS FSx"""
  percentDataReadThroughput: Metric!

  """Write throughput Percentage of AWS FSx"""
  percentDataWriteThroughput: Metric!

  """Data Read Operations percentage of AWS FSx"""
  percentDataReadOperations: Metric!

  """Data Write Operations percentage of AWS FSx"""
  percentDataWriteOperations: Metric!
}

"""AWS Lambda Entity"""
type AwsLambda implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this lambda function belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Entity resource"""
  resource: String

  """Cloudprovider name"""
  cloudProvider: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """
  This field represents the amount of memory available to the lambda function at runtime
  """
  memorySize: Int

  """
  This field represents the amount of time in seconds that Lambda allows a lambda function to run before stopping it
  """
  timeout: Int

  """This field represents the current status of the lambda function"""
  state: State

  """
  This field represents the status of the last update that was performed on the lambda function
  """
  lastUpdateStatus: String

  """
  This field represents the reason code for the last update that was performed on the lambda function
  """
  lastUpdateStatusReasonCode: String

  """The cloud account id for AWS Lambda entity"""
  cloudAccountId: String

  """The metricsTag of the lambda function"""
  metricTag: String

  """Function version"""
  version: String

  """Relation: lambda functions are triggered by aws s3"""
  triggeringS3Buckets: [AwsS3]

  """The number of times that your function code is invoked."""
  invocations: Metric!

  """The amount of time that your function code spends processing an event."""
  duration: Metric!

  """The number of invocations that result in a function error. """
  errors: Metric!

  """The number of invocation requests that are throttled."""
  throttles: Metric!

  """The number of function instances that are processing events."""
  concurrentExecutions: Metric!

  """
  The number of times that Lambda attempts to send an event to a dead-letter queue but fails.
  """
  deadLetterErrors: Metric!

  """
  The age is the amount of time between when a stream receives the record and when the event source mapping sends the event to the function.
  """
  iteratorAge: Metric!

  """
  For a Region the number of events that functions without reserved concurrency are processing.
  """
  unreservedConcurrentExecutions: Metric!

  """
  The error rate metric is used in health score for AWS Lambda, which sum of errors by sum of innvocations.
  """
  errorRate: Metric!

  """
  The throttle rate metric is used in health score for AWS Lambda, which is sum of throttle by total number of throllet and innvocations.
  """
  throttleRate: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS NAT Gateway"""
type AwsNatGateway implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ALB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """
  State of NAT Gateway(pending | failed | available | deleting | deleted).
  """
  state: State

  """NAT Gateway name"""
  gatewayName: String

  """NAT Gateway Id"""
  natGatewayId: String

  """VPC id in which the NAT Gateway existing."""
  vpcId: String

  """NAT Gateway connectivity type  (private | public)"""
  connectivityType: String

  """The ID of the subnet in which the NAT gateway is located."""
  subnetId: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String

  """
  The cloudaccountId of the cloudAccount to which this NAT gateway belongs.
  """
  cloudAccountId: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """
  The total number of concurrent active TCP connections through the NAT gateway.
  """
  activeConnectionCount: Metric!

  """The number of bytes received by the NAT gateway from the destination."""
  bytesInFromDestination: Metric!

  """
  The number of bytes received by the NAT gateway from clients in your VPC.
  """
  bytesInFromSource: Metric!

  """
  The number of bytes sent out through the NAT gateway to the destination.
  """
  bytesOutToDestination: Metric!

  """
  The number of bytes sent through the NAT gateway to the clients in your VPC.
  """
  bytesOutToSource: Metric!

  """The number of connection attempts made through the NAT gateway."""
  connectionAttemptCount: Metric!

  """The number of connections established through the NAT gateway."""
  connectionEstablishedCount: Metric!

  """The number of times the NAT gateway could not allocate a source port."""
  errorPortAllocation: Metric!

  """
  The number of connections that transitioned from the active state to the idle state. An active connection transitions to idle if it was not closed gracefully and there was no activity for the last 350 seconds.
  """
  idleTimeoutCount: Metric!

  """The number of packets dropped by the NAT gateway."""
  packetsDropCount: Metric!

  """
  The number of packets received by the NAT gateway from the destination.
  """
  packetsInFromDestination: Metric!

  """
  The number of packets received by the NAT gateway from clients in your VPC.
  """
  packetsInFromSource: Metric!

  """
  The number of packets sent out through the NAT gateway to the destination.
  """
  packetsOutToDestination: Metric!

  """
  The number of packets sent through the NAT gateway to the clients in your VPC.
  """
  packetsOutToSource: Metric!

  """Bandwidth of AWS NAT Gateway"""
  bandwidth: Metric!

  """
  The ConnectionEstablishedPercent metric provides percentage of Connection Established count over Connection Attempt Count.
  """
  connectionEstablishedPercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS RDS"""
type AwsRDS implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Unique identifier of an instance."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String!

  """Unique identifier of an instance."""
  dbInstanceIdentifier: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Database Name"""
  dbName: String

  """This field represents the RDS state"""
  state: State

  """The Availability Zone of the instance."""
  availabilityZone: String

  """
  All instances in a database class. For example, we can aggregate metrics for all instances that belong to the database class db.r5.large.
  """
  databaseClass: String

  """A number of instances can be entangled in a cluster. """
  databaseClusterIdentifier: String

  """
  The identified engine name only. For example, we can aggregate metrics for all instances that have the engine name postgres.
  """
  engineName: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """
  Information about an RDS engine version. Example: engineName = "mysql" and versions ="5.7.42"
  """
  engineVersion: String

  """The metricsTag of the volume."""
  metricsTag: String

  """Cloud Account to which this RDS belongs."""
  cloudAccount: CloudAccount

  """AWS Account Number"""
  cloudAccountNumber: String!

  """The amount of disk space occupied by binary logs."""
  binLogDiskUsage: Metric!

  """
  The percent of General Purpose SSD (gp2) burst-bucket I/O credits available.
  """
  burstBalance: Metric!

  """The percentage of CPU utilization."""
  cpuUtilization: Metric!

  """The number of CPU credits spent by the instance for CPU utilization. """
  cpuCreditUsage: Metric!

  """The number of earned CPU credits that an instance has accrued."""
  cpuCreditBalance: Metric!

  """The number of client network connections to the database instance."""
  databaseConnections: Metric!

  """
  The number of outstanding I/Os (read/write requests) waiting to access the disk.
  """
  diskQueueDepth: Metric!

  """
  The number of failed Microsoft SQL Server Agent jobs during the last minute.
  """
  failedSQLServerAgentJobsCount: Metric!

  """The amount of available random access memory."""
  freeableMemory: Metric!

  """The amount of available storage space."""
  freeStorageSpace: Metric!

  """The maximum transaction IDs that have been used."""
  maximumUsedTransactionIDs: Metric!

  """
  The incoming (receive) network traffic on the DB instance, including both customer database traffic and Amazon RDS traffic used for monitoring and replication.
  """
  networkReceiveThroughput: Metric!

  """
  The outgoing (transmit) network traffic on the DB instance, including both customer database traffic and Amazon RDS traffic used for monitoring and replication.
  """
  networkTransmitThroughput: Metric!

  """
  The lagging size of the replica lagging the most in terms of write-ahead log (WAL) data received. Applies to PostgreSQL.
  """
  oldestReplicationSlotLag: Metric!

  """The average number of disk read I/O operations per second."""
  readIOPS: Metric!

  """The average amount of time taken per disk I/O operation."""
  readLatency: Metric!

  """The average number of bytes read from disk per second."""
  readThroughput: Metric!

  """
  For read replica configurations, the amount of time a read replica DB instance lags behind the source DB instance.
  """
  replicaLag: Metric!

  """The disk space used by replication slot files."""
  replicationSlotDiskUsage: Metric!

  """The amount of swap space used on the DB instance."""
  swapUsage: Metric!

  """The disk space used by transaction logs. """
  transactionLogsDiskUsage: Metric!

  """The size of transaction logs generated per second."""
  transactionLogsGeneration: Metric!

  """The average number of disk write I/O operations per second."""
  writeIOPS: Metric!

  """The average amount of time taken per disk I/O operation."""
  writeLatency: Metric!

  """The average number of bytes written to disk per second."""
  writeThroughput: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AwsRegion {
  code: String!
}

"""AWS S3 """
type AwsS3 implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """S3 bucket name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Types of storage."""
  storageType: String

  """Cloud Account to which this S3 bucket belongs."""
  cloudAccount: CloudAccount

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """The amount of data in bytes stored in a bucket."""
  bucketSizeBytes: Metric!

  """
  The total number of objects stored in a bucket for all storage classes.
  """
  numberOfObjects: Metric!

  """The total number of HTTP requests made to an Amazon S3 bucket."""
  allRequests: Metric!

  """
  The number of HTTP 4xx client error status code requests made to an Amazon S3 bucket.
  """
  numberOf4xxErrors: Metric!

  """
  The elapsed per-request time from the first byte received to the last byte sent to an Amazon S3 bucket.
  """
  totalRequestLatency: Metric!

  """
  The maximum number of seconds by which the replication destination Region is behind the source Region for a given replication rule.
  """
  replicationLatency: Metric!

  """
  The number of HTTP GET requests made for objects in an Amazon S3 bucket. This doesn't include list operations.
  """
  getRequests: Metric!

  """
  The number of HTTP PUT requests made for objects in an Amazon S3 bucket.
  """
  putRequests: Metric!

  """
  The number of HTTP DELETE requests made for objects in an Amazon S3 bucket.
  This also includes Delete Multiple Objects requests.
  This metric shows the number of requests, not the number of objects deleted.
  """
  deleteRequests: Metric!

  """The number of HTTP HEAD requests made to an Amazon S3 bucket."""
  headRequests: Metric!

  """The number of HTTP POST requests made to an Amazon S3 bucket."""
  postRequests: Metric!

  """
  The number of Amazon S3 SELECT Object Content requests made for objects in an Amazon S3 bucket.
  """
  selectRequests: Metric!

  """
  The number of bytes of data scanned with Amazon S3 SELECT Object Content requests in an Amazon S3 bucket.
  """
  selectBytesScanned: Metric!

  """
  The number of bytes of data returned with Amazon S3 SELECT Object Content requests in an Amazon S3 bucket.
  """
  selectBytesReturned: Metric!

  """The number of HTTP requests that list the contents of a bucket."""
  listRequests: Metric!

  """
  The number of bytes downloaded for requests made to an Amazon S3 bucket, where the response includes a body.
  """
  bytesDownloaded: Metric!

  """
  The number of bytes uploaded that contain a request body, made to an Amazon S3 bucket.
  """
  bytesUploaded: Metric!

  """
  The number of HTTP 5xx server error status code requests made to an Amazon S3 bucket with a value of either 0 or 1.
  The average statistic shows the error rate, and the sum statistic shows the count of that type of error,
  during each period.
  """
  numberOf5xxErrors: Metric!

  """
  The per-request time from the complete request being received by an Amazon S3 bucket to when the
  response starts to be returned.
  """
  firstByteLatency: Metric!

  """
  The total number of bytes of objects pending replication for a given replication rule.
  """
  bytesPendingReplication: Metric!

  """
  The number of operations pending replication for a given replication rule.
  """
  operationsPendingReplication: Metric!

  """The total provisioned capacity in bytes for an Outpost."""
  outpostTotalBytes: Metric!

  """
  The count of free bytes available on an Outpost to store customer data.
  """
  outpostFreeBytes: Metric!

  """The total size of all objects for the given bucket."""
  bucketUsedBytes: Metric!

  """The total size of all objects for the specified Outposts account."""
  accountUsedBytes: Metric!

  """Percentage of 5xx request against all requests to S3 bucket."""
  rateOf5xxError: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AwsService {
  id: String!
}

"""AWS SNS entities for Topic"""
type AwsSNSTopic implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """SNS Topic name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ALB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """Cloud provider Name."""
  cloudProvider: String!

  """
  The cloudaccountId of the cloudAccount to which this SNS Topic belongs.
  """
  cloudAccountId: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """ARN of SNS Topic."""
  topicARN: String

  """Cloud Account ID who owns SNS service."""
  owner: String

  """The number of confirmed subscriptions for the topic."""
  subscriptionsConfirmed: Int

  """The number of deleted subscriptions for the topic."""
  subscriptionsDeleted: Int

  """The number of subscriptions pending confirmation for the topic."""
  subscriptionsPending: Int

  """The number of messages published to your Amazon SNS topics."""
  numberOfMessagesPublished: Metric!

  """
  The number of messages successfully delivered from your Amazon SNS topics to subscribing endpoints.
  """
  numberOfNotificationsDelivered: Metric!

  """The number of messages that Amazon SNS failed to deliver."""
  numberOfNotificationsFailed: Metric!

  """
  The number of messages that were rejected by subscription filter policies.
  """
  numberOfNotificationsFilteredOut: Metric!

  """
  The number of messages that were rejected by subscription filter policies because the messages' attributes are invalid  for example, because the attribute JSON is incorrectly formatted.
  """
  numberOfNotificationsFilteredOutInvalidAttributes: Metric!

  """
  The number of messages that were rejected by subscription filter policies because the messages have no attributes.
  """
  numberOfNotificationsFilteredOutNoMessageAttributes: Metric!

  """The number of messages that have been moved to a dead-letter queue."""
  numberOfNotificationsRedrivenToDlq: Metric!

  """The number of messages that couldn't be moved to a dead-letter queue."""
  numberOfNotificationsFailedToRedriveToDlq: Metric!

  """The size of messages published."""
  publishSize: Metric!

  """
  The TopicSuccessRate metric provides percentage of messages sent successfully
  """
  notificationSuccessRate: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS Simple Queue Service"""
type AwsSQS implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """SQS Queue name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ALB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Resource Type Name eg: EC2, ElasticBeanstalk"""
  resourceType: String!

  """Cloud provider Name."""
  cloudProvider: String!

  """
  The cloudaccountId of the cloudAccount to which this SQS Topic belongs.
  """
  cloudAccountId: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """The time when the queue was created in seconds."""
  createdTimestamp: String

  """The default delay on the queue in seconds."""
  delaySeconds: Int

  """The time when the queue was last changed in seconds."""
  lastModifiedTimestamp: String

  """
  The limit of how many bytes a message can contain before Amazon SQS rejects it.
  """
  maximumMessageSize: Int

  """
  The length of time, in seconds, for which Amazon SQS retains a message.
  """
  messageRetentionPeriod: Int

  """The Amazon resource name (ARN) of the queue."""
  queueArn: String

  """
  The length of time, in seconds, for which the ReceiveMessage action waits for a message to arrive.
  """
  receiveMessageWaitTimeSeconds: Int

  """The visibility timeout for the queue."""
  visibilityTimeout: Int

  """The approximate age of the oldest non-deleted message in the queue."""
  approximateAgeOfOldestMessage: Metric!

  """
  The number of messages in the queue that are delayed and not available for reading immediately.
  """
  approximateNumberOfMessagesDelayed: Metric!

  """The number of messages that are in flight."""
  approximateNumberOfMessagesNotVisible: Metric!

  """The number of messages available for retrieval from the queue."""
  approximateNumberOfMessagesVisible: Metric!

  """The number of ReceiveMessage API calls that did not return a message."""
  numberOfEmptyReceives: Metric!

  """The number of messages deleted from the queue."""
  numberOfMessagesDeleted: Metric!

  """The number of messages returned by calls to the ReceiveMessage action."""
  numberOfMessagesReceived: Metric!

  """The number of messages added to a queue."""
  numberOfMessagesSent: Metric!

  """The size of messages added to a queue."""
  sentMessageSize: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AwsTestConnectionResult {
  success: Boolean!
  errorMessage: String
}

"""AWS Transfer Family"""
type AwsTransferFamily implements Entity & HealthEntity & StatefulEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this Family Transfer belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """
  State of Transfer Family(OFFLINE | ONLINE | STARTING | STOPPING | START_FAILED | STOP_FAILED).
  """
  state: State

  """
  Specifies the unique system assigned identifier for the servers that were listed
  """
  serverId: String

  """
  Specifies the domain of the storage system that is used for file transfers
  """
  domain: String

  """Specifies the type of VPC endpoint that your server is connected to"""
  endpointType: String

  """The mode of authentication for a server"""
  identityProviderType: String

  """
  Specifies the number of users that are assigned to a server you specified with the ServerId
  """
  userCount: Int

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String!

  """Event Source as seen in logs eg: transfer.amazonaws.com"""
  eventSource: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """The total number of bytes transferred into the server"""
  bytesIn: Metric!

  """The total number of bytes transferred out of the server"""
  bytesOut: Metric!

  """The total number of files transferred into the server"""
  filesIn: Metric!

  """The total number of files transferred out of the"""
  filesOut: Metric!

  """The total number of workflow executions started on the server"""
  onUploadExecutionsStarted: Metric!

  """The total number of successful workflow executions on the server"""
  onUploadExecutionsSuccess: Metric!

  """The total number of unsuccessful workflow executions on the server"""
  onUploadExecutionsFailed: Metric!

  """
  The total number of on-partial-upload workflow executions started on the server
  """
  onPartialUploadExecutionsStarted: Metric!

  """
  The total number of successful, on-partial-upload workflow executions on the server
  """
  onPartialUploadExecutionsSuccess: Metric!

  """
  The total number of unsuccessful, on-partial-upload workflow executions on the server
  """
  onPartialUploadExecutionsFailed: Metric!

  """
  The bytesOutPercentage metrics provides percentage of bytesOut over bytesIn
  """
  bytesOutPercentage: Metric!

  """
  The filesOutPercentage metrics provides percentage of filesOut over filesIn.
  """
  filesOutPercentage: Metric!
}

"""AWS Transit Gateway"""
type AwsTransitGateway implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ALB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """
  State of Transit Gateway(pending | available | modifying | deleting | deleted).
  """
  state: State

  """Transit Gateway name"""
  gatewayName: String

  """Transit Gateway Id"""
  transitGatewayId: String!

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """The ID of the AWS account that owns the transit gateway."""
  ownerId: String

  """Indicates whether DNS support is enabled."""
  dnsSupport: String

  """Indicates whether multicast is enabled on the transit gateway."""
  multicastSupport: String

  """Indicates whether Equal Cost Multipath Protocol support is enabled."""
  vpnEcmpSupport: String

  """The ID of the default propagation route table."""
  propagationDefaultRouteTableId: String

  """The ID of the Transit attachment."""
  transitGatewayAttachmentId: String

  """The Name of the Transit attachment."""
  transitGatewayAttachmentName: String

  """The ID of the resource."""
  resourceId: String

  """The ID of the AWS account that owns the resource."""
  resourceOwnerId: String

  """
  The resource type (vpc | vpn | direct-connect-gateway | connect | peering | tgw-peering).
  """
  resourceType: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String

  """
  The cloudaccountId of the cloudAccount to which this Transit gateway belongs.
  """
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """
  The number of bytes dropped because they matched a blackhole route on the transit gateway attachment.
  """
  bytesDropCountBlackhole: Metric!

  """
  The number of bytes dropped because they did not match a route on the transit gateway attachment.
  """
  bytesDropCountNoRoute: Metric!

  """
  The number of bytes received by the transit gateway from the attachment.
  """
  bytesIn: Metric!

  """The number of bytes sent from the transit gateway to the attachment."""
  bytesOut: Metric!

  """
  The number of packets received by the transit gateway from the attachment.
  """
  packetsIn: Metric!

  """The number of packets sent by the transit gateway to the attachment."""
  packetsOut: Metric!

  """
  The number of packets dropped because they matched a blackhole route on the transit gateway attachment.
  """
  packetDropCountBlackhole: Metric!

  """
  The number of packets dropped because they did not match a route on the transit gateway attachment.
  """
  packetDropCountNoRoute: Metric!

  """
  The BytesDropPercentage metric provides percentage of Bytes Drop over Bytes In
  """
  bytesDropPercentage: Metric!

  """
  The PacketsDropPercentage metric provides percentage of packets Drop over packets in
  """
  packetsDropPercentage: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AWS VPN (Virtual Private Network)"""
type AwsVPN implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to name unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this ALB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """
  The current state of the VPN connection (pending | available | deleting | deleted).
  """
  state: State

  """VPN name"""
  vpnName: String

  """VPN Id"""
  vpnId: String!

  """
  The category of the VPN connection. A value of VPN indicates an AWS VPN connection. A value of VPN-Classic indicates an AWS Classic VPN connection.
  """
  vpnCategory: String

  """The ID of the customer gateway at your end of the VPN connection."""
  customerGatewayId: String

  """
  The current state of the gateway association (associated | not-associated | associating | disassociating).
  """
  gatewayAssociationState: String

  """The type of VPN connection(ipsec.1)."""
  vpnConnectionType: String

  """The ID of the transit gateway associated with the VPN connection."""
  transitGatewayId: String

  """
  The ID of the virtual private gateway at the AWS side of the VPN connection.
  """
  vpnGatewayId: String

  """
  The current state of the VPC attachment to the virtual private gateway(attaching | attached | detaching | detached).
  """
  vpcAttachmentState: String

  """The ID of the VPC attached to the virtual private gateway."""
  vpcId: String

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """Cloud provider Name"""
  cloudProvider: String

  """The cloudaccountId of the cloudAccount to which this AWS VPN  belongs."""
  cloudAccountId: String!

  """AWS Account Number"""
  cloudAccountNumber: String!

  """
  The state of the tunnels. For static VPNs, 0 indicates DOWN and 1 indicates UP. For BGP VPNs, 1 indicates ESTABLISHED and 0 is used for all other states. For both types of VPNs, values between 0 and 1 indicate at least one tunnel is not UP
  """
  tunnelState: Metric!

  """
  The bytes received on the AWS side of the connection through the VPN tunnel from a customer gateway.Each metric data point represents the number of bytes received after the previous data point.
  """
  tunnelDataIn: Metric!

  """
  The bytes sent from the AWS side of the connection through the VPN tunnel to the customer gateway. Each metric data point represents the number of bytes sent after the previous data point.
  """
  tunnelDataOut: Metric!

  """
  The tunnelDataOutPercent metric is used in health score for AWS VPN, which is sum of tunnelDataOut by tunnelDataIn.
  """
  tunnelDataOutPercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure App Service"""
type AzureAppService implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """App Service name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this app service belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Azure App Service Type """
  kind: String

  """Azure App Service resourceId"""
  resourceId: String!

  """Azure App Service instance"""
  instance: String

  """Name of the cloud provider for filtering purpose"""
  cloudProvider: String

  """The cloud account id for Azure function entity"""
  cloudAccountId: String

  """The metricsTag of the Azure function"""
  metricTag: String

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """The amount of CPU consumed by the app, in seconds"""
  cpuTime: Metric!

  """The amount of incoming bandwidth consumed by the app in MiB.  """
  bytesReceived: Metric!

  """The amount of outgoing bandwidth consumed by the app in MiB. """
  bytesSent: Metric!

  """
  The current number of Assemblies loaded across all AppDomains in this application.
  """
  currentAssemblies: Metric!

  """
  The number of times the generation 0 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  """
  gen0Collections: Metric!

  """
  The number of times the generation 1 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  """
  gen1Collections: Metric!

  """
  The number of times the generation 2 objects are garbage collected since the start of the app process.
  """
  gen2Collections: Metric!

  """
  The count of requests resulting in an HTTP status code = 500 but < 600. 
  The average statistic shows the error rate and the sum statistic shows the count of that type of error during each period.
  """
  http5xx: Metric!

  """
  The rate at which the app process is issuing bytes to I/O operations that don't involve data such as controls operations.
  """
  ioOtherBytesPerSecond: Metric!

  """
  The rate at which the app process is issuing I/O operations that aren't read or write operations. 
  """
  ioOtherOperationsPerSecond: Metric!

  """
  The rate at which the app process is reading bytes from I/O operations.
  """
  ioReadBytesPerSecond: Metric!

  """The rate at which the app process is issuing read I/O operations."""
  ioReadOperationsPerSecond: Metric!

  """The rate at which the app process is writing bytes to I/O operations. """
  ioWriteBytesPerSecond: Metric!

  """The rate at which the app process is issuing write I/O operations."""
  ioWriteOperationsPerSecond: Metric!

  """The current amount of memory used by the app in MiB. """
  memoryWorkingSet: Metric!

  """
  Private Bytes is the current size in bytes of memory that the app process has allocated that can't be shared with other processes.
  """
  privateBytes: Metric!

  """
  The total number of requests regardless of their resulting HTTP status code.
  """
  requests: Metric!

  """The number of requests in the application request queue."""
  requestsInApplicationQueue: Metric!

  """The current number of AppDomains loaded in this application."""
  totalAppDomains: Metric!

  """
  The total number of AppDomains unloaded since the start of the application. 
  """
  totalAppDomainsUnloaded: Metric!

  """The average time taken for the app to serve requests, in seconds.  """
  averageResponseTime: Metric!

  """
  The count of requests resulting in an HTTP status code = 200 but < 300. 
  """
  http2xx: Metric!

  """
  The count of requests resulting in an HTTP status code = 400 but < 500.  
  """
  http4xx: Metric!

  """The number of bound sockets existing in the sandbox."""
  appConnections: Metric!

  """The average amount of memory used by the app, in megabytes (MiB)"""
  averageMemoryWorkingSet: Metric!

  """The total number of handles currently open by the app process. """
  handles: Metric!

  """The count of requests resulting in an HTTP status code 101."""
  http101: Metric!

  """
  The count of requests resulting in an HTTP status code = 300 but < 400.
  """
  http3xx: Metric!

  """The count of requests resulting in HTTP 401 status code."""
  http401: Metric!

  """The count of requests resulting in HTTP 403 status code."""
  http403: Metric!

  """The count of requests resulting in HTTP 404 status code. """
  http404: Metric!

  """The count of requests resulting in HTTP 406 status code."""
  http406: Metric!

  """The number of threads currently active in the app process."""
  threads: Metric!

  """5xx Error Rate"""
  errorRate5xx: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure Blob Storage"""
type AzureBlobStorage implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Name of Azure Storage."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """Relation: Cloud Account to which this lambda function belongs"""
  cloudAccount: CloudAccount

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Azure Blob Storage resourceId"""
  resourceId: String!

  """Cloud provider Name"""
  cloudProvider: String

  """Azure Storage Type (Blob, File, Queue, Table)"""
  storageType: String

  """The amount of data in bytes stored in a bucket."""
  bucketSizeBytes: Metric!

  """
  The total number of objects stored in a bucket for all storage classes.
  """
  numberOfObjects: Metric!

  """The total number of HTTP requests made to an Azure Storage."""
  allRequests: Metric!

  """
  The number of bytes downloaded for requests made to an Azure Storage, where the response includes a body.
  """
  bytesDownloaded: Metric!

  """
  The number of bytes uploaded that contain a request body, made to an Azure Storage.
  """
  bytesUploaded: Metric!

  """
  The percentage of availability for the storage service or the specified API operation.
  All unexpected errors result in reduced availability for the storage service or the specified API operation
  """
  availbility: Metric!

  """
  The average end-to-end latency of successful requests made to a storage service or the specified API operation.
  """
  successE2ELatency: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure CDN entity"""
type AzureCdn implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Front Door - CDN name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """
  Azure CDN/Front Door (Standard|Premium tier) type - 'cdn' | 'frontdoor'
  """
  kind: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """The current status of Azure CDN entity."""
  state: State

  """Cloud provider Name"""
  cloudProvider: String!

  """TenantID"""
  tenantID: String!

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this CDN resource belongs."""
  cloudAccount: CloudAccount

  """The number of client requests served by the HTTP/S proxy"""
  requestCount: Metric!

  """
  The time calculated from when the client request was received by the HTTP/S proxy until the client acknowledged the last response byte from the HTTP/S proxy
  """
  totalLatency: Metric!

  """
  The number of client requests processed by the Web Application Firewall
  """
  webApplicationFirewallRequestCount: Metric!

  """The number of requests sent from AFDX to origin"""
  originRequestCount: Metric!

  """
  The time calculated from when the request was sent by AFDX edge to the backend until AFDX received the last response byte from the backend
  """
  originLatency: Metric!

  """The percentage of successful health probes from AFDX to backends"""
  originHealthPercentage: Metric!

  """
  The percentage of all the client requests for which the response status code is 4XX
  """
  percentage4XX: Metric!

  """
  The percentage of all the client requests for which the response status code is 5XX
  """
  percentage5XX: Metric!

  """The number of bytes sent as requests from clients to AFDX"""
  requestSize: Metric!

  """The number of bytes sent as responses from HTTP/S proxy to clients"""
  responseSize: Metric!

  """
  This is the ratio of the total bytes served from the cache compared to the total response bytes
  """
  byteHitRatio: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AzureCloudAccount {
  entityId: ID!
  displayName: String!
  configuration: AzureCloudAccountConfiguration
}

type AzureCloudAccountConfiguration implements CloudAccountConfigurationInterface {
  metricsTag: String
  enabled: Boolean!
  tenantId: String!
  clientId: String
  subscriptions: [AzureSubscription!]!
}

input AzureCloudAccountConfigurationInput {
  metricsTag: String!
  subscriptions: [AzureSubscriptionInput!]!
}

"""Azure Cosmos DB"""
type AzureCosmosDb implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Cosmos DB name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this Azure Cosmos DB belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Azure Cosmos DB resourceId"""
  resourceId: String!

  """Name of the cloud provider for filtering purpose"""
  cloudProvider: String

  """The cloud account id for Azure Cosmos DB entity"""
  cloudAccountId: String

  """The metricsTag of the Azure Cosmos DB"""
  metricTag: String

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """The amount of storage available."""
  availableStorage: Metric!

  """
  Number of Cassandra connections that were closed reported at a 1 minute granularity.
  """
  cassandraConnectionClosures: Metric!

  """RUs consumed for Cassandra requests made.  """
  cassandraRequestCharges: Metric!

  """Number of Cassandra requests made. """
  cassandraRequests: Metric!

  """Total data usage reported at 5 minutes granularity."""
  dataUsage: Metric!

  """
  Total document count reported at 5 minutes, 1 hour and 1 day granularity.
  """
  documentCount: Metric!

  """Total storage quota reported at 5 minutes granularity."""
  documentQuota: Metric!

  """Total index usage reported at 5 minutes granularity."""
  indexUsage: Metric!

  """
  Count of metadata requests. Cosmos DB maintains system metadata collection for each account, that allows you to enumerate collections, databases,etc.
  """
  metadataRequests: Metric!

  """Mongo Request Units Consumed."""
  mongoRequestCharge: Metric!

  """Number of Mongo Requests Made. """
  mongoRequests: Metric!

  """Provisioned Throughput."""
  provisionedThroughput: Metric!

  """
  P99 Replication Latency across source and target regions for geo-enabled account.
  """
  replicationLatencyP99: Metric!

  """
  Account requests availability at one hour or day or month granularity. 
  """
  serviceAvailability: Metric!

  """Request Units consumed."""
  totalRequestUnits: Metric!

  """Number of requests made. """
  totalRequests: Metric!

  """Autoscale Max Throughput. """
  autoscaleMaxThroughput: Metric!

  """Cassandra Connector Average ReplicationLatency. """
  cassandraConnectorAvgReplicationLatency: Metric!

  """Cassandra Connector Replication Health Status. """
  cassandraConnectorReplicationHealthStatus: Metric!

  """Request Units consumed for Gremlin requests made. """
  gremlinRequestCharges: Metric!

  """Number of Gremlin requests made. """
  gremlinRequests: Metric!

  """Max RU consumption percentage per minute. """
  normalizedRUConsumption: Metric!

  """Server Side Latency. """
  serverSideLatency: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

input AzureCredentialInput {
  clientId: String!
  tenantId: String!
  clientSecret: String!
}

"""Add Entity description here"""
type AzureDatabasesName implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Azure resourceId"""
  resourceId: String

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this entity belongs."""
  cloudAccount: CloudAccount

  """Database's server name"""
  databaseServer: String

  """Database ID"""
  databaseId: String

  """Database Edition"""
  databaseEdition: String

  """Elastic pool name"""
  elasticPoolName: String

  """Containment state of the database"""
  containmentState: String

  """Max size of the the database"""
  maxSizeBytes: String

  """Allocated data storage. Not applicable to data warehouses."""
  allocatedDataStorage: Metric!

  """Blocked by Firewall"""
  blockedByFirewall: Metric!

  """Failed Connections"""
  connectionFailed: Metric!

  """Successful Connections"""
  connectionSuccessful: Metric!

  """CPU percentage"""
  cpuPercent: Metric!

  """Deadlocks. Not applicable to data warehouses."""
  deadlock: Metric!

  """DTU Percentage. Applies to DTU-based databases."""
  dtuConsumptionPercent: Metric!

  """DTU Limit. Applies to DTU-based databases."""
  dtuLimit: Metric!

  """DTU used. Applies to DTU-based databases."""
  dtuUsed: Metric!

  """Log IO percentage. Not applicable to data warehouses."""
  logWritePercent: Metric!

  """Data IO percentage"""
  physicalDataReadPercent: Metric!

  """Sessions percentage. Not applicable to data warehouses."""
  sessionsPercent: Metric!

  """Data space used. Not applicable to data warehouses."""
  storage: Metric!

  """
  Data space used percent. Not applicable to data warehouses or hyperscale databases.
  """
  storagePercent: Metric!

  """Workers percentage. Not applicable to data warehouses."""
  workersPercent: Metric!

  """In-Memory OLTP storage percent. Not applicable to data warehouses."""
  xtpStoragePercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure Event Hubs entity"""
type AzureEventHubs implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Event Hubs name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """The current status of Azure Eventhubs Namespace entity."""
  state: State

  """Cloud provider Name"""
  cloudProvider: String

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this Event Hubs belongs."""
  cloudAccount: CloudAccount

  """Total Active Connections for Microsoft.EventHub."""
  activeConnections: Metric!

  """Capture Backlog for Microsoft.EventHub."""
  captureBacklog: Metric!

  """Captured Bytes for Microsoft.EventHub."""
  capturedBytes: Metric!

  """Captured Messages for Microsoft.EventHub."""
  capturedMessages: Metric!

  """Connections Closed for Microsoft.EventHub."""
  connectionsClosed: Metric!

  """Connections Opened for Microsoft.EventHub."""
  connectionsOpened: Metric!

  """Incoming Bytes for Microsoft.EventHub."""
  incomingBytes: Metric!

  """Incoming Messages for Microsoft.EventHub."""
  incomingMessages: Metric!

  """Incoming Requests for Microsoft.EventHub."""
  incomingRequests: Metric!

  """CPU usage metric for Premium SKU namespaces."""
  namespaceCpuUsage: Metric!

  """Memory usage metric for Premium SKU namespaces."""
  namespaceMemoryUsage: Metric!

  """Outgoing Bytes for Microsoft.EventHub."""
  outgoingBytes: Metric!

  """Outgoing Messages for Microsoft.EventHub."""
  outgoingMessages: Metric!

  """Quota Exceeded Errors for Microsoft.EventHub."""
  quotaExceededErrors: Metric!

  """Server Errors for Microsoft.EventHub."""
  serverErrors: Metric!

  """Size of an EventHub in Bytes."""
  size: Metric!

  """Successful Requests for Microsoft.EventHub."""
  successfulRequests: Metric!

  """Throttled Requests for Microsoft.EventHub."""
  throttledRequests: Metric!

  """User Errors for Microsoft.EventHub."""
  userErrors: Metric!

  """
  The serverErrorsPercent metric provides percentage of requests that errored out over incoming requests.
  """
  serverErrorsPercent: Metric!

  """
  The successfulRequestsPercent metric provides percentage of requests that are successful over incoming requests.
  """
  successfulRequestsPercent: Metric!

  """
  The throttledRequestsPercent metric provides percentage of requests that are throttled over incoming requests.
  """
  throttledRequestsPercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""AZURE FILES """
type AzureFiles implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Name of the Azure Storage."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """Relation: Cloud Account to which this lambda function belongs"""
  cloudAccount: CloudAccount

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Azure Files resourceId"""
  resourceId: String!

  """The cloud account id for Azure Files entity"""
  cloudAccountId: String

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String

  """Azure Storage Type (Blob, File, Queue, Table)"""
  storageType: String

  """
  Metric Shows the percentage of availability for the storage service or the specified API operation.
  """
  availability: Metric!

  """Metric Shows the amount of egress data, in bytes."""
  egress: Metric!

  """
  The amount of storage used by the storage account's File service in bytes.
  """
  fileCapacity: Metric!

  """The number of file in the storage account's File service."""
  fileCount: Metric!

  """The number of file shares in the storage account's File service."""
  fileShareCount: Metric!

  """
  The upper limit on the amount of storage that can be used by Azure Files Service in bytes.
  """
  fileShareQuotaSize: Metric!

  """
  The number of snapshots present on the share in storage account's Files Service.
  """
  fileShareSnapshotCount: Metric!

  """
  The amount of storage used by the snapshots in storage account's File service in bytes.
  """
  fileShareSnapshotSize: Metric!

  """The amount of ingress data, in bytes. """
  ingress: Metric!

  """
  The end-to-end latency of successful requests made to a storage service or the specified API operation, in milliseconds. 
  """
  successE2ELatency: Metric!

  """
  The latency used by Azure Storage to process a successful request, in milliseconds.
  """
  successServerLatency: Metric!

  """
  The number of requests made to a storage service or the specified API operation.
  """
  transactions: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure Front Door entity"""
type AzureFrontDoor implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Front Door - CDN name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """The current status of Azure FrontDoor entity."""
  state: State

  """Cloud provider Name"""
  cloudProvider: String!

  """TenantID"""
  tenantID: String!

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this Front Door resource belongs."""
  cloudAccount: CloudAccount

  """The number of client requests served by the HTTP/S proxy"""
  requestCount: Metric!

  """
  The time calculated from when the client request was received by the HTTP/S proxy until the client acknowledged the last response byte from the HTTP/S proxy
  """
  totalLatency: Metric!

  """
  The number of client requests processed by the Web Application Firewall
  """
  webApplicationFirewallRequestCount: Metric!

  """The number of bytes sent as requests from clients to the HTTP/S proxy"""
  requestSize: Metric!

  """The number of bytes sent as responses from HTTP/S proxy to clients"""
  responseSize: Metric!

  """The number of requests sent from the HTTP/S proxy to backends"""
  backendRequestCount: Metric!

  """
  The time calculated from when the request was sent by the HTTP/S proxy to the backend until the HTTP/S proxy received the last response byte from the backend
  """
  backendRequestLatency: Metric!

  """
  The percentage of successful health probes from the HTTP/S proxy to backends
  """
  backendHealthPercentage: Metric!

  """
  The number of billable bytes (minimum 2KB per request) sent as responses from HTTP/S proxy to clients
  """
  billableResponseSize: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure Function"""
type AzureFunction implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Function name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Azure function app host name"""
  hostName: String

  """Azure function app state"""
  state: State

  """Azure function redundancy mode"""
  redundancyMode: String

  """Azure function kind"""
  kind: String

  """Azure function windows version"""
  windowsFxVersion: String

  """Azure function linux version"""
  linuxFxVersion: String

  """Azure function node version"""
  nodeVersion: String

  """Azure function php version"""
  phpVersion: String

  """Azure function python version"""
  pythonVersion: String

  """Azure function java version"""
  javaVersion: String

  """Azure function power shell version"""
  powerShellVersion: String

  """Azure function net framework version"""
  netFrameworkVersion: String

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Cloud Account to which this lambda function belongs"""
  cloudAccount: CloudAccount
  healthScore: HealthScore

  """Azure Function resourceId"""
  resourceId: String!

  """Name of the cloud provider for filtering purpose"""
  cloudProvider: String

  """The cloud account id for Azure function entity"""
  cloudAccountId: String

  """The metricsTag of the Azure function"""
  metricTag: String

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Function Execution Count. For FunctionApps only."""
  functionExecutionCount: Metric!

  """The average amount of memory used by the app in megabytes (MiB)."""
  averageMemoryWorkingSet: Metric!

  """The amount of incoming bandwidth consumed by the app in MiB.  """
  bytesReceived: Metric!

  """The amount of outgoing bandwidth consumed by the app in MiB. """
  bytesSent: Metric!

  """
  The current number of Assemblies loaded across all AppDomains in this application.
  """
  currentAssemblies: Metric!

  """
  The number of times the generation 0 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  """
  gen0Collections: Metric!

  """
  The number of times the generation 1 objects are garbage collected since the start of the app process. Higher generation GCs include all lower generation GCs.
  """
  gen1Collections: Metric!

  """
  The number of times the generation 2 objects are garbage collected since the start of the app process.
  """
  gen2Collections: Metric!

  """
  The count of requests resulting in an HTTP status code = 500 but < 600. 
  The average statistic shows the error rate and the sum statistic shows the count of that type of error during each period.
  """
  http5xx: Metric!

  """
  The rate at which the app process is issuing bytes to I/O operations that don't involve data such as controls operations.
  """
  ioOtherBytesPerSecond: Metric!

  """
  The rate at which the app process is issuing I/O operations that aren't read or write operations. 
  """
  ioOtherOperationsPerSecond: Metric!

  """
  The rate at which the app process is reading bytes from I/O operations.
  """
  ioReadBytesPerSecond: Metric!

  """The rate at which the app process is issuing read I/O operations."""
  ioReadOperationsPerSecond: Metric!

  """The rate at which the app process is writing bytes to I/O operations. """
  ioWriteBytesPerSecond: Metric!

  """The rate at which the app process is issuing write I/O operations."""
  ioWriteOperationsPerSecond: Metric!

  """The current amount of memory used by the app in MiB. """
  memoryWorkingSet: Metric!

  """
  Private Bytes is the current size in bytes of memory that the app process has allocated that can't be shared with other processes.
  """
  privateBytes: Metric!

  """
  The total number of requests regardless of their resulting HTTP status code.
  """
  requests: Metric!

  """The number of requests in the application request queue."""
  requestsInApplicationQueue: Metric!

  """The current number of AppDomains loaded in this application."""
  totalAppDomains: Metric!

  """
  The total number of AppDomains unloaded since the start of the application. 
  """
  totalAppDomainsUnloaded: Metric!

  """The average time taken for the app to serve requests, in seconds.  """
  averageResponseTime: Metric!

  """
  The count of requests resulting in an HTTP status code = 200 but < 300. 
  """
  http2xx: Metric!

  """
  The count of requests resulting in an HTTP status code = 400 but < 500.  
  """
  http4xx: Metric!

  """Function Execution unit. For FunctionApps only."""
  functionExecutionUnit: Metric!

  """5xx Error Rate"""
  functionErrorRate5xx: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure Key Vault entity"""
type AzureKeyVault implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Key Vault name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this key vault belongs."""
  cloudAccount: CloudAccount

  """Number of total service api hits"""
  hit: Metric!

  """Overall latency of service api requests"""
  latency: Metric!

  """Number of total service api results"""
  result: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AzureRegion {
  id: String!
  enabled: Boolean!
}

input AzureRegionInput {
  id: String!
  enabled: Boolean!
}

type AzureResourceType {
  typeName: String!
  displayName: String!
  enabled: Boolean!
}

input AzureResourceTypeInput {
  typeName: String!
  displayName: String!
  enabled: Boolean!
}

"""Azure Service Bus Entity"""
type AzureServiceBus implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Entity name"""
  name: String

  """Azure Service Bus Queue Names"""
  queueNames: String

  """Azure Service Bus Topic Names"""
  topicNames: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """The current status of Azure Service Bus entity."""
  state: State

  """Cloud provider Name"""
  cloudProvider: String

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this entity belongs."""
  cloudAccount: CloudAccount

  """Abandoned Messages"""
  abandonMessage: Metric!

  """Total Active Connections for Microsoft.ServiceBus."""
  activeConnections: Metric!

  """Count of active messages in a Queue/Topic."""
  activeMessages: Metric!

  """Completed Messages"""
  completeMessage: Metric!

  """Connections Closed for Microsoft.ServiceBus."""
  connectionsClosed: Metric!

  """Connections Opened for Microsoft.ServiceBus."""
  connectionsOpened: Metric!

  """Count of dead-lettered messages in a Queue/Topic."""
  deadletteredMessages: Metric!

  """Incoming Messages for Microsoft.ServiceBus."""
  incomingMessages: Metric!

  """Incoming Requests for Microsoft.ServiceBus."""
  incomingRequests: Metric!

  """Count of messages in a Queue/Topic."""
  messages: Metric!

  """Outgoing Messages for Microsoft.ServiceBus."""
  outgoingMessages: Metric!

  """Pending Checkpoint Operations Count."""
  pendingCheckpointOperationCount: Metric!

  """Count of scheduled messages in a Queue/Topic."""
  scheduledMessages: Metric!

  """Server Errors for Microsoft.ServiceBus."""
  serverErrors: Metric!

  """Server Send Latency."""
  serverSendLatency: Metric!

  """Size of an Queue/Topic in Bytes."""
  size: Metric!

  """Total successful requests for a namespace"""
  successfulRequests: Metric!

  """Throttled Requests for Microsoft.ServiceBus."""
  throttledRequests: Metric!

  """User Errors for Microsoft.ServiceBus."""
  userErrors: Metric!

  """CPU usage metric for Premium SKU namespaces."""
  namespaceCpuUsage: Metric!

  """Memory usage metric for Premium SKU namespaces."""
  namespaceMemoryUsage: Metric!

  """
  The serverErrorsPercent metric provides percentage of requests that errored out over incoming requests.
  """
  serverErrorsPercent: Metric!

  """
  The successfulRequestsPercent metric provides percentage of requests that are successful over incoming requests.
  """
  successfulRequestsPercent: Metric!

  """
  The throttledRequestsPercent metric provides percentage of requests that are throttled over incoming requests.
  """
  throttledRequestsPercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Add Entity description here"""
type AzureSqlDatabase implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """Cloud Account to which this entity belongs."""
  cloudAccount: CloudAccount

  """Database's server name"""
  databaseServer: String

  """Database ID"""
  databaseId: String

  """Database Edition"""
  databaseEdition: String

  """Elastic pool name"""
  elasticPoolName: String

  """Containment state of the database"""
  containmentState: String

  """Max size of the the database"""
  maxSizeBytes: String

  """Allocated data storage. Not applicable to data warehouses."""
  allocatedDataStorage: Metric!

  """Blocked by Firewall"""
  blockedByFirewall: Metric!

  """Failed Connections"""
  connectionFailed: Metric!

  """Successful Connections"""
  connectionSuccessful: Metric!

  """CPU percentage"""
  cpuPercent: Metric!

  """Deadlocks. Not applicable to data warehouses."""
  deadlock: Metric!

  """DTU Percentage. Applies to DTU-based databases."""
  dtuConsumptionPercent: Metric!

  """DTU Limit. Applies to DTU-based databases."""
  dtuLimit: Metric!

  """DTU used. Applies to DTU-based databases."""
  dtuUsed: Metric!

  """Log IO percentage. Not applicable to data warehouses."""
  logWritePercent: Metric!

  """Data IO percentage"""
  physicalDataReadPercent: Metric!

  """Sessions percentage. Not applicable to data warehouses."""
  sessionsPercent: Metric!

  """Data space used. Not applicable to data warehouses."""
  storage: Metric!

  """
  Data space used percent. Not applicable to data warehouses or hyperscale databases.
  """
  storagePercent: Metric!

  """Workers percentage. Not applicable to data warehouses."""
  workersPercent: Metric!

  """In-Memory OLTP storage percent. Not applicable to data warehouses."""
  xtpStoragePercent: Metric!

  """Connection failure rate"""
  rateOfConnectionFailure: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type AzureSubscription {
  id: String!
  displayName: String!
  enabled: Boolean!
  regions: [AzureRegion!]
  resourceTypes: [AzureResourceType!]
}

input AzureSubscriptionInput {
  id: String!
  displayName: String!
  enabled: Boolean!
  regions: [AzureRegionInput!]
  resourceTypes: [AzureResourceTypeInput!]
}

"""Azure VirtualMachine ScaleSet"""
type AzureVirtualMachineScaleSet implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Azure Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """Cloud provider Name"""
  cloudProvider: String!

  """TenantID"""
  tenantID: String!

  """Azure resourceId"""
  resourceId: String!

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String

  """This field represents the VMSS state"""
  state: State

  """Cloud Account to which this entity belongs."""
  cloudAccount: CloudAccount

  """
  Amount of physical memory, in bytes, immediately available for allocation to a process or for system use in the Virtual Machine
  """
  availableMemoryBytes: Metric!

  """Data Disk Queue Depth(or Queue Length)"""
  dataDiskQueueDepth: Metric!

  """Bytes/Sec read from a single disk during monitoring period"""
  dataDiskReadBytesPerSec: Metric!

  """Read IOPS from a single disk during monitoring period"""
  dataDiskReadOperationsPerSec: Metric!

  """Bytes/Sec written to a single disk during monitoring period"""
  dataDiskWriteBytesPerSec: Metric!

  """Write IOPS from a single disk during monitoring period"""
  dataDiskWriteOperationsPerSec: Metric!

  """Bytes read from disk during monitoring period"""
  diskReadBytes: Metric!

  """Disk Read IOPS"""
  diskReadOperationsPerSec: Metric!

  """Bytes written to disk during monitoring period"""
  diskWriteBytes: Metric!

  """Disk Write IOPS"""
  diskWriteOperationsPerSec: Metric!

  """
  Inbound Flows are number of current flows in the inbound direction (traffic going into the VM)
  """
  inboundFlows: Metric!

  """The maximum creation rate of inbound flows (traffic going into the VM)"""
  inboundFlowsMaximumCreationRate: Metric!

  """
  The number of bytes received on all network interfaces by the Virtual Machine(s) (Incoming Traffic)
  """
  networkInTotal: Metric!

  """
  The number of bytes out on all network interfaces by the Virtual Machine(s) (Outgoing Traffic)
  """
  networkOutTotal: Metric!

  """OS Disk Queue Depth(or Queue Length)"""
  oSDiskQueueDepth: Metric!

  """Bytes/Sec read from a single disk during monitoring period for OS disk"""
  oSDiskReadBytesPerSec: Metric!

  """Read IOPS from a single disk during monitoring period for OS disk"""
  oSDiskReadOperationsPerSec: Metric!

  """
  Bytes/Sec written to a single disk during monitoring period for OS disk
  """
  oSDiskWriteBytesPerSec: Metric!

  """Write IOPS from a single disk during monitoring period for OS disk"""
  oSDiskWriteOperationsPerSec: Metric!

  """
  Outbound Flows are number of current flows in the outbound direction (traffic going out of the VM)
  """
  outboundFlows: Metric!

  """
  The maximum creation rate of outbound flows (traffic going out of the VM)
  """
  outboundFlowsMaximumCreationRate: Metric!

  """
  The percentage of allocated compute units that are currently in use by the Virtual Machine(s)
  """
  percentageCPU: Metric!

  """Premium Data Disk Cache Read Hit"""
  premiumDataDiskCacheReadHit: Metric!

  """Premium Data Disk Cache Read Miss"""
  premiumDataDiskCacheReadMiss: Metric!

  """Premium OS Disk Cache Read Hit"""
  premiumOSDiskCacheReadHit: Metric!

  """Premium OS Disk Cache Read Miss"""
  premiumOSDiskCacheReadMiss: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Azure entity extension for Host"""
type AzureVMHostExtension {
  """Azure VM name"""
  name: String

  """Azure resourceId"""
  resourceId: String!

  """Unique identifier of an Azure VM"""
  hostId: String!

  """Azure VM type"""
  hostType: String!

  """Name of the cloud provider for filtering purpose"""
  cloudProvider: String

  """Name of the cloud platform eg: azure vm"""
  cloudPlatform: String

  """Separate geographic area that Azure uses to house its infrastructure."""
  region: String!

  """The Availability Zone of the instance."""
  availabilityZone: String

  """The ID of the image used to launch the instance."""
  imageId: String

  """The name of the image that was provided during image creation."""
  imageName: String

  """The value is window or linux."""
  osType: String

  """State of the Azure VM"""
  state: State

  """The name of the os disk. There is one os disk per VM."""
  osDiskName: String

  """The size of the os disk. There is one os disk per VM."""
  osDiskSize: String

  """The value is ReadWrite/ReadOnly or blank."""
  osDiskCaching: String

  """The number of CPU cores for the instance."""
  cpuCount: Int

  """Cloud Account to which this VM belongs."""
  cloudAccount: CloudAccount

  """Available Memory"""
  availableMemory: Metric!

  """Percentage CPU"""
  cpuUtilization: Metric!

  """Disk Read Operations/Sec"""
  diskReadOps: Metric!

  """Disk Write Operations/Sec"""
  diskWriteOps: Metric!

  """CPU Credits Remaining"""
  cpuCreditRemaining: Metric!

  """CPU Credits Consumed"""
  cpuCreditUsage: Metric!

  """Data Disk Read Bytes/sec"""
  diskDataReadBytes: Metric!

  """Data Disk Write Bytes/sec"""
  diskDataWriteBytes: Metric!

  """Data Disk Read Operations/sec"""
  diskDataReadOps: Metric!

  """Data Disk Write Operations/sec"""
  diskDataWriteOps: Metric!

  """Data Disk Queue Depth"""
  diskDataQueueDepth: Metric!

  """OS Disk Read Bytes/sec"""
  diskOsReadBytes: Metric!

  """OS Disk Write Bytes/sec"""
  diskOsWriteBytes: Metric!

  """OS Disk Read Operations/sec"""
  diskOsReadOps: Metric!

  """OS Disk Write Operations/sec"""
  diskOsWriteOps: Metric!

  """OS Disk Queue Depth"""
  diskOsQueueDepth: Metric!

  """Inbound Flows"""
  networkInboundFlows: Metric!

  """Outbound Flows"""
  networkOutboundFlows: Metric!

  """Inbound Flows Maximum Creation Rate"""
  inboundFlowsMaximumCreationRate: Metric!

  """Outbound Flows Maximum Creation Rate"""
  outboundFlowsMaximumCreationRate: Metric!

  """Premium Data Disk Cache Read Hit"""
  diskCacheDataReadHit: Metric!

  """Premium Data Disk Cache Read Miss"""
  diskCacheDataReadMiss: Metric!

  """Premium OS Disk Cache Read Hit"""
  diskCacheOsReadHit: Metric!

  """Premium OS Disk Cache Read Miss"""
  diskCacheOsReadMiss: Metric!

  """Network In Total"""
  networkIn: Metric!

  """Network Out Total"""
  networkOut: Metric!

  """Percentage of data disk I/Os consumed per minute"""
  dataDiskIOPSConsumedPercentage: Metric!

  """Percentage of data disk bandwidth consumed per minute"""
  dataDiskBandwidthConsumedPercentage: Metric!

  """virtual metric from vm state"""
  available: Metric!
}

scalar Byte

"""Byte array representation of the value."""
type BytesKeyValuePair implements EventKeyValuePair {
  key: String!
  value: String! @deprecated(reason: "Only for backwards compatibility, will be removed in favor of typed values (valueBytes)")
  valueBytes: [Byte!]
}

type CategoryDashboards {
  category: DashboardCategory!
  dashboardsCount: Int!
}

input CategoryFilter {
  type: CategoryType
  ownerId: ID
}

type CategoryOwner {
  id: ID!
  name: String!
}

enum CategoryType {
  system
  custom
}

type CheckForString implements Validation {
  type: ValidationType!
  status: ValidationStatus!
  string: String!
}

input CheckForStringInput {
  """
  Defines whether the check should pass only when the string is present on the page (CONTAINS) or
  only when it is absent (DOES_NOT_CONTAIN).
  """
  operator: CheckStringOperator!

  """The string that which will be searched in the page source code."""
  value: String!
}

type CheckForStringType {
  operator: CheckStringOperator!
  value: String!
}

enum CheckStringOperator {
  CONTAINS
  DOES_NOT_CONTAIN
}

"""Cloud Account entity"""
type CloudAccount implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Cloud Account provider (AWS, ...)"""
  cloudProvider: String!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
  configuration: CloudAccountConfigurationInterface
}

interface CloudAccountConfigurationInterface {
  metricsTag: String
  enabled: Boolean!
}

enum CollectionType {
  SET
  LIST
}

type CollectLogRow {
  clientId: ID!
  downloadUrl: String
}

"""
*DEPRECATED:* `ConditionType` is now described by metadata composed of `[AlertConditionScope]`, `AlertConditionDataSource` and `[AlertConditionDataType]`.
Alert definition condition types
"""
enum ConditionType {
  ENTITY_METRIC
  STANDALONE_METRIC
  LOG_QUERY
  ANOMALY_EVENTS
  UNKNOWN
}

type ConnectionDetails implements AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
  ipAddress: String!
  port: Int!
  protocol: String!
}

"""Container entity"""
type Container implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Container id"""
  containerId: String

  """Container image name"""
  imageName: String

  """Extension field that adds Apm instance fields to the Container entity"""
  apm: ApmContainerExtension

  """
  Read-only flag that's 'true' when there is "apm" extension set on the entity
  and 'false' if there's not.
  """
  hasApm: Boolean!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type ConversationMeasurements {
  """Source IP/Hostname of the conversation"""
  source: String!

  """Destination IP/Hostname of the conversation"""
  destination: String!

  """Array of data points"""
  measurements: [Measurement!]!
}

input ConversationsFilterInput {
  """
  Sets the top limit of conversations with highest flows traffic to retrieve.
  """
  limit: Int!

  """Sets time range to load netflow data from"""
  timeFilter: TimeRangeInput!

  """Sets size of aggregation buckets."""
  bucketSizeInSeconds: Int!

  """Input used to construct dynamic filters"""
  advancedFilter: AdvancedNetflowFilter
}

input CreateAwsCloudAccountInput {
  sessionId: Guid!
  displayName: String!
  configuration: AwsCloudAccountConfigurationInput!
}

type CreateAwsCloudAccountResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  awsCloudAccount: AwsCloudAccount
}

input CreateAzureCloudAccountInput {
  sessionId: Guid!
  displayName: String!
  configuration: AzureCloudAccountConfigurationInput!
}

type CreateAzureCloudAccountResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  azureCloudAccount: AzureCloudAccount
}

input CreateAzureIntegrationInput {
  displayName: String!
  metricsTag: String!
  credential: AzureCredentialInput!
  subscription: AzureSubscriptionInput!
}

type CreateAzureIntegrationResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  azureCloudAccount: AzureCloudAccount
}

input CreateCategoryInput {
  name: String!
}

type CreateCategoryResponse {
  code: String!
  success: Boolean!
  message: String!
  category: DashboardCategory
}

input CreateDashboardInput {
  name: String!
  description: String
  isPrivate: Boolean
  categoryId: ID
  widgets: [WidgetInput!]!
  layout: [LayoutInput!]!
}

type CreateDashboardResponse {
  code: String!
  success: Boolean!
  message: String!
  dashboard: Dashboard
}

union CreateEntityGroupResult = CreateEntityGroupSuccess | EntityGroupMutationError

type CreateEntityGroupSuccess {
  """Created entity group"""
  entityGroup: EntityGroup!
}

input CreateExclusionFilterExpressionInput {
  kind: ExclusionFilterExpressionKind!
  expression: String!
}

input CreateExclusionFilterInput {
  name: String!
  description: String!
  tokenSignature: String
  expressions: [CreateExclusionFilterExpressionInput!]!
}

type CreateExclusionFilterResponse implements ExclusionFilterResponseInterface {
  code: ExclusionFilterResponseCode!
  success: Boolean!
  message: String!
  exclusionFilter: ExclusionFilter
}

input CreateFeedbackInput {
  url: String!
  message: String!
  browser: String!
  appVersion: String!
  isTrialAccount: Boolean!
}

type CreateFeedbackResponse {
  code: FeedbackResponseCode!
  message: String!
  success: Boolean!
}

input CreateLogArchiveStorageInput {
  name: String!
  provider: LogArchiveProvider!
  storage: String!
  region: String!
  prefix: String!
}

type CreateLogArchiveStorageResponse implements LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  success: Boolean!
  message: String!
}

input CreateLogFilterInput {
  name: String!
  description: String
  expressions: [LogFilterExpressionInput!]!
  groupIds: [ID!]!
  global: Boolean!
}

type CreateLogFilterResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  logFilter: LogFilter
}

input CreateLogGroupInput {
  name: String!
  description: String
  syslogHosts: [String!]
  syslogApps: [String!]
  tags: [String!]
}

input CreateLogSearchHistoryInput {
  query: String!
}

input CreateLogSearchInput {
  name: String!
  query: String!
  groupId: ID
}

input createNotificationServiceConfigurationInput {
  type: String!
  title: String!
  description: String
  settings: JSON!
}

type CreateNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  configuration: NotificationService
}

input CreateOrganizationInvitationInput {
  email: String!
  role: OrganizationRole!
}

type CreateOrganizationInvitationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  invitation: OrganizationInvitation
}

input CreateSamlConfigurationInput {
  identityProvider: SamlIdentityProviderInput!
  enabled: Boolean
}

input CreateSavedSearchInput {
  name: String!
  query: String!
  isPrivate: Boolean
  context: SavedSearchContext!
  objectId: String
}

type CreateSavedSearchResponse {
  code: String!
  success: Boolean!
  message: String!
  savedSearch: SavedSearch
}

input CreateTokenInput {
  name: String!
  accessLevel: TokenAccessLevel!
  type: String
}

type CreateTokenResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  token: Token
}

input CreateWebsiteInput {
  """
  Name of the website, which must be unique within the organization. The website must also not
  contain any control characters, any white space other than space (U+0020), or any consecutive,
  leading or trailing spaces.
  """
  name: String!

  """
  URL of the website. Must be a valid URL with no leading or trailing white space. Must not contain
  invalid port number (>65535).
  """
  url: String!

  """
  Use this field to configure availability tests for the website.
  
  If it is omitted or set to null, the resulting Website entity will have no availability tests
  configured.
  """
  availabilityCheckSettings: AvailabilityCheckSettingsInput
}

type CreateWebsiteSuccess {
  id: ID!
}

type Credential {
  id: ID!
  displayName: String!
  description: String!
  tags: [CredentialTag]
  secretType: String!
  modifiedBy: User
  createdAt: Timestamp!
  modifiedAt: Timestamp
}

input CredentialFilter {
  secretTypes: [String!]!
}

type CredentialTag {
  key: String!
  value: String!
}

type CustomHeader {
  name: String!
  value: String!
}

input CustomHeaderInput {
  """
  Name of a request header. Must contain only characters allowed by RFC: a-z, A-Z, 0-9, - and _.
  """
  name: String!

  """Value of a request header."""
  value: String!
}

type Dashboard {
  id: ID!
  name: String!
  description: String
  category: DashboardCategory
  systemReference: ID
  isPrivate: Boolean
  widgets: [Widget!]!
  layout: [Layout!]!
  ownerId: ID @deprecated
  owner: DashboardOwner
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DashboardCategory {
  id: ID!
  name: String!
  type: String!
  owner: CategoryOwner
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DashboardCategoryQueries {
  search(inputs: SearchDashboardCategoriesInput!): SearchCategoriesResult!
}

input DashboardFilter {
  ownerId: ID
  categoryId: ID
  isSystem: Boolean
}

type DashboardOwner {
  id: ID!
  name: String!
}

type DashboardQueries {
  byId(id: ID!): Dashboard
  search(inputs: SearchDashboardsInput!): SearchDashboardsResult!
  categories: DashboardCategoryQueries
  widgets: WidgetQueries
}

type DatabaseAgent {
  agent: String!
  id: String!
  version: String!
  deploymentStatus: String!
  healthStatus: String!
}

type DatabaseInstance implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Database type/family [mongo, mssql, mysql, pgsql, redis]"""
  databaseType: String!

  """Database product name e.g. MySQL Community Server (GPL) """
  databaseProductName: String

  """Database version e.g. 8.0.27"""
  databaseVersion: String

  """
  Database display name e.g. 'mysql on offhost0 listening on shard1:3306'
  """
  databaseDisplayName: String

  """Uamsclient ID that runs dbo agents if any."""
  uamsClientID: String

  """
  Credential Id points to the credentials to be used to connect with the database instance
  """
  credentialId: String

  """Database address in the form of host:port e.g. localhost:3306"""
  databaseAddress: String

  """Database TLS enabled"""
  databaseTlsEnabled: Boolean

  """Database name to connect to, if required"""
  databaseDbName: String

  """Date and time in UTC of when the database instance was discovered"""
  databaseDiscoveredAt: String

  """Database instance bindings e.g. [127.0.0.1:3306]"""
  databaseBindings: [String!]

  """Database instance tags e.g. [rds, aurora, prod]"""
  databaseTags: [String!]

  """
  Database query capture method [poll, sniff, profiler, slow-log, query-cache]
  Allowed values depend on the databaseType
  """
  databaseQueryCapture: String

  """
  Latency (computed as executionTime/executionCount) rate of observed queries
  """
  latency: Metric!

  """Queries error rate"""
  errorRate: Metric!

  """Queries execution count"""
  throughput: Metric!

  """Queries execution time"""
  concurrency: Metric!

  """Total queries error rate"""
  totalErrorRate: Metric!

  """Total queries execution count"""
  totalThroughput: Metric!

  """Total queries execution time"""
  totalConcurrency: Metric!
  healthScore: HealthScore
  cloudProvider: String
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type DatabaseMetricColumn {
  metric: String!
  value: String!
}

type DatabaseProfiler {
  """Returns the profiler configuration for the given input"""
  configuration(input: DatabaseProfilerConfigurationInput!): DatabaseProfilerConfiguration!

  """Returns a ranked result by the given metric"""
  rank(input: DatabaseProfilerRankInput): DatabaseProfilerRankResponse!
}

type DatabaseProfilerCategory {
  """A user-friendly name for the category"""
  name: String!

  """
  This field defines what the user can rank the category by. For example, rank 'Queries' BY 'Total Time'.
  """
  rankBy: [DatabaseProfilerDescribableMetric!]!

  """
  These are the columns that can be included in the table when the category is ranked
  """
  columns: [DatabaseProfilerDescribableMetric!]!

  """
  Indicates the type of value available in the description. Could be of type QUERY or TEXT.
  """
  descriptionType: DatabaseProfilerDescriptionType!
  filters: [DatabaseProfilerRankOption!]! @deprecated(reason: "Use options instead")
  options: [DatabaseProfilerRankOption!]!
}

type DatabaseProfilerCategoryFilter {
  """
  A unique id for this filter, to be used as 'propertyName' when used in a query.
  """
  id: String!

  """This field defines how the filter should be used by the end user."""
  type: DatabaseProfilerCategoryFilterType!
}

enum DatabaseProfilerCategoryFilterType {
  BOOL
  STRING
  KEYVALUE
}

type DatabaseProfilerColumn {
  """The user-defined id that was received in the request"""
  id: String!
  value: Float!
  percentage: Float!
}

input DatabaseProfilerColumnMetric {
  """
  A user-defined id that will be returned in the response as part of the column data.
  """
  id: String!

  """The metric name associated to the column"""
  metricName: String!
}

type DatabaseProfilerConfiguration {
  """The set of categories a user can rank in the profiler."""
  categories: [DatabaseProfilerCategory!]!
}

input DatabaseProfilerConfigurationInput {
  """
  Optional unique identifier of an entity. If provided, the configuration will be related only to the given entity.
  """
  entityId: ID

  """Used for fetching hosts information from dbo-hosts-api"""
  timeRange: TimeRangeInput!
}

type DatabaseProfilerDescribableMetric {
  """A user-friendly description of the metric"""
  description: String!

  """The metric name known by the internal services"""
  metricName: String!
}

enum DatabaseProfilerDescriptionType {
  QUERY
  TEXT
}

type DatabaseProfilerRanking {
  position: Int!
  value: Float!
  percentage: Float!
  measurements(bucketSizeInSeconds: Int = 60): [Measurement!]!
}

input DatabaseProfilerRankInput {
  """The metric name to rank the data by"""
  metricName: String!

  """The time range from the resulting data"""
  timeRange: TimeRangeInput!

  """The resulting rows cannot be greater than this limit"""
  limit: Int!

  """Extra filter to be applied to the result"""
  filter: FilterInput

  """Extra filter to be applied to the result"""
  extraColumnsMetrics: [DatabaseProfilerColumnMetric!]!
}

type DatabaseProfilerRankOption {
  """
  A unique id for this filter, to be used as 'propertyName' when used in a query.
  """
  id: String!

  """This field defines how the filter should be used by the end user."""
  type: DatabaseProfilerRankOptionType!
}

enum DatabaseProfilerRankOptionType {
  BOOL
  STRING
  KEYVALUE
}

"""
Rank representation. It contains the ranked rows and a single item including a
summarized result of any other item that did not ranked high enough to be on the
table.
"""
type DatabaseProfilerRankResponse {
  rows: [DatabaseProfilerRankRow!]!
  rest: DatabaseProfilerRankRest!
}

"""
Represents a summarized rank of elements that are not included in the main result
"""
type DatabaseProfilerRankRest {
  description: String!
  ranking: DatabaseProfilerRanking!
  columns: [DatabaseProfilerColumn!]!
  rowCount: Int!
}

"""Ranked row describing a single element"""
type DatabaseProfilerRankRow {
  id: String!
  description: String!
  ranking: DatabaseProfilerRanking!
  columns: [DatabaseProfilerColumn!]!
}

type DatabaseQueries {
  queries: [DatabaseQueryDetails!]!
  pageInfo: PageInfo
}

input DatabaseQueriesInput {
  metricName: String!
  timeRange: TimeRangeInput!
  filter: FilterInput
  newQueriesOnly: Boolean! = false
  paging: PagingInput
}

type DatabaseQuery {
  id: String!
  digest: String!
  firstSeen: String!
  lastSeen: String!
  tags: [DatabaseQueryTag!]
  samples: [DatabaseQuerySample!]
}

type DatabaseQueryDetails {
  id: String!
  digest: String!
  rank: DatabaseRank!
  measurements(bucketSizeInSeconds: Int!): [Measurement!]!
}

input DatabaseQueryInput {
  entityId: String
  queryId: String!
  timeRange: TimeRangeInput!
}

type DatabaseQuerySample {
  entityId: String!
  databaseType: String!
  text: String!
  timestamp: String!
  database: String!
  user: String!
  origin: String!
  application: String!
  latency: Float!
  truncated: Boolean!
  connectionId: String!
  sampleError: String!
  warnings: [Int!]
  rawPlan: String!
  explainError: String!
  textEmptyReason: String!
}

type DatabaseQuerySpan {
  queryId: String!
  spanId: String!
}

type DatabaseQueryTag {
  key: String!
  value: String!
  keyValue: String!
}

type DatabaseRank {
  time: Int! @deprecated(reason: "time is deprecated. Use totalTime instead.")
  totalTime: Float!
  value: String!
}

type DatabaseResponseDetails {
  metric: String!
  value: Float!
}

input DatabaseSessionMetricInput {
  databaseTypes: [String!]!
  timeRange: TimeRangeInput!
  bucketSizeInSeconds: Int!
  filter: FilterInput
}

type DatabaseSessionMetricResponse {
  databaseType: String!
  values: [SessionMeasurement!]!
}

type DatabaseTopQueries {
  id: String!
  digest: String!
  rank: DatabaseRank
  timeseries(bucketSizeInS: Int!): [Measurement!]!
  percentage: Float!
  column(metric: [String!]): [DatabaseMetricColumn!]!
}

input DatabaseTopQueriesInput {
  entityId: String
  metricName: String!
  timeRange: TimeRangeInput!
  limit: Int!
  filter: FilterInput
  newQueriesOnly: Boolean! = false
}

type DatabaseTrace {
  queries: [DatabaseQuerySpan!]
}

input DatabaseTraceInput {
  traceId: String!
  spanIds: [String!]
}

scalar DateTime

type DBOQueries {
  internalQueryIDs: [String!]!
}

input DeleteCategoryInput {
  id: ID!
}

type DeleteCategoryResponse {
  code: String!
  success: Boolean!
  message: String!
}

input DeleteCloudAccountsInput {
  entityIds: [String!]!
}

type DeleteCloudAccountsResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
}

input DeleteCredentialInput {
  ids: [ID!]!
}

type DeleteCredentialResult {
  ids: [ID!]!
}

input DeleteDashboardInput {
  id: ID!
}

type DeleteDashboardResponse {
  code: String!
  success: Boolean!
  message: String!
}

input DeleteDatabaseRequest {
  databaseInstanceID: String!
}

type DeleteDatabaseResponse {
  code: String!
  message: String
}

union DeleteEntityGroupResult = DeleteEntityGroupSuccess | EntityGroupMutationError

type DeleteEntityGroupSuccess {
  """Deleted entity group ID"""
  id: ID!
}

input DeleteExclusionFilterInput {
  id: ID!
}

input DeleteLogFilterInput {
  filterId: ID!
}

"""Delete network device response."""
type DeleteNetworkDeviceResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
}

input DeleteNotificationServiceConfigurationInput {
  id: ID!
}

type DeleteNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

type DeleteOrganizationMemberResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  lifespan: Int
}

input DeleteSavedSearchInput {
  id: ID!
}

type DeleteSavedSearchResponse {
  code: String!
  success: Boolean!
  message: String!
}

type DeleteServiceError {
  message: String!
}

input DeleteServiceInput {
  id: ID!
}

union DeleteServiceResult = DeleteServiceSuccess | DeleteServiceError

type DeleteServiceSuccess {
  id: ID!
}

input DeleteTokenInput {
  id: ID!
}

type DeleteTokenResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

input DeleteWebsiteInput {
  """The id of the website to be deleted."""
  id: ID!
}

type DeleteWebsiteSuccess {
  id: ID!
}

"""Mutations related to Digital Experience Monitoring (DEM)."""
type DemMutations {
  internalCreateWebsite(input: InternalCreateWebsiteInput!): InternalCreateWebsiteResult!
  internalUpdateWebsite(input: InternalUpdateWebsiteInput!): InternalUpdateWebsiteResult!
  createWebsite(input: CreateWebsiteInput!): CreateWebsiteSuccess!
  updateWebsite(input: PublicUpdateWebsiteInput!): PublicUpdateWebsiteSuccess!
  deleteWebsite(input: DeleteWebsiteInput!): DeleteWebsiteSuccess!
  triggerOnDemandCheck(input: TriggerOnDemandCheckInput!): TriggerOnDemandCheckResult!
}

"""Queries related to Digital Experience Monitoring (DEM)."""
type DemQueries {
  """Synthetic probes used to perform availability tests."""
  probes: [Probe!]!
}

enum Density {
  Comfort
  Compact
}

type DeployedOn implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]
}

enum DeploymentStatus {
  UNKNOWN
  UP_TO_DATE
  UPDATE_AVAILABLE
  DEPLOYMENT_IN_PROGRESS
  DELETE_IN_PROGRESS
  FAILED
  SCHEDULED_FOR_INSTALLATION
  SCHEDULED_FOR_DELETION
  UPDATE_CHECK_FAILED
}

"""DeviceVolume entity"""
type DeviceVolume implements Entity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """
  Orion Volume Uri 
  Serves as natural key for Device Volume
  """
  uri: String!

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Network Device to Device Volume."""
  networkDevice: NetworkDevice

  """State of Device Volume entity."""
  state: State

  """Device Volume type"""
  volumeType: String

  """Disk Usage Percentage of Device Volume Entity."""
  diskUsed: Metric!

  """Average Disk Queue Length of Device Volume Entity."""
  avgDiskQLength: Metric!

  """Average Disk Reads of Device Volume Entity."""
  avgDiskReads: Metric!

  """Average Disk Writes of Device Volume Entity."""
  avgDiskWrites: Metric!

  """Average Disk Transfer of Device Volume Entity."""
  avgDiskpersectransfer: Metric!

  """Average Disk Size of Device Volume Entity."""
  volumeSize: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

enum DiagnosticsType {
  LOGS
}

enum Direction {
  BACKWARD
  FORWARD
}

enum DurationColumn {
  TRACE_DURATION
  SPAN_DURATION
}

"""EC2 entity extension for Host"""
type EC2HostExtension {
  """EC2 instance name"""
  name: String

  """EC2 entity hostname (private Dns Name)"""
  hostname: String

  """Event Source as seen in logs eg: ec2.amazonaws.com"""
  eventSource: String

  """Name of the cloud provider for filtering purpose"""
  cloudProvider: String

  """Name of the cloud platform eg: AWS EC2"""
  cloudPlatform: String

  """AWS Account Number"""
  cloudAccountNumber: String!

  """Unique identifier of an AWS instance"""
  instanceId: String!

  """AWS EC2 instance type"""
  instanceType: String

  """State of the EC2 instance"""
  state: State

  """Separate geographic area that AWS uses to house its infrastructure."""
  region: String!

  """The Availability Zone of the instance."""
  availabilityZone: String

  """The ID of the AMI used to launch the instance."""
  imageId: String

  """The name of the AMI that was provided during image creation."""
  imageName: String

  """The description of the AMI that was provided during image creation."""
  imageDescription: String

  """The number of CPU cores for the instance."""
  cpuCoreCount: String

  """The architecture of the image."""
  architecture: String

  """The value is Windows for Windows instances; otherwise blank."""
  platform: String

  """Cloud Account to which this EC2 host belongs."""
  cloudAccount: CloudAccount

  """
  The number of earned CPU credits that an instance has accrued since it was launched or started.
  """
  cpuCreditBalance: Metric!

  """The number of CPU credits spent by the instance for CPU utilization."""
  cpuCreditUsage: Metric!

  """
  The number of surplus credits that have been spent by an unlimited instance when its CPUCreditBalance value is zero.
  """
  cpuSurplusCreditBalance: Metric!

  """
  The number of spent surplus credits that are not paid down by earned CPU credits, and which thus incur an additional charge.
  """
  cpuSurplusCreditsCharged: Metric!

  """
  The percentage of allocated EC2 compute units that are currently in use on the instance.
  """
  cpuUtilization: Metric!

  """
  The percentage of allocated compute capacity that is currently in use by the instances running on the Dedicated Host.
  """
  dedicatedHostCpuUtilization: Metric!

  """Bytes read from all instance store volumes available to the instance."""
  diskReadBytes: Metric!

  """
  Completed read operations from all instance store volumes available to the instance in a specified period of time.
  """
  diskReadOps: Metric!

  """Bytes written to all instance store volumes available to the instance."""
  diskWriteBytes: Metric!

  """
  Completed write operations to all instance store volumes available to the instance in a specified period of time.
  """
  diskWriteOps: Metric!

  """
  Completed I/O operations to all instance store volumes available to the instance in a specified period of time.
  """
  diskIOps: Metric!

  """
  Provides information about the percentage of throughput credits remaining in the burst bucket.
  """
  ebsByteBalance: Metric!

  """
  Provides information about the percentage of I/O credits remaining in the burst bucket.
  """
  ebsIOBalance: Metric!

  """
  Bytes read from all EBS volumes attached to the instance in a specified period of time.
  """
  ebsReadBytes: Metric!

  """
  Completed read operations from all Amazon EBS volumes attached to the instance in a specified period of time.
  """
  ebsReadOps: Metric!

  """
  Bytes written to all EBS volumes attached to the instance in a specified period of time.
  """
  ebsWriteBytes: Metric!

  """
  Completed write operations to all EBS volumes attached to the instance in a specified period of time.
  """
  ebsWriteOps: Metric!

  """
  The number of times the instance metadata service was successfully accessed using a method that does not use a token.
  """
  metadataNoToken: Metric!

  """
  The number of bytes received by the instance on all network interfaces. This metric identifies the volume of incoming network traffic to a single instance.
  """
  networkIn: Metric!

  """
  The number of bytes sent out by the instance on all network interfaces.
  """
  networkOut: Metric!

  """
  The number of bites sent and received by the instance on all network interfaces per second.
  """
  networkIO: Metric!

  """
  The number of packets received by the instance on all network interfaces
  """
  networkPacketsIn: Metric!

  """
  The number of packets sent out by the instance on all network interfaces.
  """
  networkPacketsOut: Metric!

  """
  Reports whether the instance has passed both the instance status check and the system status check in the last minute.
  """
  statusCheckFailed: Metric!

  """
  Reports whether the instance has passed the instance status check in the last minute.
  """
  statusCheckFailedInstance: Metric!

  """
  Reports whether the instance has passed the system status check in the last minute.
  """
  statusCheckFailedSystem: Metric!
}

input EditOtelReceiverInput {
  clientId: String!
  receiverName: String!
  instanceName: String!
  displayName: String
  parameters: [OtelReceiverParameterInput]
  credentials: [OtelReceiverCredentialInput]
  attributes: [OtelReceiverAttributeInput]
}

type EmptyLogFilterResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

type EmptyLogGroupResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

"""
Entities group for search result. Even search without grouping returns result in an entity group
with "grouping" value null.
"""
type EntitiesGroup {
  """
  Unique group identifier to allow clients to cache the group.
  Note the value is not human readable due to potentially multiple
  group by properties.
  """
  id: ID!

  """Entities in this group"""
  entities: [Entity!]!

  """
  If the search query contained grouping then this property contains information about particular groups.
  If the search query was not grouped then this property is null
  """
  grouping: [EntityGrouping!]

  """Total count of entities without paging."""
  totalEntitiesCount: Int

  """
  If the 'pagingPerGroup' flag is set in the grouping definition then each group contains extra page information
  valid for given group. 
  If a client wants to load next page of only a single group it has to adjust original search filter to limit the results
  to that group only. Applying group page information on the original query will load all the other groups as well 
  but their paging won't be valid.
  """
  pageInfo: PageInfo
}

type Entitlement {
  name: String!
  usage: Int!
  limit: Int!
  isSubscribed: Boolean!
  subscription: String!
  asOf: Int!
  status: EntitlementStatus
  statusEnd: Timestamp
  expiredStatus: EntitlementStatus
}

input EntitlementFilterInput {
  name: String!
}

enum EntitlementStatus {
  TRIAL
  ACTIVE
  SUSPENDED
}

"""Base interface for all entities"""
interface Entity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
}

"""Members of the group are a subtree starting from the these root ids."""
type EntityContextEntityGroupDefinition {
  entityContextRootEntityIds: [ID!]!
}

"""Input type for generic entity queries"""
input EntityFilterInput {
  """
  List of entity types to get. If empty/missing then search is across all entities.
  """
  types: [String!]

  """Optional filter definition."""
  filter: FilterInput

  """
  Contextual search query string. If used along with filter, entities must match both filters.
  """
  query: String

  """Optional entity telemetry status filter."""
  status: EntityTelemetryStatus
}

"""Type describing entity filter"""
type EntityFilterMetadata {
  """Name of filtered property"""
  propertyName: String!

  """
  List of available filter options (values) with number of matching entities
  """
  options: [EntityFilterOptionMetadata!]!

  """
  Paging information. If there are too many options available there may be multiple pages.
  """
  pageInfo: PageInfo!
}

"""Type describing entity filter option"""
type EntityFilterOptionMetadata {
  """Value of the property to filter by"""
  value: String!

  """Number of entities matching this filter option"""
  count: Int!
}

"""Input type for entity traversal queries"""
input EntityGraphTraversalInput {
  """
  List of incoming (where current entity is on "to" end) relationship types that should be traversed
  when looking for entities.
  When this list is empty then all incoming relationships are traversed.
  """
  inRelationshipTypes: [String!]

  """
  List of outgoing (where current entity is on "from" end) relationship types that should be traversed
  when looking for entities.
  When this list is empty then all outgoing relationships are traversed.
  """
  outRelationshipTypes: [String!]

  """
  How deep across relationships the traversal should go when looking for entities.
  If the depth is 0 then traversal across relationships is not executed at all.
  """
  depth: Int

  """
  Entity filter to filter out the entities during traversal. The filter can limit the entity types 
  and apply conditions on entity properties.
  """
  filter: EntityFilterInput
}

"""Entity Group entity that may contain other entities"""
type EntityGroup implements Entity & HealthEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Description of the Entity Group"""
  description: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """Type of the Entity Group"""
  groupType: EntityGroupType!

  """Entity Group definition. Describes how to find members of the group."""
  definition: EntityGroupDefinition!

  """Defines how the Health Score of the entity group should be calculated"""
  healthScoreCalculationMethod: EntityGroupHealthScoreCalculationMethod!

  """Collection of entities that are members of this group"""
  members: [Entity!]
}

"""
Group by definition. 
Grouping supports multiple levels so order of propertyNames values matters.
"""
input EntityGroupByInput {
  """Property names to group result by."""
  propertyNames: [String!]!

  """
  Specify how to apply paging when grouping result. This only applies to endpoints
  with pagination.
  If true then result will contain all groups and each group will be paged separately.
  If false (default) then paging will be applied to the whole result at once so only first 
  group or groups may have data for the first page and the rest may be empty. You need to move 
  to following pages to get data for remaining groups.
  """
  pagingPerGroup: Boolean = false
}

union EntityGroupDefinition = StaticEntityGroupDefinition | FilterEntityGroupDefinition | EntityContextEntityGroupDefinition

input EntityGroupDefinitionInput {
  """
  List of group's static members if 'groupType' is STATIC. Ignored for other group types.
  """
  staticMemberIds: [ID!]

  """
  Dynamic group members filter if 'groupType' is FILTER. Ignored for other group types.
  """
  dynamicFilter: EntityFilterInput

  """
  List of group's root entities if 'groupType' is ENTITY_CONTEXT. Ignored for other group types.
  """
  entityContextRootEntityIds: [ID!]
}

"""Defines how the Health Score of the entity group should be calculated"""
enum EntityGroupHealthScoreCalculationMethod {
  BEST
  AVERAGE
  WORST
}

"""
Entity group description telling what property and value this group represents
"""
type EntityGrouping {
  propertyName: String!
  propertyValue: String
}

input EntityGroupInput {
  """Name of the Entity Group"""
  name: String!

  """Description of the Entity Group"""
  description: String

  """Type of the Entity Group"""
  groupType: EntityGroupType!

  """Entity Group definition. Describes how to find members of the group."""
  definition: EntityGroupDefinitionInput!

  """Defines how the Health Score of the entity group should be calculated"""
  healthScoreCalculationMethod: EntityGroupHealthScoreCalculationMethod! = AVERAGE
}

"""Result in case of entity group mutation error."""
type EntityGroupMutationError {
  """Mutation error"""
  error: String

  """Validation errors"""
  validationResults: [ValidationResult!]
}

"""Entity Group type options"""
enum EntityGroupType {
  STATIC
  FILTER
  ENTITY_CONTEXT
}

input EntityLookupInput {
  """Keys and values used to lookup entities."""
  kvPairs: [KeyValuePairInput!]!

  """
  Include only entities that match given kvPairs with at least this score.
  """
  minMatchScore: Int!
}

type EntityLookupResult {
  """
  List of entities that match lookup keys in some way. Actual match score is included in each result.
  """
  entities: [EntityMatchResult!]!
}

type EntityMatchResult {
  entity: Entity!

  """
  How well the entity matched the lookup values. 
  Value is in range 0-100 where 0 is no match at all and 100 is full match.
  """
  matchScore: Int!
}

"""Result in case of entity mutation error."""
type EntityMutationError {
  """Mutation error"""
  error: String

  """Validation errors"""
  validationResults: [ValidationResult!]
}

type EntityMutations {
  """
  Set existing entity's display name / alias.
  Setting the explicit value sets display name to that value.
  Setting empty/null value removes display name and entity will use original name as its display name.
  """
  setEntityDisplayName(id: ID!, displayName: String): SetEntityDisplayNameResult

  """
  Set existing SyslogEntity's syslogAppName.
  Setting empty/null value removes syslogAppName
  """
  setEntitySyslogAppName(id: ID!, syslogAppName: String): SetEntitySyslogAppNameResult

  """
  Set existing SyslogEntity's syslogHostname
  Setting empty/null value removes syslogHostname
  """
  setEntitySyslogHostname(id: ID!, syslogHostname: String): SetEntitySyslogHostnameResult
}

type EntityQueries {
  """
  Get Entity by ID. If "timeRange" argument is passed it set a "time context" for the whole query and override any "intervalSec" values in metric scalars 
  metric directives. If the "timeRange" is not defined the default "intervalSec" value from the schema is used.
  """
  byId(id: ID!, timeRange: TimeRangeInput): Entity

  """
  Search for entities. The result can be grouped and sorted. If "timeRange" argument is passed it set a "time context" for the whole query and override any 
  "intervalSec" values in metric scalars metric directives. If the "timeRange" is not defined the default "intervalSec" value from the schema is used.
  """
  search(filter: EntityFilterInput, groupBy: EntityGroupByInput, sortBy: EntitySortInput, paging: PagingInput, timeRange: TimeRangeInput): SearchEntitiesResult!

  """
  Search for entities using graph traversal. Search first finds starting entities using `filter` constraints and then uses `traversal`
  to go to related entities via relationships.
  
  Depending on the used traversal `depth` value the supported behavior is slightly different:
  * `depth <= 1` - Results can be sorted using `sortBy` argument and full paging is supported.
  * `depth > 1` - Sorting is not supported and paging supports only `first` argument.
  
  If "timeRange" argument is passed it set a "time context" for the whole query and override any "intervalSec" values in metric scalars
  metric directives. If the "timeRange" is not defined the default "intervalSec" value from the schema is used.
  """
  searchGraph(filter: EntityFilterInput, traversal: EntityGraphTraversalInput, sortBy: EntitySortInput, paging: PagingInput, timeRange: TimeRangeInput): SearchEntitiesGraphResult!

  """Search for relationships."""
  searchRelationships(filter: RelationshipFilterInput, paging: PagingInput, timeRange: TimeRangeInput): SearchRelationshipsResult!
}

"""
Query sort definiton. Sort support multiple properties and two sort directions.
"""
input EntitySortInput {
  sorts: [EntitySortItemInput!]!
}

"""Single property sort definition."""
input EntitySortItemInput {
  propertyName: String!
  direction: SortDirection
}

"""Various statistics queries related to a single entity"""
type EntityTelemetryStatistics {
  """
  Get number or unique values for given metric key for a given metric for this entity.
  If metric is not given, search all metrics.
  """
  uniqueMetricKeyValuesCount(key: String!, timeRange: TimeRangeInput!, metricName: String): Int!

  """Get number of unique metrics for this entity."""
  metricsCount(timeRange: TimeRangeInput!): Int!
}

"""Entity Telemetry Status"""
enum EntityTelemetryStatus {
  """ Entity is considered known if any telemetry was received within the given time range 
  """
  KNOWN

  """ Entity is considered unknown if no telemetry was received within the given time range 
  """
  UNKNOWN
}

type EntityTriggerCount {
  """Entity ID"""
  id: ID!

  """Entity display name"""
  displayName: String!

  """Number of triggered alerts within given time range"""
  triggerCount: Int!

  """Timestamp of the latest triggered alert (in ISO-8601 date format)"""
  lastTriggeredAt: String
}

"""Type describing single entity type"""
type EntityTypeMetadata {
  """Name of the entity type"""
  type: String!

  """
  Name of parent entity type when deducted from top-level extension, else null value.
  """
  parentType: String

  """List of all base types for this entity type"""
  baseTypes: [String!]!

  """List of all properties with metadata for this entity type"""
  properties: [PropertyMetadata!]!

  """
  List of metrics for this entity type defined in the schema.
  This list won't contain metrics that are present in the system but not defined in the schema.
  Kind specifies which metric sources should be used (BUILD_IN - defined in schema, STORED - available in storage)
  """
  metrics(kind: MetricKindInput = BUILD_IN): [MetricMetadata!]!

  """
  Special field that returns metadata about available filters for given set of properties, their values and entity counts.
  It can be narrowed down to a subset of entities via "filter" and "timeRange" argument and value containing query.
  "timeRange" argument filters by "lastSeenTime" property, entities with empty "lastSeenTime" property will not be filtered out.
  """
  filters(propertyNames: [String!]!, query: String, filter: EntityFilterInput, paging: PagingInput, timeRange: TimeRangeInput): [EntityFilterMetadata!]!

  """
  Flag telling if the entity type represents an ephemeral entity. Ephemeral entities are entities that can have very short
  lifetime and can appear and disappear frequently, such as container, DB queries etc.
  """
  isEphemeral: Boolean!
}

type ErrorItem {
  spanId: String!
  time: String!
  message: String!
  spanLayer: String!
  hostname: String!
  exceptionClassMessageHash: String!
}

"""Evaluation result types"""
enum EvalResultType {
  BOOLEAN
  NUMBER
  STRING
  NULL
}

type EvaluatedResult {
  """Defining in which attribute is the value set"""
  type: EvalResultType
  boolean: Boolean
  string: String
  number: Float
}

"""Evaluated condition node"""
type EvaluatedTreeNode {
  type: String!
  result: EvaluatedResult
  operator: String
  fieldName: String
  source: String
  query: String
}

"""Single event"""
type Event {
  """Event id"""
  id: String!

  """Event timestamp in ISO-8601 format"""
  time: String!

  """Event data - key value pairs"""
  data: [EventKeyValuePair!]
}

"""Input type for namespace, namespaceKey and namespaceKeyValue queries"""
input EventFilterTimeRangeInput {
  """Optional filter definition."""
  filter: FilterInput

  """
  Contextual search query string. If used along with filter, events must match both filters.
  """
  query: String

  """The time range to retrieve the events for"""
  timeRange: TimeRangeInput!
}

"""Single event key-eventCount pair"""
type EventKeyEventCountPair {
  key: String!
  eventCount: Int!
}

"""Response type for event key queries"""
type EventKeysResponse {
  """Namespace name"""
  namespace: String!

  """List of key-eventCount pairs"""
  keys: [EventKeyEventCountPair!]

  """Paging information."""
  pageInfo: PageInfo

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

"""Single event keyValue-eventCount pair"""
type EventKeyValueEventCountPair {
  value: String!
  eventCount: Int!
}

"""Single event key-value pair"""
interface EventKeyValuePair {
  key: String!
  value: String! @deprecated(reason: "Kept for backwards compatibility, will be removed in favor of typed values (valueString, valueBytes)")
}

"""Response type for event key-values queries"""
type EventKeyValuesResponse {
  """Namespace name"""
  namespace: String!

  """Key name"""
  key: String!

  """List of keyValue-eventCount pairs"""
  values: [EventKeyValueEventCountPair!]

  """Paging information."""
  pageInfo: PageInfo

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

"""Response type for event namespace queries, returning list of names"""
type EventNamespacesResponse {
  """List of namespace names"""
  namespaces: [String!]

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

type EventQueries {
  """Search for events"""
  search(query: EventsQueryInput, paging: PagingInput): EventsResponse

  """
  Obtain a list of event namespaces either expanded or first level only
  if false it returns dbo.* - meaning there is more namespaces starting with dbo using dot notation
  if true (default) - it returns all namespaces e.g.: "dbo.checkins", "dbo.features", "dbo.samples"
  """
  namespaces(expand: Boolean = true): EventNamespacesResponse

  """
  Obtain a list of keys associated with `namespace` matching `query` + their counts
  """
  namespaceKeys(namespace: String!, query: EventFilterTimeRangeInput, paging: PagingInput, sortBy: EventSortByKeyOrCountInput, keyNameQuery: String): EventKeysResponse

  """
  Obtain a list of values associated with `namespace` and `key` matching `query` + their counts
  """
  namespaceKeyValues(namespace: String!, key: String!, query: EventFilterTimeRangeInput, paging: PagingInput, sortBy: EventSortByKeyValueOrCountInput): EventKeyValuesResponse
}

"""Sort by input for namespaceKeys search"""
input EventSortByKeyOrCountInput {
  sort: EventSortByKeyOrCountItem! = COUNT
  direction: SortDirection! = ASC
}

"""Sort either by keys or by counts"""
enum EventSortByKeyOrCountItem {
  KEY
  COUNT
}

"""Sort by input for namespaceKeyValues search"""
input EventSortByKeyValueOrCountInput {
  sort: EventSortByKeyValueOrCountItem! = COUNT
  direction: SortDirection! = ASC
}

"""Sort either by keyValues or by counts"""
enum EventSortByKeyValueOrCountItem {
  VALUE
  COUNT
}

"""Input type for events queries"""
input EventsQueryInput {
  """Namespace to search events for"""
  namespace: String! = "events"

  """Optional filter definition."""
  filter: FilterInput

  """
  Contextual search query string. If used along with filter, events must match both filters.
  """
  query: String

  """The time range to retrieve the metric for"""
  timeRange: TimeRangeInput!

  """
  List of event fields to retrieve. If empty then only event_id and timestamp are returned.
  """
  fields: [String!]
}

"""Response from events queries"""
type EventsResponse {
  """List of events"""
  events: [Event!]

  """Total count of events without paging."""
  totalEventsCount: Int

  """Paging information."""
  pageInfo: PageInfo

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

"""
ExclusionFilter is a set of regular expressions used to exclude unwanted log messages.
The filters may be scoped to an entire organization or a single token
"""
type ExclusionFilter {
  id: ID!
  tokenSignature: String
  name: String!
  description: String
  enabled: Boolean!
  expressions: [ExclusionFilterExpression!]!
}

type ExclusionFilterExpression {
  id: ID!
  kind: ExclusionFilterExpressionKind!
  expression: String!
}

enum ExclusionFilterExpressionKind {
  REGEX
  STRING
}

enum ExclusionFilterResponseCode {
  OK
  NOT_FOUND
  INVALID_REGEX
  INVALID_TOKEN_SIGNATURE
  DUPLICATE_ENTRY
  INTERNAL_SERVER_ERROR
}

interface ExclusionFilterResponseInterface {
  code: ExclusionFilterResponseCode!
  success: Boolean!
  message: String!
}

type ExternalActiveAlert {
  """ID in UUID format"""
  id: String!

  """Source platform (e.g. HCO)"""
  source: ExternalAlertSource!

  """Name of the associated Alert Definition"""
  definitionName: String!

  """Link to the associated Alert Definition"""
  definitionUrl: String

  """Severity of given instance"""
  severity: ExternalAlertSeverity

  """Name of the target the alert was raised for (e.g. entity name)"""
  targetName: String

  """SWO entity ID this instance is associated to"""
  entityId: String

  """SWO Host name"""
  host: String

  """Reason why this alert was raised"""
  reason: String

  """Trigger time of this alert instance"""
  triggeredAt: String!

  """Name of the user that acknowledged the alert instance"""
  acknowledgedBy: String
  acknowledgedAt: String
}

type ExternalActiveAlertsResult {
  """List of the external active alerts"""
  activeAlerts: [ExternalActiveAlert!]!

  """Paging metadata"""
  pageInfo: PageInfo!

  """Total number of available records"""
  totalRecords: Int
}

type ExternalAlertQueries {
  """
  Returns external alert instances for given Source, Filter, Paging and Sorting.
  Sorting is supported for `definitionName`, `targetName`, `severity`, `triggeredAt` and `acknowledgedBy`.
  Requires JWT payload (*x-jwt-verified* header) with `org_id` claim containing Organization ID.
  """
  activeAlerts(filter: AlertFilterExpressionInput!, paging: PagingInput, sortBy: SortInput): ExternalActiveAlertsResult!
}

"""
List of severities for external alerts (different from SWO alert severities)
"""
enum ExternalAlertSeverity {
  NOTICE
  INFORMATIONAL
  WARNING
  SERIOUS
  CRITICAL
}

"""
List of available external platforms form which we ingest active alert instances
"""
enum ExternalAlertSource {
  HCO
}

type FeaturePermissions {
  name: String!
  rolePermissions: [RolePermissions!]!
}

"""
Queries for checking whether selected feature is supported by version of orion that the org is using
"""
type FeatureSupport {
  """
  Checks whether the installation of orion which the org is using is able to filter data based on its origin
  """
  isTrafficFilterSupported: Boolean!
}

enum FeedbackResponseCode {
  OK
  SLACK_UNREACHABLE
  INTERNAL_SERVER_ERROR
}

"""
Members of the group are evaluated based on an entity query with this filter.
"""
type FilterEntityGroupDefinition {
  """String representation of 'EntityFilterInput' used to define the group"""
  filterExpression: String!

  """
  Contextual search query string based on conjunction
  of 'EntityFilterInput.filter' and 'EntityFilterInput.query' used to define the group
  """
  query: String
}

"""Input type imported from entity-service schema"""
input FilterInput {
  """Name of the property to filter on."""
  propertyName: String

  """
  Value of the property for operations that expect single value such as EQ, NE, GT, ... 
  """
  propertyValue: String

  """
  Values of the property for operations expecting multiple values, such as IN. 
  """
  propertyValues: [String]

  """
  Source/context of the property, one of: entity, metric, event.
  If not set, the default value is derived from the query type.
  """
  propertySource: PropertySource

  """
  Operation to use for the evaluation. Default: "EQ"
  """
  operation: FilterOperation! = EQ

  """
  Children filters in case of "operator" being one of "OR", "AND", "NOT". 
  In such case the "propertyName" and "propertyValue" are ignored.
  """
  children: [FilterInput!]
}

"""Allowed entity filtering operators"""
enum FilterOperation {
  EQ
  NE
  GT
  GE
  LT
  LE
  CONTAINS
  MATCHES
  IN
  AND
  OR
  NOT
  EXISTS
}

type FilterOptions {
  """List of filter options"""
  options: [String!]!

  """Page info metadata"""
  pageInfo: PageInfo!
}

input FilterOptionsInput {
  """Specifies property whose options we are querying"""
  property: String!

  """Specifies filter applied to options of property"""
  filter: AdvancedNetflowFilter

  """Specifies time range which should be searched for options"""
  timeFilter: TimeRangeInput!

  """
  Paging metadata for the query. If page input is not defined, the getFilterOptions returns
  all options for a given time range and set of filters
  """
  paging: PagingInput
}

type FirewallNetworkDeviceExtension {
  """Firewall name"""
  name: String
}

type FlatAlertConditionExpression {
  """Alert Condition Expression Tree Node ID"""
  id: ID!

  """List of named child condition node IDs."""
  links: [NamedLinks!]

  """
  Ordered list of expression nodes representing the flatten tree.
  The first item is the tree root with named links using `operands`.
  """
  value: FlatAlertConditionNode
}

"""
See https://swicloud.atlassian.net/wiki/spaces/NIT/pages/2700936948/Data+Format+for+storing+alerts.
"""
type FlatAlertConditionNode {
  """
  Node (operator) type. Supported values:
  - `aggregationOperator` (child of `binaryOperator`)
  - `binaryOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  - `constantValue` (root, or child of `aggregationOperator`, `binaryOperator`)
  - `logicalOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  - `metricField` (child of `binaryOperator`, `aggregationOperator`)
  - `queryField` (child of `aggregationOperator`)
  - `unaryOperator` (root, or child of `logicalOperator`, `unaryOperator`)
  """
  type: String!

  """
  Operator for combining operands. Supported values:
  - For aggregationOperator: `COUNT`, `MIN`, `MAX`, `AVG`, `SUM`, `LAST`
  - For binaryOperator: `=`, `!=`, `>`, `<`, `>=`, `<=`
  - For logicalOperator: `AND`, `OR`
  - For unaryOperator: `!`
  """
  operator: String

  """Entity filter for `metricField` nodes"""
  entityFilter: AlertConditionNodeEntityFilter

  """Entity metric field for `metricField` nodes"""
  fieldName: String

  """Measurement filter for tags on metrics"""
  metricFilter: [FlatAlertFilterExpression]

  """
  Data type for `constantValue` nodes. Supported values: `boolean`, `number`, `string`
  """
  dataType: String

  """String representation of value for `constantValue` nodes."""
  value: String

  """Source specification for `queryField` nodes."""
  source: String @deprecated(reason: "Field is deprecated, `source` is now defined by `namespace`.")

  """Query specification for `queryField` nodes."""
  query: String

  """Events/logs namespace (in Chainsaw) for `queryField` nodes."""
  namespace: String
}

type FlatAlertFilterExpression {
  """Filter Expression Tree Node ID"""
  id: ID!

  """
  List of named child condition link IDs
  Children filters in case of "operator" being one of "OR", "AND", "NOT".
  In such case the "propertyName" and "propertyValue" are ignored.
  """
  links: [NamedLinks!]

  """
  Ordered list of expression nodes representing the flatten tree.
  The first item is the tree root with named links using `operands`.
  """
  value: AlertFilterExpression
}

"""
Ordered list of evaluated condition nodes representing the flatten condition tree.
The first item is the tree root with named links using `operands`.
"""
type FlatEvaluatedConditionTreeNode {
  """Evaluated condition Tree Node ID"""
  id: ID!

  """List of named child condition link IDs"""
  links: [NamedLinks!]

  """Evaluated tree node"""
  value: EvaluatedTreeNode
}

type FlowSourceExtension {
  """Indicates whether flow source is enabled"""
  enabled: Boolean! @deprecated(reason: "There is currently no use for this property")

  """Indicates whether the flow source sent flows in the past 15 minutes"""
  seenInPast15Minutes: Boolean! @deprecated(reason: "Formerly used for network device filtering. Replaced by flowSourceStatus on networkDevice")

  """
  Indicates whether the flow source ever sent flows (during 30 day retention period)
  """
  seenEver: Boolean! @deprecated(reason: "Formerly used for network device filtering. Replaced by flowSourceStatus on networkDevice")
}

type GenerateAwsCloudAccountEditWizardSessionResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  awsCloudAccountEditWizardSession: AwsCloudAccountEditWizardSession
}

type GenerateAwsCloudAccountWizardSessionResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  awsCloudAccountWizardSession: AwsCloudAccountWizardSession
}

input GenerateAzureAuthenticationUriInput {
  domainOrTenantId: String!
}

type GenerateAzureAuthenticationUriResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  sessionId: Guid!
  uri: String!
}

type GenericExclusionFilterMutationResponse implements ExclusionFilterResponseInterface {
  code: ExclusionFilterResponseCode!
  success: Boolean!
  message: String!
}

type GeoCoordinates {
  """Latitude in decimal degrees."""
  latitude: Float!

  """Longitude in decimal degrees."""
  longitude: Float!
}

type GetAzureSubscriptionsResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
  tenantName: String
  subscriptions: [AzureSubscription!]!
}

input GetExclusionFilterInput {
  id: ID!
}

enum GroupMappingType {
  ORGANIZATION
  PRODUCT
}

scalar Guid

"""Hardware Sensor entity"""
type HardwareSensor implements Entity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """State of HW sensor entity."""
  state: State

  """Operational status"""
  operationalStatus: String

  """Relation: Network Device to HardwareSensor."""
  networkDevice: NetworkDevice

  """Orion HW Sensor Uri. Serves as natural key for HardwareSensor."""
  uri: String!

  """Sensor category (e.g. Fan, Temperature, ...)."""
  category: String

  """Sensor value unit (e.g. RotationsPerMinute, ...)."""
  unit: String

  """
  Generic metric of any HW sensor. Its context is given by sensor category (and unit).
  """
  sensorValue: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type Has implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]
}

"""HcoGroup entity represents Hybrid Cloud Observability entity group"""
type HcoGroup implements Entity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """
  HCO Group Uri 
  Serves as natural key for this group
  """
  uri: String!

  """
  UAMS Client ID 
  UAMS Client plugin this HCO group belongs to
  """
  uamsClientID: String!

  """Related EntityGroup"""
  group: EntityGroup
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""The base interface for entities with a health score"""
interface HealthEntity {
  id: ID!

  """Health score of the entity"""
  healthScore: HealthScore
}

"""Health Score"""
type HealthScore {
  """Health score value from 0 to 100"""
  score: Int!

  """Health Score category label"""
  category: String
}

interface HistoricalAlert {
  """Alert definition ID"""
  alertDefinitionId: String!

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Time when the evaluation was triggered in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  triggeredAt: String!

  """
  Time when the evaluation was resolved in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  resolvedAt: String!

  """Resolution reason"""
  reason: AlertReason!

  """Condition type"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData
}

input HistoricalAlertsFilterInput {
  """Time range for filter"""
  timeRange: AlertTimeRangeInput!

  """List of Alert definition IDs"""
  alertDefinitionIds: [String!]

  """List of Alert definition severities"""
  severities: [AlertSeverity!]

  """List of Entity IDs"""
  entityIds: [String!]

  """List of Entity types"""
  entityTypes: [String!]

  """String used to search in Alert definition name or Entity display name"""
  searchString: String
}

type HistoricalAlertsResult {
  """List of historical alerts"""
  alerts: [HistoricalAlert!]!

  """Historical alerts statistics data"""
  statistics: HistoricalAlertsStatistics!

  """Cursor-based paging metadata"""
  pageInfo: PageInfo!

  """Number of records in data list"""
  totalRecords: Int
}

type HistoricalAlertsStatistics {
  """List of alert histogram columns"""
  alertsHistogram: [AlertsHistogramColumn!]!

  """List of alert statistics"""
  alertsStatistics: [AlertStatistics!]!

  """Mean time to resolution in seconds"""
  meanTimeToResolveInSeconds: Int
}

"""Historical alerts statistics categories"""
enum HistoricalAlertsStatisticsCategory {
  ALERT_DEFINITION
  ENTITY_TYPE
  MEAN_TIME_TO_RESOLVE
  SEVERITY
  REASON
  TRIGGERING_OBJECT
}

type HistoricalEventAlert implements HistoricalAlert {
  """Alert definition ID"""
  alertDefinitionId: String!

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Time when the evaluation was triggered in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  triggeredAt: String!

  """
  Time when the evaluation was resolved in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  resolvedAt: String!

  """Resolution reason"""
  reason: AlertReason!

  """Condition type"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData
}

type HistoricalLogAlert implements HistoricalAlert {
  """Alert definition ID"""
  alertDefinitionId: String!

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Time when the evaluation was triggered in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  triggeredAt: String!

  """
  Time when the evaluation was resolved in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  resolvedAt: String!

  """Resolution reason"""
  reason: AlertReason!

  """Condition type"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData
}

type HistoricalMetricAlert implements HistoricalAlert {
  """Alert definition ID"""
  alertDefinitionId: String!

  """Alert definition name"""
  alertDefinitionName: String!

  """Alert definition severity"""
  alertDefinitionSeverity: AlertSeverity!

  """
  Time when the evaluation was triggered in ISO-8601 date format (e.g. `2011-12-03T10:15:30Z`)
  """
  triggeredAt: String!

  """
  Time when the evaluation was resolved in ISO-8601 date format -(e.g. `2011-12-03T10:15:30Z`)
  """
  resolvedAt: String!

  """Resolution reason"""
  reason: AlertReason!

  """Condition type"""
  conditionType: ConditionType!

  """Entity details"""
  entity: AlertEntityData
}

"""Host entity"""
type Host implements Entity & HealthEntity & StatefulEntity & SyslogEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Host Id"""
  hostId: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Host Name"""
  hostname: String!

  """Os name"""
  osName: String

  """Os version"""
  osVersion: String

  """Os type"""
  osType: String

  """os description"""
  osDescription: String

  """
  Original host name. User can add hostname alias in the config of instrumentation lib (which will override observed value). This attribute is used to represent observed/polled name.
  """
  originalHostname: String

  """Entity type."""
  type: String!

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state.
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Host to Service"""
  deployedServices: [Service!]

  """Relation: Host to ServiceInstances"""
  deployedServiceInstances: [ServiceInstance!]

  """Relation: Websites that are hosted on this host"""
  relatedWebsites: [Website!]
  healthScore: HealthScore

  """
  The hostname field identifies the machine that originally sent the syslog message.
  """
  syslogHostname: String

  """
  The appName field should identify the device or application that originated the message.
  """
  syslogAppName: String
  distro: String
  system: String
  systemVersion: String
  agentVersion: String
  cpu: String
  cpuCount: Int
  cpuCores: Int
  ipAddresses: String
  macAddresses: String
  hostType: String
  architecture: String
  region: String
  availabilityZone: String
  cloudProvider: String

  """State of Host entity"""
  state: State

  """Trace service host error"""
  traceServiceHostErrors: Metric!

  """Trace service host request"""
  traceServiceHostRequests: Metric!

  """Trace service host response time"""
  traceServiceHostResponseTime: Metric!

  """Extension field that adds EC2 instance fields to the Host entity"""
  ec2: EC2HostExtension

  """
  Read-only flag that's 'true' when there is "ec2" extension set on the entity
  and 'false' if there's not.
  """
  hasEc2: Boolean!

  """Extension field that adds Azure VM fields to the Host entity"""
  azureVm: AzureVMHostExtension

  """
  Read-only flag that's 'true' when there is "azureVm" extension set on the entity
  and 'false' if there's not.
  """
  hasAzureVm: Boolean!

  """Extension field that adds APM Host fields to the Host entity"""
  apm: APMHostExtension

  """
  Read-only flag that's 'true' when there is "apm" extension set on the entity
  and 'false' if there's not.
  """
  hasApm: Boolean!

  """Extension field that adds UAMS Host fields to the Host entity"""
  uams: UAMSHostExtension

  """
  Read-only flag that's 'true' when there is "uams" extension set on the entity
  and 'false' if there's not.
  """
  hasUams: Boolean!

  """
  Extension field that adds NetworkCollector Host fields to the Host entity
  """
  nc: NCHostExtension

  """
  Read-only flag that's 'true' when there is "nc" extension set on the entity
  and 'false' if there's not.
  """
  hasNc: Boolean!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type HttpHeader {
  name: String
  value: String
}

"""
Indirect (transitive) relationship. E.g: A -> B -> C gives indirect relationship A -> C
"""
type IndirectRelationship implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]
}

input InsertCredentialInput {
  jweData: String!
  displayName: String!
  description: String!
  tags: [TagCredentialInput]
  secretType: String!
}

type InsertCredentialResult {
  id: ID!
}

input InternalCreateWebsiteInput {
  name: String!
  url: String!
  options: MonitoringOptionsInput!
  availability: AvailabilityMonitoringInput!
  rum: RumMonitoringInput
  customHeaders: [CustomHeaderInput!]
}

union InternalCreateWebsiteResult = InternalCreateWebsiteSuccess | WebsiteInputValidationError

type InternalCreateWebsiteSuccess {
  website: Website!
}

input InternalProbeLocationInput {
  type: ProbeLocationType!
  value: String!
}

input InternalUpdateWebsiteInput {
  id: ID!
  name: String!
  url: String!
  options: MonitoringOptionsInput!
  availability: AvailabilityMonitoringInput!
  rum: RumMonitoringInput
  customHeaders: [CustomHeaderInput!]
}

union InternalUpdateWebsiteResult = InternalUpdateWebsiteSuccess | WebsiteInputValidationError

type InternalUpdateWebsiteSuccess {
  website: Website!
}

type InvalidField {
  field: String!
  message: String!
}

"""IpAddress entity"""
type IpAddress implements Entity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Orion NodeIPAddresses Uri"""
  uri: String!

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Network Device to Ip Address"""
  networkDevice: NetworkDevice

  """Relation: Network Interface to Ip Address"""
  networkInterface: NetworkInterface

  """IpAddress"""
  ip: String

  """IpAddress type (IPv4, IPv6)"""
  ipType: String

  """Interface index"""
  ifIndex: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type IpLookupDetails implements AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
  hostname: String!
  resolvedIp: String!
}

type IsEntitlementSubscribedResponse {
  name: String!
  isSubscribed: Boolean!
}

scalar JSON

input KeyValue {
  key: String!
  value: String!
}

"""Tag key and value used when grouping measurement streams"""
input KeyValuePairInput {
  key: String!
  value: String!
}

enum KubernetesCloudProvider {
  OTHER
  AWS
  AZURE
}

"""Kubernetes Cluster entity"""
type KubernetesCluster implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """The Unique Id of the cluster."""
  clusterUid: String

  """The SWO collector version for the cluster."""
  collectorVersion: String

  """Provides information about node count during the time."""
  nodeCount: Metric!

  """Provides information about pod count during the time."""
  podCount: Metric!

  """Provides information about total core count in the cluster."""
  cpuCapacity: Metric!

  """Provides information about total cluster memory capacity."""
  memoryCapacity: Metric!

  """Provides current CPU usage."""
  clusterCpuUsagePercent: Metric!

  """Provides current cluster memory usage."""
  memoryUsagePercent: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
  cloudProvider: KubernetesCloudProvider
}

"""Kubernetes Container entity"""
type KubernetesContainer implements Entity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """State of entity"""
  state: State

  """The unique Id of the cluster."""
  clusterUid: String

  """The kubernetes namespace of the container"""
  namespaceName: String

  """Name of the pod."""
  podName: String

  """The unique Id of the container"""
  containerId: String

  """Container image name"""
  imageName: String

  """Container image id"""
  imageId: String

  """Kubernetes Pod to which this container belongs."""
  pod: KubernetesPod
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Kubernetes CronJob entity"""
type KubernetesCronJob implements Entity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The unique Id of the cluster."""
  clusterUid: String

  """The kubernetes namespace of the cron job"""
  namespaceName: String

  """Cluster to which this cron job belongs."""
  cluster: KubernetesCluster
}

"""Kubernetes DaemonSet entity"""
type KubernetesDaemonSet implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The Unique Id of the Cluster."""
  clusterUid: String

  """The kubernetes namespace of the DaemonSet"""
  namespaceName: String

  """Namespace to which this DaemonSet belongs."""
  namespace: KubernetesNamespace

  """Kubernetes Cluster to which this DaemonSet belongs."""
  cluster: KubernetesCluster

  """Creation time in unix timestamp for a DaemonSet"""
  creationTime: Int

  """Pods that are running"""
  podsReadyCount: Int

  """Available amount of pods"""
  podsAvailableCount: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Kubernetes Deployment entity"""
type KubernetesDeployment implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The Unique Id of the Cluster."""
  clusterUid: String

  """The kubernetes namespace of the Deployment"""
  namespaceName: String

  """Namespace to which this Deployment belongs."""
  namespace: KubernetesNamespace

  """Cluster to whichh this Deployment belongs."""
  cluster: KubernetesCluster

  """Creation time in unix timestamp for a Deployment"""
  creationTime: Int

  """
  Indicating the status of "Available" condition. Possible values are: "true", "false", "unknown"
  """
  conditionAvailable: String

  """
  Indicating the status of "Progressing" condition. Possible values are: "true", "false", "unknown"
  """
  conditionProgressing: String

  """
  Indicating the status of "ReplicaFailure" condition. Possible values are: "true", "false", "unknown"
  """
  conditionReplicaFailure: String

  """Desired number of Replicas from Spec"""
  replicasCount: Int

  """Pods that are running"""
  podsReadyCount: Int

  """Total amount of pods"""
  podsTotalCount: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type KubernetesHelmValues {
  clusterUid: String!
  otelEndpoint: String!
  values: String!
}

input KubernetesHelmValuesInput {
  clusterName: String!
  prometheusUrl: String!
  customClusterUid: String
}

type KubernetesHelmValuesResponse {
  success: Boolean!
  message: String!
  code: String!
  kubernetesHelmValues: KubernetesHelmValues
}

"""Kubernetes Job entity"""
type KubernetesJob implements Entity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The unique Id of the cluster."""
  clusterUid: String

  """The kubernetes namespace of the job"""
  namespaceName: String

  """Cluster to which this job belongs."""
  cluster: KubernetesCluster

  """CronJob to which this job belongs."""
  cronJob: KubernetesCronJob

  """Creation time in unix timestamp for a job"""
  creationTime: Int

  """Start time in unix timestamp for a job"""
  startTime: Int

  """Completion time in unix timestamp for a job"""
  completionTime: Int

  """Number of completions to job be completed"""
  completions: Int

  """Number of active completions"""
  active: Int

  """Number of succeeded completions"""
  succeeded: Int

  """Number of failed completions"""
  failed: Int
}

"""Kubernetes Namespace entity"""
type KubernetesNamespace implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The Unique Id of the Cluster."""
  clusterUid: String

  """Cluster to which this Namespace belongs."""
  cluster: KubernetesCluster

  """Creation time in unix timestamp for a Namespace"""
  creationTime: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Kubernetes Node entity"""
type KubernetesNode implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state.
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Health score of the entity"""
  healthScore: HealthScore

  """State of entity"""
  state: State

  """The Unique Id of the cluster."""
  clusterUid: String

  """The UID of the Node."""
  nodeUid: String

  """Kubelet version that is operating the node"""
  version: String

  """Information about the provider that is hosting the node"""
  providerId: String

  """Information about the operating system"""
  osImage: String

  """Kubernetes Cluster to which this Node belongs."""
  cluster: KubernetesCluster

  """Container runtime version that is installed on the node"""
  containerRuntimeVersion: String

  """Node internal IP"""
  internalIp: String

  """Provides information about pod count during the time."""
  podCount: Metric!

  """Provides information about total core count in the node."""
  cpuCapacity: Metric!

  """Provides information about total node memory capacity."""
  memoryCapacity: Metric!

  """Provides current CPU usage."""
  cpuUtilization: Metric!

  """Provides current node memory usage."""
  memoryUtilization: Metric!

  """Provides information about the number of file system reads and writes."""
  fileSystemIops: Metric!

  """
  Provides information about the throughput volume of file system reads and writes in bytes.
  """
  fileSystemThroughput: Metric!

  """Provides information about the file system usage in bytes."""
  fileSystemUsage: Metric!

  """Provides information about the network utilization - bytes received."""
  networkBytesReceived: Metric!

  """
  Provides information about the network utilization - bytes transmitted.
  """
  networkBytesTransmitted: Metric!

  """Creation time in unix timestamp for a node"""
  creationTime: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Kubernetes Pod entity"""
type KubernetesPod implements Entity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """
  State of entity (status phase of the Pod (Pending, Running, Succeeded, Failed, Unknown))
  """
  state: State

  """The unique Id of the cluster."""
  clusterUid: String

  """The kubernetes namespace of the pod"""
  namespaceName: String

  """The unique Id of the pod."""
  podUid: String

  """Pod IP address"""
  podIp: String

  """The current host IP of the pod"""
  hostIp: String

  """Name of the priority class assigned to the pod"""
  priorityClass: String

  """Controls whether the pod may use the node network namespace"""
  hostNetwork: Boolean

  """Name of entity responsible for creating the pod"""
  createdByName: String

  """Type of entity responsible for creating the pod"""
  createdByKind: String

  """Cluster to which this pod belongs."""
  cluster: KubernetesCluster

  """Relation: Pod to KubernetesNode"""
  node: KubernetesNode

  """StatefulSet to which this pod belongs."""
  statefulset: KubernetesStatefulSet

  """DaemonSet to which this pod belongs."""
  daemonset: KubernetesDaemonSet

  """ReplicaSet to which this pod belongs."""
  replicaset: KubernetesReplicaSet

  """Job to which this pod belongs."""
  job: KubernetesJob

  """Creation time in unix timestamp for a pod"""
  creationTime: Int

  """Start time in unix timestamp for a pod"""
  startTime: Int

  """Completion time in unix timestamp for a pod"""
  completionTime: Int

  """Provides information about container count."""
  containerCount: Metric!

  """Provides current CPU usage."""
  cpuUsage: Metric!

  """Provides current memory usage."""
  memoryUsage: Metric!

  """
  Provides the reason of Pending/Unknown/Failure states
  possible states are Evicted|NodeAffinity|NodeLost|Shutdown|UnexpectedAdmissionError
  TODO: move this property to native state when we switch from metric ingestion to events ingestion.
  """
  statusReason: String

  """Provides information about the number of file system reads and writes."""
  fileSystemIops: Metric!

  """
  Provides information about the throughput volume of file system reads and writes in bytes.
  """
  fileSystemThroughput: Metric!

  """Provides information about the file system usage in bytes."""
  fileSystemUsage: Metric!

  """Provides information about the network utilization - bytes received."""
  networkBytesReceived: Metric!

  """
  Provides information about the network utilization - bytes transmitted.
  """
  networkBytesTransmitted: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Kubernetes ReplicaSet entity"""
type KubernetesReplicaSet implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The Unique Id of the Cluster."""
  clusterUid: String

  """The kubernetes namespace of the ReplicaSet"""
  namespaceName: String

  """Deployment to which this ReplicaSet belongs."""
  deployment: KubernetesDeployment

  """Creation time in unix timestamp for a ReplicaSet"""
  creationTime: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Kubernetes StatefulSet entity"""
type KubernetesStatefulSet implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  Setting the explicit value of this property updates it to that value.
  Setting empty/null value to this property makes this property returning value of `name` property.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The Unique Id of the Cluster."""
  clusterUid: String

  """The kubernetes namespace of the StatefulSet"""
  namespaceName: String

  """Namespace to which this StatefulSet belongs."""
  namespace: KubernetesNamespace

  """Cluster to which this StatefulSet belongs."""
  cluster: KubernetesCluster

  """Creation time in unix timestamp for a StatefulSet"""
  creationTime: Int

  """Desired number of Replicas from Spec"""
  replicasCount: Int

  """Pods that are running"""
  podsReadyCount: Int

  """Total amount of pods"""
  podsTotalCount: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

input LastTriggeredFilterInput {
  """Time ranges for filter"""
  timeRanges: [AlertTimeRangeInput!]

  """Whether to include never triggered in the result"""
  neverTriggered: Boolean
}

type Layout {
  id: String!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

input LayoutInput {
  id: String!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

input ListExclusionFilterInput {
  query: String
}

input ListLogArchivesInput {
  timeFilter: LogArchiveTimeRangeInput!
  first: Int
  last: Int
  after: String
  before: String
}

type LogArchive {
  id: ID!
  name: String!
  downloadUrl: String!
  archivedTimestamp: Int!
  archiveSize: Float!
}

type LogArchiveConnection {
  edges: [LogArchiveEdge!]!
  pageInfo: PageInfo!
}

type LogArchiveEdge {
  node: LogArchive!
  cursor: String!
}

type LogArchiveFailure {
  message: String!
  provider: LogArchiveProvider
  updatedAt: Int!
  failureCount: Int!
}

enum LogArchiveProvider {
  AWS
  AZURE
  SWO_INTERNAL
}

type LogArchiveProviderInstruction {
  instructions: String!
}

input LogArchiveProviderInstructionsInput {
  provider: LogArchiveProvider!
}

type LogArchiveProviderStatus {
  id: ID!
  provider: LogArchiveProvider!
  isEnabled: Boolean!
}

enum LogArchiveResponseCode {
  OK
  PROVIDER_UNREACHABLE
  PROVIDER_NO_ACCESS
  INTERNAL_SERVER_ERROR
}

interface LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  success: Boolean!
  message: String!
}

input LogArchiveTimeRangeInput {
  startTime: String!
  endTime: String!
}

type LogEvent {
  id: ID!
  receivedAt: TimestampMs!
  facility: String
  severity: String
  sourceId: ID
  sourceName: String
  program: String
  message: String!
  positions: [LogEventPositions!]!
  isJson: Boolean
}

type LogEventPositions {
  length: Int!
  starts: [Int!]!
}

type LogEvents {
  cursor: LogEventsCursor!
  events: [LogEvent!]!
}

type LogEventsCursor {
  minId: ID!
  maxId: ID!
  minTimestamp: TimestampMs!
  maxTimestamp: TimestampMs!
  missedEvents: Boolean!
}

input LogEventsInput {
  direction: Direction!
  entityIds: [ID!]
  groupId: ID
  sourceId: ID
  minId: ID
  maxId: ID
  minTime: TimestampMs
  maxTime: TimestampMs
  query: String
  searchLimit: Int!
  visibleIds: [ID!]
}

type LogFilter {
  id: ID!
  orgId: String!
  name: String!
  description: String
  enabled: Boolean!
  expressions: [LogFilterExpression!]!
  groups: [LogGroup!]!
  createdAt: Timestamp
  updatedAt: Timestamp
  deletedAt: Timestamp
  readonly: Boolean!
  global: Boolean!
}

type LogFilterExpression {
  id: ID!
  enabled: Boolean!
  value: String!
  kind: LogFilterKind!
  operator: LogFilterOperator!
}

input LogFilterExpressionInput {
  id: ID
  value: String!
  kind: LogFilterKind!
  operator: LogFilterOperator!
  enabled: Boolean
}

input LogFilterInput {
  filterId: ID!
}

enum LogFilterKind {
  REGEX
  STRING
}

enum LogFilterOperator {
  CONTAINS
  DOES_NOT_CONTAIN
}

type LogGroup {
  id: ID!
  orgId: String!
  name: String!
  description: String
  syslogHosts: [String!]!
  syslogApps: [String!]!
  tags: [String!]!
  swokenSignature: String
  createdAt: Timestamp
  updatedAt: Timestamp
  deletedAt: Timestamp
  readonly: Boolean!
  httpHosts: [String!]!
}

input LogGroupInput {
  id: ID!
}

type LogGroupPT {
  id: ID!
  name: String!
  default: Boolean!
  editable: Boolean!
}

input LogGroupPTInput {
  groupId: ID!
}

type LogGroupResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  logGroup: LogGroup!
}

type LogMetrics {
  minTimestamp: TimestampMs!
  maxTimestamp: TimestampMs!
  metrics: [TimeSeriesSampleMs!]!
}

input LogMetricsInput {
  entityIds: [ID!]
  groupId: ID
  sourceId: ID
  minTime: TimestampMs
  maxTime: TimestampMs
  query: String
}

enum LogsCollectionScope {
  EVERYTHING
  UAMS_CLIENT
  PLUGIN
  PLUGIN_INSTANCE
}

input LogSearchesInput {
  groupId: ID
}

type LogSource {
  id: ID!
  name: String!
  editable: Boolean!
}

input LogSourceInput {
  id: ID!
}

type LogViewerSettings {
  id: String! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  density: Density! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  dynamicFavicon: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  chromeless: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  font: String! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  highlightMatches: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  tailingEdge: TailingEdge! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  themeId: Int! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  truncate: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  utcTimestamps: Boolean! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  visibility: VisibilitySettings! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
}

"""Single measurement - a metric data point"""
type Measurement {
  """Timestamp to which this measurement belongs"""
  time: String!

  """Measurement value"""
  value: Float
}

"""Measurements query result"""
type Measurements {
  """Measurement series with data point"""
  series: [MeasurementSeries!]!

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata

  """Paging information. The paging is done across measurement series."""
  pageInfo: PageInfo!
}

"""One metric measurement stream"""
type MeasurementSeries {
  """Set of tags and their values for this measurement stream"""
  tags: [Tag!]

  """Deprecated. Use "bucketSizeInSeconds"."""
  bucketSizeInS: Int!

  """How large is the aggregation bucket used to calculate this stream."""
  bucketSizeInSeconds: Int

  """Array of measurements - data points"""
  measurements: [Measurement!]!
}

"""Relationship used to assign an entity to an Entity Group."""
type MemberOf implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]
}

input MemberRolesInput {
  role: OrganizationRole
}

type MetadataQueries {
  """Get list of all entity types"""
  entityTypes: [String!]!

  """
  Get metadata about given entity type.
  limitToExtensions is optional argument, use to filter output only to desired extensions. Null argument means return
  all extensions, empty array means that metadata will be only for the base type.
  """
  entityTypeMetadata(type: String!, limitToExtensions: [String!]): EntityTypeMetadata

  """Get list of all relationship types"""
  relationshipTypes: [String!]!

  """Get metadata about given relationship type"""
  relationshipTypeMetadata(type: String!): RelationshipTypeMetadata

  """
  Get metadata about property name across all entity types, where property name contains given query
  """
  entityPropertyNameMetadata(query: String, paging: PagingInput): PropertyNameMetadataResult!

  """
  Get list of unique property names matching 'query' for given entity types or for all entity types 
  if the 'entityTypes' argument is missing or is an empty array.
  The default query matching is using "contain" logic but can be changed via 'matchMethod' argument to use "starts with".
  The result is ordered alphabetically by property name.
  """
  entityPropertyNamesAutocomplete(query: String, matchMethod: PropertyAutocompleteMatchMethod = CONTAINS, entityTypes: [String], paging: PagingInput): PropertyNameAutocompleteResult!

  """
  Get all the values of a property obtained from 'entityPropertyNamesAutocomplete' query using its 'id'.
  The returned values may be limited using 'query' argument and the behavior can be controlled using 'matchMethod' argument.
  The result values are ordered alphabetically.
  """
  entityPropertyNameAutocompleteValues(id: ID!, query: String, matchMethod: PropertyAutocompleteMatchMethod = CONTAINS, paging: PagingInput, timeRange: TimeRangeInput): PropertyNameAutocompleteValuesResult!
}

"""Type describing single metric"""
type Metric {
  """Name of this metric (same as the "name" field)"""
  id: ID!

  """Name of this metric"""
  name: String!

  """Formula for calculating the metric"""
  formula: String

  """
  If the metric is defined by formula then this property contains list of all the metrics used in the formula.
  """
  metricsUsedInFormula: [String!]

  """Units for this metric values"""
  units: String

  """
  Metric measurements. Can be queried using various filters, aggregations etc.
  Paging argument is applied to series, not to individual measurements.
  If you ask for first 3 items you get (at most) first 3 groups according 
  to "groupBy" definition but each group will have all the metric measurement
  according to a time range and bucket size.
  """
  measurements(metricInput: MetricQueryInput!, paging: PagingInput): Measurements!

  """Obtain a list of keys associated with `metric` containing `query`"""
  keys(query: String, timeRange: TimeRangeInput, paging: PagingInput): MetricKeysInfo

  """
  Obtain a list of values associated with `metric` and `key` containing `query`
  """
  keyValues(query: String, key: String!, timeRange: TimeRangeInput, paging: PagingInput): MetricKeyValuesInfo
}

"""Available metric aggregation functions"""
enum MetricAggregationFunction {
  COUNT
  MIN
  MAX
  AVG
  SUM
  LAST
}

"""Type representing a desired metric aggregation"""
input MetricAggregationInput {
  """Deprecated. Use "bucketSizeInSeconds"."""
  bucketSizeInS: Int

  """
  Size of an aggregation bucket.
  The actual returned bucket size may be different if the metric has lower granularity than requested.
  Caller should always check bucketSizeInS property in the result.
  """
  bucketSizeInSeconds: Int

  """
  How many data points should be returned at most.
  Service should calculate proper bucketSizeInS to return at most this number of data points.
  If both "maxDataPoints" and "bucketSizeInSeconds" are set then "maxDataPoints" takes precedence.
  """
  maxDataPoints: Int

  """
  Aggregation method such as "avg, min, max". The method can be omitted for composite metrics as these can already contain aggregation.
  """
  method: MetricAggregationFunction

  """
  How the missing values should be handled. If value other than NONE is used, the missing buckets according to
  "bucketSizeInSeconds" or "maxDataPoints" are filled with value based on specified option.
  """
  missingDataPointsHandling: MissingMeasurementDataPointsHandling = NONE

  """
  If true and missingDataPointsHandling is other than 'NONE', then if the measurement series would be empty, it is
  instead filled with values according to missingDataPointsHandling.
  """
  fillIfResultEmpty: Boolean = false

  """
  Secondary grouping to allow aggregating datapoints inside individual buckets.
  Has to be set together with `bucketGroupAggregationMethod` and then the data points in each bucket are grouped using these
  tags and aggregated using `bucketGroupAggregationMethod` before sending up to the main aggregation over the whole bucket.
  """
  bucketGrouping: [String!]

  """
  Secondary aggregation to allow aggregating datapoints inside individual buckets.
  Has to be set together with `bucketGrouping` and then the data points in each bucket are grouped using `bucketGrouping`
  tags and aggregated using  this method before sending up to the main aggregation over the whole bucket.
  """
  bucketGroupAggregationMethod: MetricAggregationFunction
}

type MetricDataPoint {
  timestamp: Timestamp!
  value: MetricValue
}

"""Response type for metric keys requests"""
type MetricKeysInfo {
  """Metric keys."""
  keys: [String!]!

  """Paging information."""
  pageInfo: PageInfo!

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

"""Response type for metric key values requests"""
type MetricKeyValuesInfo {
  """Metric key."""
  key: String!

  """Metric key values"""
  values: [String!]!

  """Paging information."""
  pageInfo: PageInfo!

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

"""Available metric sources"""
enum MetricKindInput {
  BUILD_IN
  STORED
  BUILT_IN_AND_STORED
}

"""Type describing single property"""
type MetricMetadata {
  """Name of the metric"""
  name: String!

  """Formula for calculating the metric"""
  formula: String

  """
  If the metric is defined by formula then this property contains list of all the metrics used in the formula.
  """
  metricsUsedInFormula: [String!]

  """Units for this metric values"""
  units: String

  """Obtain a list of keys associated with this `metric` and `EntityType`"""
  keys: MetricKeysInfo

  """
  Obtain a list of values for `key` associated with this `metric` and `EntityType`
  """
  keyValues(key: String!): MetricKeyValuesInfo
}

"""Response type for metric names requests"""
type MetricNamesInfo {
  """Metric names"""
  names: [String!]!

  """Paging information."""
  pageInfo: PageInfo!

  """Metadata for this result. Only used for development."""
  metadata: QueryMetadata
}

type MetricQueries {
  """Get single metric"""
  byName(name: String!): Metric

  """
  Get metrics of given names. If list of names is empty then empty array is returned.
  """
  byNames(names: [String!]!): [Metric!]!

  """Obtain a list of metric names containing `query`"""
  names(query: String, timeRange: TimeRangeInput, paging: PagingInput, kind: MetricKindInput = BUILT_IN_AND_STORED): MetricNamesInfo
}

"""Input type for generic metric values queries"""
input MetricQueryInput {
  """Optional filter definition."""
  filter: FilterInput

  """
  Contextual search query string. If used along with filter, metric must match both filters.
  """
  query: String

  """The time range to retrieve the metric for"""
  timeRange: TimeRangeInput

  """Expected metric results aggregation."""
  aggregation: MetricAggregationInput!

  """List of tags to group by measurements"""
  groupBy: [String!]

  """
  Sort definition. It's possible to sort by time, "groupBy" tags or by aggregated values.
  To sort by time use special identifier "<time>".
  To sort by aggregated value use special identifier "<value>".
  To sort by tags use the tag name.
  The default sort is: "<time> ASC"
  If you specify custom sort then the time is not used, you have to explicitly include it 
  in your sort definition.
  """
  sortBy: [MetricSortItemInput!]
}

"""Single metric key sort definition."""
input MetricSortItemInput {
  key: String!
  direction: SortDirection
}

"""Metric value may be number or string depending on particular metric"""
scalar MetricValue

type MfaBackupCode {
  code: String
  used: Boolean
}

input MfaBackupCodesInput {
  userId: String!
  password: String!
}

type MfaSettings {
  enabled: Boolean
  lifespan: Int
}

type MfaSettingsResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  enabled: Boolean
  lifespan: Int
}

"""Missing metric datapoints handling options"""
enum MissingMeasurementDataPointsHandling {
  """Do nothing. Missing data points are not returned."""
  NONE

  """Fill missing data points with value 0."""
  ZERO_FILL

  """Fill missing data points with value 'null'."""
  NULL_FILL

  """Fill missing data points with the value of last previous data point."""
  LAST_VALUE_FILL
}

type MockAggregationByCategoryRecord {
  aggregatedValue: Float!
  category: String!
}

input MockMetricAggregatedValueInput {
  aggregationMethod: MockMetricAggregationMethod!
  filters: [MockMetricFilterInput!]
  metricName: String!
  timeRange: MockMetricTimeRangeInput!
}

type MockMetricAggregatedValueResponse {
  aggregationMethod: MockMetricAggregationMethod!
  metricName: String!
  value: Float
  valueFromPreviousPeriod: Float
}

enum MockMetricAggregationMethod {
  AVERAGE
  MAX
  MIN
  SUM
}

input MockMetricFilterInput {
  arguments: [String!]
  children: [MockMetricFilterInput!]
  operator: MockMetricFilterOperator!
}

enum MockMetricFilterOperator {
  eq
}

input MockMetricTimeRangeInput {
  endTime: DateTime!
  startTime: DateTime!
}

type MockPerformanceTestMetric {
  averageValueSet: MockPerformanceTestMetricValue!
  latestValues(count: Int!): [MockPerformanceTestMetricValue!]!
  metricAggregatedValue(input: MockMetricAggregatedValueInput!): MockMetricAggregatedValueResponse!
  timeSeries(input: MockTimeSeriesInput!): [MockPerformanceTestMetricValue!]!
}

type MockPerformanceTestMetricValue {
  contentSizesByContentType: [MockAggregationByCategoryRecord!]
  contentSizesByDomain: [MockAggregationByCategoryRecord!]
  loadTimeMs: Int
  pageSizeBytes: Int
  requestsByContentType: [MockAggregationByCategoryRecord!]
  requestsByDomain: [MockAggregationByCategoryRecord!]
  requestsCount: Int
  time: DateTime
  timestamp: Timestamp
}

input MockTimeSeriesAggregationOptions {
  maxDataPoints: Int!
  method: MockMetricAggregationMethod!
}

input MockTimeSeriesInput {
  aggregation: MockTimeSeriesAggregationOptions!
  endTime: DateTime!
  startTime: DateTime!
}

input ModifyCredentialInput {
  id: ID!
  jweData: String!
  displayName: String!
  description: String!
  tags: [TagCredentialInput]
  secretType: String!
}

type ModifyCredentialResult {
  id: ID!
}

type MonitoringOptions {
  isAvailabilityActive: Boolean
  isRumActive: Boolean
}

input MonitoringOptionsInput {
  isAvailabilityActive: Boolean
  isRumActive: Boolean
}

type Mutation {
  modifyCredential(input: ModifyCredentialInput!): ModifyCredentialResult!
  deleteCredential(input: DeleteCredentialInput!): DeleteCredentialResult!
  insertCredential(input: InsertCredentialInput!): InsertCredentialResult!
  observeDatabase(req: ObserveDatabaseRequest!): ObserveDatabaseResponse!
  unobserveDatabase(req: UnobserveDatabaseRequest!): UnobserveDatabaseResponse!
  deleteDatabase(req: DeleteDatabaseRequest!): DeleteDatabaseResponse!
  setDatabaseCredentials(req: SetDatabaseCredentialsRequest!): SetDatabaseCredentialsResponse!
  updateDatabase(req: UpdateDatabaseRequest!): UpdateDatabaseResponse!

  """Creates a new Entity Group."""
  createEntityGroup(definition: EntityGroupInput!): CreateEntityGroupResult!

  """Updates existing Entity Group."""
  updateEntityGroup(id: ID!, definition: EntityGroupInput!): UpdateEntityGroupResult!

  """Deletes an Entity Group."""
  deleteEntityGroup(id: ID!): DeleteEntityGroupResult!

  """Mutations related to entities"""
  entities: EntityMutations!
  createInstallationSession(osType: OsType, token: String): AgentInstallInstruction
  addOtelReceiver(receiver: OtelReceiverInput): OtelReceiverResponse
  updateOtelReceiver(receiver: EditOtelReceiverInput): OtelReceiverResponse
  removeOtelReceiver(receiver: EditOtelReceiverInput): Boolean
  createLogArchiveStorage(input: CreateLogArchiveStorageInput!): CreateLogArchiveStorageResponse!
  updateLogArchiveStorage(input: UpdateLogArchiveStorageInput!): UpdateLogArchiveStorageResponse!
  updateLogArchiveProviderStatus(input: UpdateLogArchiveProviderStatusInput!): UpdateLogArchiveProviderStatusResponse!
  createExclusionFilter(input: CreateExclusionFilterInput!): CreateExclusionFilterResponse!
  updateExclusionFilter(input: UpdateExclusionFilterInput!): GenericExclusionFilterMutationResponse!
  deleteExclusionFilter(input: DeleteExclusionFilterInput!): GenericExclusionFilterMutationResponse!

  """Mutations related to Alerting."""
  alertMutations: AlertMutations!
  updateUser(user: UserAttributesInput!): UpdateUserAttributesResponse!
  updateUserAttribute(input: UpdateUserAttributeInput!): UpdateUserAttributeResponse!
  updateUserPassword(userPassword: UserPasswordInput!): UpdateUserPasswordResponse!
  updateUserEmail(input: UserEmailInput!): UpdateUserEmailResponse!
  createEmailVerification(email: String): MutationResponse!
  createNotificationServiceConfiguration(configuration: createNotificationServiceConfigurationInput!): CreateNotificationServiceConfigurationResponse!
  testNotificationServiceConfiguration(input: TestNotificationServiceConfigurationInput!): TestNotificationServiceConfigurationResponse!
  updateOrganization(input: OrganizationAttributesInput!): UpdateOrganizationAttributesResponse!
  createSamlConfiguration(input: CreateSamlConfigurationInput!): SamlConfigurationResponse!
  updateSamlConfiguration(input: UpdateSamlConfigurationInput!): SamlConfigurationResponse!
  deleteSamlConfiguration: MutationResponse!
  updateSamlGroupMapping(input: UpdateSamlGroupMappingInput!): SamlGroupMappingResponse!
  updateSamlServiceAccounts(input: UpdateSamlServiceAccountsInput!): SamlServiceAccountsResponse!
  updateMfaSettings(input: UpdateMfaSettingsInput!): MfaSettingsResponse!
  updateMemberRoles(userId: ID!, input: MemberRolesInput!): UpdateMemberRolesResponse!
  deleteUserTrustedDevice(input: UpdateUserTrustedDeviceInput!): MutationResponse!
  requestMfaBackupCodes(input: MfaBackupCodesInput): RequestMfaBackupCodesResponse!
  regenerateMfaBackupCodes(input: MfaBackupCodesInput): RequestMfaBackupCodesResponse!
  resetMfa(input: ResetMfaInput!): MutationResponse!
  deleteOrganizationMember(userId: ID!): DeleteOrganizationMemberResponse!
  createOrganizationInvitation(input: CreateOrganizationInvitationInput): CreateOrganizationInvitationResponse
  deleteOrganizationInvitation(email: ID!): MutationResponse!
  resendOrganizationInvitation(email: ID!): MutationResponse!
  updateNotificationServiceConfiguration(input: UpdateNotificationServiceConfigurationInput!): UpdateNotificationServiceConfigurationResponse
  createToken(input: CreateTokenInput): CreateTokenResponse
  updateToken(input: UpdateTokenInput): UpdateTokenResponse
  deleteToken(input: DeleteTokenInput): DeleteTokenResponse
  toggleLogFilter(input: ToggleLogFilterInput!): EmptyLogFilterResponse
  deleteLogFilter(input: DeleteLogFilterInput!): EmptyLogFilterResponse
  createLogFilter(input: CreateLogFilterInput!): CreateLogFilterResponse
  updateLogFilter(input: UpdateLogFilterInput!): UpdateLogFilterResponse
  deleteLogGroup(input: LogGroupInput!): EmptyLogGroupResponse
  createLogGroup(input: CreateLogGroupInput!): LogGroupResponse
  updateLogGroup(input: UpdateLogGroupInput!): LogGroupResponse
  slackAuthorizeUrl(url: String!): SlackAuthorizeUrlResponse
  deleteNotificationServiceConfiguration(input: DeleteNotificationServiceConfigurationInput!): DeleteNotificationServiceConfigurationResponse
  updateOrganizationSessionTimeout(input: UpdateSessionTimeoutInput!): SessionTimeoutResponse
  createLogSearch(input: CreateLogSearchInput!): SavedLogSearchResponse!
  updateLogSearch(input: UpdateLogSearchInput!): SavedLogSearchResponse!
  createLogSearchHistory(input: CreateLogSearchHistoryInput!): MutationResponse!
  reTrial: MutationResponse!
  updateWebsite(input: UpdateWebsiteInput!): UpdateWebsiteResult! @deprecated(reason: "updateWebsite is deprecated. Use internalUpdateWebsite from DemQueries instead.")
  dem: DemMutations!
  generateAwsCloudAccountWizardSession: GenerateAwsCloudAccountWizardSessionResponse!
  generateAwsCloudAccountEditWizardSession(sessionId: Guid): GenerateAwsCloudAccountEditWizardSessionResponse!
  createAwsCloudAccount(input: CreateAwsCloudAccountInput!): CreateAwsCloudAccountResponse!
  updateAwsCloudAccount(input: UpdateAwsCloudAccountInput!): UpdateAwsCloudAccountResponse!
  deleteAwsCloudAccounts(input: DeleteCloudAccountsInput!): DeleteCloudAccountsResponse!
  deleteAzureCloudAccounts(input: DeleteCloudAccountsInput!): DeleteCloudAccountsResponse!
  generateAzureAuthenticationUri(input: GenerateAzureAuthenticationUriInput!): GenerateAzureAuthenticationUriResponse!
  createAzureCloudAccount(input: CreateAzureCloudAccountInput!): CreateAzureCloudAccountResponse!
  createAzureIntegration(input: CreateAzureIntegrationInput!): CreateAzureIntegrationResponse!
  updateAzureIntegration(input: UpdateAzureIntegrationInput!): UpdateAzureIntegrationResponse!
  updateAzureCloudAccount(input: UpdateAzureCloudAccountInput!): UpdateAzureCloudAccountResponse!
  getAzureSubscriptions(input: AzureCredentialInput!): GetAzureSubscriptionsResponse!
  getAzureSubscriptionsForIntegration(entityId: String!): GetAzureSubscriptionsResponse!
  deleteService(input: DeleteServiceInput!): DeleteServiceResult!
  netpath: NetPathMutations!
  nim: NimMutations
  registerWebsite(req: RegisterWebsiteRequest!): RegisterWebsiteResponse!
  createDashboard(input: CreateDashboardInput!): CreateDashboardResponse!
  updateDashboard(input: UpdateDashboardInput!): UpdateDashboardResponse!
  deleteDashboard(input: DeleteDashboardInput!): DeleteDashboardResponse!
  createCategory(input: CreateCategoryInput!): CreateCategoryResponse!
  updateCategory(input: UpdateCategoryInput!): UpdateCategoryResponse!
  deleteCategory(input: DeleteCategoryInput!): DeleteCategoryResponse!
  createSavedSearch(input: CreateSavedSearchInput!): CreateSavedSearchResponse!
  updateSavedSearch(input: UpdateSavedSearchInput!): UpdateSavedSearchResponse!
  deleteSavedSearch(input: DeleteSavedSearchInput!): DeleteSavedSearchResponse!
  createFeedback(input: CreateFeedbackInput!): CreateFeedbackResponse!
  enableGlobalAutoUpdate(isAutoUpdateEnabled: Boolean): Boolean
  enableClientAutoUpdate(clientId: String, isAutoUpdateEnabled: Boolean): Boolean
  deleteClient(clientId: String): Boolean
  downloadDiagnostics(clientId: ID!, scopeInfo: ScopeInfo!, requestedInstanceDiagnosticsSizeKb: Int, diagnosticsType: DiagnosticsType): String
  bulkDownloadDiagnostics(clientIds: [ID!]!, scopeInfo: ScopeInfo!, requestedInstanceDiagnosticsSizeKb: Int, diagnosticsType: DiagnosticsType): Boolean
  startPluginInstance(clientId: String, pluginId: String, pluginInstanceId: String): Boolean
  stopPluginInstance(clientId: String, pluginId: String, pluginInstanceId: String): Boolean
  restartPluginInstance(clientId: String, pluginId: String, pluginInstanceId: String): Boolean
  bulkStartPluginInstance(pluginInstances: [PluginInstanceInput!]!): Boolean
  bulkStopPluginInstance(pluginInstances: [PluginInstanceInput!]!): Boolean
  bulkRestartPluginInstance(pluginInstances: [PluginInstanceInput!]!): Boolean
  restartUamsClient(clientId: String): Boolean
  bulkRestartUamsClient(clientIds: [String!]!): Boolean
  addUamsClientRole(clientId: String!, role: String!): Boolean
  removeUamsClientRole(clientId: String!, role: String!): Boolean
}

type MutationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

interface MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

type NamedLinks {
  """Name of the link"""
  name: String!

  """List of linked node IDs"""
  values: [ID!]
}

enum NavigationItems {
  ENTITIES
  LOGS
  METRICS
  TRACES
  ALERTS
  GENERAL
  USERS
  ACTIVITY_LOG
  API_TOKENS
  SECURITY
  CLOUD_ACCOUNTS
  NOTIFICATION_SERVICES
  AGENT_MANAGEMENT
  SYNTHETIC_MONITORING_PROBES
  DASHBOARDS
  PERMISSIONS
  CREDENTIALS
}

type navigationItemsPermission {
  permission: NavigationItems!
  allowed: Boolean!
}

type NavigationItemsResponse {
  items: [navigationItemsPermission!]
}

"""Network Collector entity extension for Host"""
type NCHostExtension {
  """
  HCO Node Uri
  Serves as natural key for Host
  """
  uri: String!

  """Host Category (Node Category)"""
  category: String

  """Entity name"""
  name: String

  """Host system name (Node SysName)"""
  systemName: String

  """Host DNS"""
  dns: String

  """Host IpAddress"""
  ip: String

  """Host OS name (Node MachineType)"""
  machineType: String

  """Host OS version (Node IOSVersion)"""
  iosVersion: String

  """Host OS type (Node Vendor)"""
  vendor: String

  """Host OS description (Node Description)"""
  description: String

  """CpuLoad in percent for Node"""
  cpuLoad: Metric!

  """MemoryUsage in percent for Node"""
  percentMemoryUsed: Metric!

  """Response time in milliseconds for Node"""
  responseTime: Metric!

  """Availability in percent for Node"""
  availability: Metric!

  """PercentLoss in percent for Node"""
  percentLoss: Metric!
}

"""
The neighbors topology connection relation type used in neighbors topology data processing in the Topology service.
"""
type NeighborsTopologyConnection implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]

  """
  UAMS Client IDs of neighbors topology data sources.
  Neighbors Topology data sources are Network collector UAMS client plugins.
  """
  uamsClients: [String!]!

  """Neighbor ip address"""
  neighborIp: String

  """Neighbor remote autonomous system number"""
  remoteAs: Int

  """Neighbor protocol name"""
  protocolName: String

  """Neighbor protocol status description"""
  protocolStatusDescr: String

  """Neighbor last change"""
  lastChange: String
}

"""Operator that can be used to evaluate or chain filters"""
enum NetflowFilterOperation {
  Eq
  Contains
  And
  Or
}

"""Queries for netflows metrics."""
type Netflows {
  """
  Gets top measurements of Bytes grouped by TopNetflowMetric during specified period of time.
  Produces time series data when bucketSizeInSeconds is set to a value greater than 0, otherwise it produces
  total sum of bytes during that period
  """
  topMetricsByBytes(filter: NetflowsFilterInput!): [NetflowsMeasurements!]!

  """
  Gets top measurements of Bytes (time series) grouped by conversation source and destination. Time series are ordered only by time.
  Uses dynamic filtering
  """
  topConversationsByBytes_V2(filter: ConversationsFilterInput!): [ConversationMeasurements!]!

  """
  Retrieves filter options filtered by search string of certain property ordered alphabetically. The search is
  case insensitive
  """
  getFilterOptions(filter: FilterOptionsInput!): FilterOptions!

  """
  Field for retrieving top Netflow sources (Network devices) filtered by time and advanced filters
  """
  topNetflowSources(filter: TopNetflowSourcesInput!): NetflowSources!
}

input NetflowsFilterInput {
  """Sets the metric attribute that is used to group Netflow data"""
  metric: String!

  """Sets the top limit of metrics with highest flows traffic to retrieve."""
  limit: Int!

  """
  Sets size of aggregation buckets. The data will be aggregated to a single bucket
  (aggregation over whole time range) if this property is null or zero
  """
  bucketSizeInSeconds: Int

  """Sets time range to load netflow data from"""
  timeFilter: TimeRangeInput!

  """Input used to construct dynamic filters"""
  advancedFilter: AdvancedNetflowFilter
}

type NetflowsMeasurements {
  """Name of metric by which we group measurements"""
  name: String!

  """Array of data points"""
  measurements: [Measurement!]!
}

"""Queries for retrieving top netflow sources"""
type NetflowSources {
  """Retrieves top network devices ordered by reported bytes, descending"""
  networkDevices: [NetworkDeviceFlowSource!]!
}

type NetPath {
  _internals: NetPathInternals

  """TODO: temporarily just for testing purposes"""
  data: String
}

"""
Dummy internal type as a workaround for https://github.com/graphql-dotnet/graphql-dotnet/issues/1548
"""
type NetPathInternals {
  id: ID
}

"""Netpath mutations."""
type NetPathMutations {
  """Add new NetPath endpoint."""
  addNetPathEndpoint(netpathEndpointInput: AddNetPathEndpointInput!): AddNetPathEndpointResponse!
}

"""
Network Device entity as a flat representation of Orion SWIS schema for all statistics related to Node 
with telemetry mapping condition to all telemetry with existing tags 'Orion.Nodes.Uri' and 'Orion.EntityType'
"""
type NetworkDevice implements Entity & HealthEntity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """HealthScore for Node"""
  healthScore: HealthScore

  """
  Orion Node Uri 
  Serves as natural key for NetworkDevice
  """
  uri: String!

  """NetworkDevice polling method (Node ObjectSubType)"""
  orionPollingMethod: String

  """Network device IpAddress (Node IpAddress)"""
  ip: String

  """Network device IpAddress type (IPv4, IPv6)"""
  ipType: String

  """Network device vendor (Node vendor)"""
  vendor: String

  """Network device manufacturer (e.g. Cisco, ...)."""
  manufacturer: String

  """Network device model."""
  model: String

  """Network device service tag."""
  serviceTag: String

  """Network device machine type (Node machineType)"""
  machineType: String

  """Network device software version (Node IOSVersion)"""
  softwareVersion: String

  """Network device CPU count (Node CPUCount)"""
  cpuCount: Int

  """
  Indicates whether Network device Dynamic IP is enabled (Node DynamicIpEnabled)
  """
  dynamicIpEnabled: Boolean

  """Network device DNS (Node DNS)"""
  dns: String

  """Network device Category (Node Category)"""
  category: String

  """Network device Object ID (Node SysObjectId)"""
  sysObjectId: String

  """Network device Last Boot (Node LastBoot)"""
  lastBoot: String

  """Network device Software Image (Node IOSImage)"""
  softwareImage: String

  """
  Network device system name (Node SysName)
  It can be different than the Name as the Name can be changed pretty easily.
  """
  systemName: String

  """Network device description (Node Description)"""
  description: String

  """State of Network Device entity."""
  state: State

  """Network device location (Node Location)"""
  location: String

  """Network device allows 64 bit counters (Node Allow64BitCounters)"""
  allow64BitCounters: Boolean

  """Network device poll interval in seconds (Node PollInterval)"""
  pollInterval: Int

  """
  Network device rediscovery interval in minutes (Node RediscoveryInterval)
  """
  rediscoveryInterval: Int

  """
  Network device statistics collection interval in minutes (Node StatCollection)
  """
  statCollectionInterval: Int

  """
  Property of network device specifying whether the device was a source of flows in the past, recently, or never
  """
  flowSourceStatus: String

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Network Interfaces that are plugged in this Network Device"""
  networkInterfaces: [NetworkInterface]

  """Relation: Hardware Sensors that are plugged in this Network Device"""
  hardwareSensors: [HardwareSensor]

  """Relation: Device Volumes that are plugged in this Network Device"""
  deviceVolumes: [DeviceVolume]

  """Relation: Ip Addresses that are plugged in this Network Device"""
  ipAddresses: [IpAddress]

  """Relation: Physical Ports that are plugged in this Network Device"""
  physicalPorts: [PhysicalPort]

  """
  Relation: Virtual Routing and Forwarding (VRF) instances this Network Device has
  """
  virtualRoutingForwardings: [VirtualRoutingForwarding]

  """CpuLoad in percent for Node"""
  cpuLoad: Metric!

  """MemoryUsage in percent for Node """
  percentMemoryUsed: Metric!

  """Response time in milliseconds for Node """
  responseTime: Metric!

  """Availability in percent for Node """
  availability: Metric!

  """PercentLoss in percent for Node"""
  percentLoss: Metric!

  """Router extension"""
  router: RouterNetworkDeviceExtension
  hasRouter: Boolean!

  """Switch extension"""
  switch: SwitchNetworkDeviceExtension
  hasSwitch: Boolean!

  """Wireless Controller extension"""
  wirelessController: WirelessControllerNetworkDeviceExtension
  hasWirelessController: Boolean!

  """Firewall extension"""
  firewall: FirewallNetworkDeviceExtension
  hasFirewall: Boolean!

  """Netflow Source extension"""
  flowSource: FlowSourceExtension @deprecated(reason: "Using this fields properties for filtering would lead to incorrect behaviour")
  hasFlowSource: Boolean!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type NetworkDeviceFlowSource {
  """Unique identifier of an network device entity"""
  entityId: ID!

  """Sum of bytes reported by network device"""
  bytes: Float!
}

"""Queries for network device management."""
type NetworkDevices {
  """Deletes network device by network device id."""
  deleteNetworkDevice(networkDeviceId: ID!): DeleteNetworkDeviceResponse!
}

"""Network Interface entity"""
type NetworkInterface implements Entity & StatefulEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """The interface's physical address (MAC). (PhysicalAddress)"""
  physicalAddress: String

  """State of Interface entity."""
  state: State

  """Relation: Network Device to Network Interface"""
  networkDevice: NetworkDevice

  """Relation: Ip Addresses that are plugged in this Network Interface"""
  ipAddresses: [IpAddress]

  """
  Orion Interfaces Uri 
  Serves as natural key for NetworkInterface
  """
  uri: String!

  """Network Interface type"""
  typeDescription: String

  """Network Interface speed"""
  speed: String

  """Availability in percent for Interface"""
  availability: Metric!

  """Input Utilization in percent for Interface"""
  inPercentUtil: Metric!

  """Output Utilization in percent for Interface"""
  outPercentUtil: Metric!

  """Output average bps for Interface"""
  outAverageBps: Metric!

  """Input average bps for Interface"""
  inAverageBps: Metric!

  """Input Errors for Interface"""
  inErrors: Metric!

  """Output Errors for Interface"""
  outErrors: Metric!

  """Input Discards for Interface"""
  inDiscards: Metric!

  """Output Discards for Interface"""
  outDiscards: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""
This Entity represents Shadow Node, which is a node where we know just the IP address and nothing else. This entity can be important for displaying topology data.  
"""
type NetworkShadowDevice implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """
  Orion Shadow Node Uri 
  Serves as natural key for ShadowEntity
  """
  uri: String!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type NginxInstance implements Entity & HealthEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type"""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden.
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Host name"""
  hostName: String

  """Host id"""
  hostId: String

  """UAMS agent id"""
  uamsClientId: String

  """UAMS agent plugin instance id"""
  uamsPluginInstanceId: String

  """NGINX request rate"""
  requestsRate: Metric!

  """NGINX accepted connection rate"""
  connectionsAcceptedRate: Metric!

  """NGINX handled connection rate"""
  connectionsHandledRate: Metric!

  """NGINX dropped connection rate"""
  connectionsDroppedRate: Metric!

  """NGINX current connections"""
  connectionsCurrent: Metric!
}

"""
Dummy internal type as a workaround for https://github.com/graphql-dotnet/graphql-dotnet/issues/1548
"""
type NimInternals {
  id: ID
}

type NimMutations {
  networkDevices: NetworkDevices!
}

type NimQueries {
  _internals: NimInternals
  netflows: Netflows!
  featureSupport: FeatureSupport!
}

type NotificationService {
  """The ID of the NotificationService."""
  id: ID!

  """The type of the NotificationService."""
  type: String!

  """The title of the NotificationService."""
  title: String!

  """The description of the NotificationService."""
  description: String

  """The settings of the NotificationService."""
  settings: JSON

  """The created time of the NotificationService."""
  createdAt: DateTime!

  """The createdBy user ID of the NotificationService."""
  createdBy: String!

  """The createdBy user full name of the NotificationService."""
  createdByName: String
}

input NotificationServiceFilter {
  type: String
}

type NotificationServicesGroupCount {
  email: Int
  slack: Int
  pagerduty: Int
  webhook: Int
  victorops: Int
  opsgenie: Int
  amazonsns: Int
  zapier: Int
  msTeams: Int
  pushover: Int
  sms: Int
  swsd: Int
  servicenow: Int
}

input ObserveDatabaseRequest {
  databaseInstanceID: String!
  uamsClientID: String!
  name: String!
  description: String
  type: String!
  bindings: [String!]
  options: [KeyValue!]
  credentials: [KeyValue!]
}

type ObserveDatabaseResponse {
  databaseInstanceID: String!
  code: String!
  message: String
}

type ObservedFrom implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]
}

enum OnDemandCheckStatus {
  UNSPECIFIED
  OK
  TOO_EARLY
}

type Organization {
  id: ID!
  credentials(filter: CredentialFilter): [Credential!]!
  credentialsPublicKey: String!
  name: String!
  role: OrganizationRole!
  multiOrgUsers: [User!]
  members(filter: OrganizationMemberFilter): [OrganizationMember!]!
  invitations: [OrganizationInvitation!]!
  auditTrail(limit: Int): [AuditTrailEntity!]
  samlConfiguration: SamlConfiguration
  samlGroupMapping: SamlGroupMapping
  samlServiceAccounts: [String!]!
  mfaConfiguration: MfaSettings!
  notificationServices(filter: NotificationServiceFilter): [NotificationService!]!
  notificationServicesGroupCount: NotificationServicesGroupCount!
  notificationServiceConfiguration(configurationId: String, configurationType: String): NotificationService!
  sessionTimeout: SessionTimeout!
  attribute(id: String!): OrganizationAttribute!
  attributes: [OrganizationAttribute!]!
  volumetricsSummary(input: VolumetricsSummaryInput!): VolumetricsSummaryResponse!
  volumetricsTimeseries(input: VolumetricsTimeseriesInput!): VolumetricsTimeseriesResponse!
  volumetricsTotal(input: VolumetricsTotalInput!): VolumetricsTotalResponse!
  logEvents(input: LogEventsInput!): LogEvents! @deprecated(reason: "Please use Entity Service for querying log events.")
  logMetrics(input: LogMetricsInput!): LogMetrics!
  logSearches(input: LogSearchesInput!): [SavedLogSearch!]!
  logSearchHistory: [RecentLogSearch!]!
  logGroupsPT: [LogGroupPT!]!
  logGroupPT(input: LogGroupPTInput!): LogGroupPT!
  logSources: [LogSource!]!
  logSource(input: LogSourceInput!): LogSource!
  tokens(filter: OrganizationTokenFilter): [Token!]
  activeFeatures: [String!]!
  permission(input: PermissionInput!): PermissionResponse!
  permissions(input: [PermissionInput!]!): [PermissionResponse!]!
  allPermissions: AllPermissionsResponse!
  allResources: [ResourceResponse!]!
  navigationItems: NavigationItemsResponse!
  entitlements(filter: EntitlementFilterInput): [Entitlement]!
  isEntitlementSubscribed(input: EntitlementFilterInput!): IsEntitlementSubscribedResponse
  retentions: [Retention!]!
  tenant: Tenant
  registeredUamsClients(role: String): [UamsClient!]
}

union OrganizationAttribute = AttributeString | AttributeInt | AttributeFloat | AttributeBool | AttributeJson

input OrganizationAttributesInput {
  name: String
}

type OrganizationBaseInfo {
  id: ID!
  name: String!
  role: OrganizationRole!
  joinedDate: DateTime!
}

input OrganizationFilter {
  orgId: String
}

type OrganizationInvitation {
  email: ID!
  role: OrganizationRole!
  date: DateTime!
}

type OrganizationMember {
  id: ID!
  user: User!
  role: OrganizationRole!
}

input OrganizationMemberFilter {
  role: OrganizationRole
  id: String
}

enum OrganizationRole {
  OWNER
  ADMIN
  MEMBER
  BILLING
  RESTRICTED_MEMBER
  VIEWER
}

type OrganizationSettings {
  orgId: ID!
  autoUpdateEnabled: Boolean
}

input OrganizationTokenFilter {
  id: String
}

enum OsType {
  WINDOWS
  LINUX
}

type OtelReceiverAttribute {
  name: String!
  value: String!
  attributeType: OtelReceiverAttributeType!
}

input OtelReceiverAttributeInput {
  name: String!
  value: String!
  attributeType: OtelReceiverAttributeType!
}

enum OtelReceiverAttributeType {
  UNDEFINED
  STRING
  BOOL
  INT
  DOUBLE
  ENTITY_ID
}

type OtelReceiverCredential {
  name: String!
  value: String
}

input OtelReceiverCredentialInput {
  key: String!
  value: String!
}

input OtelReceiverFilter {
  clientId: String
  pluginInstanceId: String
  receiverName: String
  instanceName: String
}

input OtelReceiverInput {
  clientId: String!
  receiverName: String!
  instanceName: String
  displayName: String
  parameters: [OtelReceiverParameterInput]
  credentials: [OtelReceiverCredentialInput]
  attributes: [OtelReceiverAttributeInput]
}

type OtelReceiverParameter {
  name: String!
  value: String
}

input OtelReceiverParameterInput {
  key: String!
  value: String!
}

type OtelReceiverResponse {
  clientId: String!
  pluginId: String!
  pluginInstanceId: String!
  receiverName: String!
  instanceName: String!
  displayName: String
  parameters: [OtelReceiverParameter]
  credentials: [OtelReceiverCredential]
  attributes: [OtelReceiverAttribute]
}

"""
Page info returned in results containing collection of items.
If can be used to page through the results.
"""
type PageInfo {
  """
  Start cursor for this page of items. The value is an opaque string and should be used
  as PagingInput.before|after argument in following queries.
  """
  startCursor: String

  """
  End cursor for this page of items. The value is an opaque string and should be used
  as PagingInput.before|after argument in following queries.
  """
  endCursor: String

  """
  True if there are more items after this page. Use `PagingInput.after=endCursor` in the next query to get to the next page.
  """
  hasNextPage: Boolean!

  """
  True if there are more items before this page. Use `PagingInput.before=startCursor` in the next query to get to the next page.
  """
  hasPreviousPage: Boolean!
}

input PaginationInput {
  limit: Int!
  offset: Int!
}

"""
Paging input for paginated queries. If not specified the first page of the results is returned and it will contain
up to X items where X is a value configured in the system.
"""
input PagingInput {
  """
  Fetch items that exist before this cursor. Cursor can be obtained from PageInfo data returned in previous query.
  """
  before: String

  """
  Fetch items that exist after this cursor. Cursor can be obtained from PageInfo data returned in previous query.
  """
  after: String

  """
  Get first X items from the result. This value can be used alone or in combination with "after".
  Other combinations are invalid and will lead to query error.
  """
  first: Int

  """
  Get last X items from the result. This value can be used alone or in combination with "before".
  Other combinations are invalid and will lead to query error.
  """
  last: Int
}

input PermissionInput {
  name: String!
  action: String!
}

enum PermissionName {
  MFA
  SAML
  NAME
  SESSION_TIMEOUT
  USER
  AUDITLOG
  TOKEN
  NOTIFICATION
  AGENT
  CREDENTIAL
  ENTITY
}

type PermissionResponse {
  allowed: Boolean
  reasons: [String]
  name: String!
  action: String!
}

"""PhysicalPort entity"""
type PhysicalPort implements Entity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Orion UDT Port Uri"""
  uri: String!

  """Relation: Network Device to Physical port"""
  networkDevice: NetworkDevice

  """Relation: Ip Addresses that are plugged in this Physical port"""
  ipAddresses: [PhysicalPortIpAddress]

  """Relation: Port to Endpoints that are plugged in this Physical port"""
  portToEndpoints: [PhysicalPortToEndpoint]

  """IsMonitored"""
  isMonitored: Boolean

  """OperationalStatus"""
  operationalStatus: String

  """Name"""
  portName: String

  """PortIndex"""
  portIndex: Int

  """PortType"""
  portType: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""PhysicalPortEndpoint entity"""
type PhysicalPortEndpoint implements Entity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Orion UDT IPAddressCurrent Uri"""
  uri: String!

  """Relation: Ip Addresses to Endpoint"""
  ipAddresses: [PhysicalPortIpAddress]

  """Relation: Port to Endpoint to Endpoint"""
  portToEndpoint: PhysicalPortToEndpoint

  """MAC Address"""
  macAddress: String

  """Vendor"""
  vendor: String
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""PhysicalPortIpAddress entity"""
type PhysicalPortIpAddress implements Entity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Orion UDT IPAddressCurrent Uri"""
  uri: String!

  """Relation: Network Device to Ip Address"""
  networkDevice: NetworkDevice

  """Relation: Physical port to Ip Address"""
  physicalPort: PhysicalPort

  """Relation: Endpoint to Ip Address"""
  endpoint: PhysicalPortEndpoint

  """Ip Address"""
  ip: String

  """DNS Name"""
  dnsName: String

  """Vrf Name"""
  vrfName: String
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""PhysicalPortToEndpoint entity"""
type PhysicalPortToEndpoint implements Entity & AlertingEntity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Orion UDT IPAddressCurrent Uri"""
  uri: String!

  """Relation: Network Device to Port to Endpoint"""
  networkDevice: NetworkDevice

  """Relation: Physical port to Port to Endpoint"""
  physicalPort: PhysicalPort

  """Relation: Endpoint to Port to Endpoint"""
  endpoint: PhysicalPortEndpoint

  """VlanID"""
  vlanId: Int

  """
  Connection type (null or 0 - Unknown, 1 - Direct, 2 - Indirect, 3 - Undetermined)
  """
  connectionType: Int
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type PlatformOptions {
  testFromAll: Boolean
  platforms: [String!]!
}

input PlatformOptionsInput {
  platforms: [String!]!
  testFromAll: Boolean
}

type PluginInfo {
  pluginId: String
  version: String
  deploymentStatus: DeploymentStatus
  instances: [PluginInstanceInfo]
}

enum PluginInstanceHealthStatus {
  UNKNOWN
  HEALTHY
  UNHEALTHY
}

type PluginInstanceInfo {
  instanceId: String
  healthStatus: PluginInstanceHealthStatus
  startupState: PluginInstanceStartupState
  statusCode: PluginInstanceStatusCode
  lastStatusUpdate: DateTime
}

input PluginInstanceInput {
  clientId: String!
  pluginId: String!
  pluginInstanceId: String!
}

enum PluginInstanceStartupState {
  UNKNOWN
  START
  STOP
}

enum PluginInstanceStatusCode {
  UNSPECIFIED
  OK
  BROKEN
  STOPPED
  RESTARTING
  START_FAILED
  NOT_RESPONDING
  HEALTHCHECK_FAILED
  CONFIGURATION_ISSUE
  FAILED
  INVALID
}

type Probe {
  id: ID!
  name: String!
  active: Boolean!
  region: String!
  country: String!
  city: String!
  platform: String!
  ipv4: String!
  ipv6: String

  """Geographical coordinates in decimal degrees."""
  coordinates: GeoCoordinates!
}

type ProbeLocation {
  type: ProbeLocationType!
  value: String!
}

input ProbeLocationInput {
  type: ProbeLocationType!

  """
  A list of probe location values of the selected `type`. At least one value matching an existing
  probe must be provided.
  """
  values: [String!]!
}

enum ProbeLocationType {
  REGION
  COUNTRY
  CITY
}

enum ProbePlatform {
  AWS
  AZURE
  GOOGLE_CLOUD
}

input ProbePlatformOptionsInput {
  """
  Cloud platforms of the synthetic probes to be used for availability tests.
  """
  probePlatforms: [ProbePlatform!]!

  """
  Use this field to configure whether availability tests should be performed from all selected
  platforms or one randomly selected platform. It has no effect if you provided only one platform
  in the `probePlatforms` field.
  
  If set to true, a separate test is made from each of the selected platforms.
  
  If set to false, only one of the selected platforms is chosen every time.
  
  If omitted, the previous setting will stay in effect. If there is no previous setting, the value
  will default to false.
  """
  testFromAll: Boolean
}

type ProfileEntry {
  id: Int!
  parentId: Int
  class: String!
  method: String!
  file: String!
  percent: Float!
  lineNumbers: [Int!]!
  hiddenChildren: [ProfileEntry!]
}

"""Property autocomplete match methods"""
enum PropertyAutocompleteMatchMethod {
  """Match all properties or values that contain given query."""
  CONTAINS

  """Match all properties or values that start with given query."""
  STARTS_WITH
}

"""Type describing single property"""
type PropertyMetadata {
  """Name of the property"""
  name: String!

  """Data type of the property - String, Int, ..."""
  type: String!

  """Entity or relationship type in which this property exists"""
  ownerType: PropertyOwnerType!

  """True if the property is nullable"""
  nullable: Boolean!

  """True if the type is a List"""
  list: Boolean!

  """True if the type is a Set"""
  set: Boolean!

  """Logical type of the property - IpAddress, Status, ..."""
  logicalType: String

  """True if it's possible to filter entities by this property"""
  filterable: Boolean

  """True if it's possible to group entities by this property"""
  groupable: Boolean

  """True if it's possible to sort entities by this property"""
  sortable: Boolean

  """True if property is read-only and can't be updated"""
  readonly: Boolean!
}

"""
Single autocomplete property information.
The 'id' can be used in 'entityPropertyNameAutocompleteValues' query to obtain values.
"""
type PropertyNameAutocompleteProperty {
  """
  Unique property identifier to be used in 'entityPropertyNameAutocompleteValues' to obtain property values.
  The value should not be displayed anywhere, it's internal opaque handle 
  that should not be interpreted in any way by clients.
  """
  id: ID!

  """Name of the property."""
  name: String!

  """
  Type of the property. For example 'String', 'Int', 'Boolean'.
  If there are multiple properties with the same name but different types the value of type is 'Mixed'.
  In case of 'Mixed' property the `entityPropertyNameAutocompleteValues` may returns only a subset
  of the values such as strings or bolleans but won't return numeric values. 
  """
  type: String!
}

"""Result of propery names autocomplete query."""
type PropertyNameAutocompleteResult {
  """Properties matching given query."""
  properties: [PropertyNameAutocompleteProperty!]!

  """
  Paging information. If there are too many options available there may be multiple pages.
  """
  pageInfo: PageInfo!
}

"""Single property autocomplete value"""
type PropertyNameAutocompleteValue {
  """The actual value."""
  value: String!
}

"""Result for 'entityPropertyNameAutocompleteValues' query."""
type PropertyNameAutocompleteValuesResult {
  """Available property values."""
  values: [PropertyNameAutocompleteValue!]!

  """
  Paging information. If there are too many options available there may be multiple pages.
  """
  pageInfo: PageInfo!
}

"""Type describing property name"""
type PropertyNameMetadata {
  """Property name"""
  propertyName: String!

  """List of all property occurrences across entity types"""
  properties: [PropertyMetadata!]!

  """
  Special field that returns metadata about available filters for this property, its values and entity counts.
  It can be narrowed down to a subset of entities via "filter" and "timeRange" argument and value containing query.
  "timeRange" argument filters by "lastSeenTime" property, entities with empty "lastSeenTime" property will not be filtered out.
  """
  filters(query: String, filter: EntityFilterInput, paging: PagingInput, timeRange: TimeRangeInput): EntityFilterMetadata!
}

"""Result wrapper for property name metadata query"""
type PropertyNameMetadataResult {
  """Properties matching given property name query."""
  properties: [PropertyNameMetadata!]!

  """
  Paging information. If there are too many matching properties there may be multiple pages.
  """
  pageInfo: PageInfo!
}

"""
Type union to describe owner type of a property - it can be either entity or relationship.
"""
union PropertyOwnerType = EntityTypeMetadata | RelationshipTypeMetadata

"""Source of a property in a filter."""
enum PropertySource {
  ENTITY
  METRIC
  EVENT
}

input PublicUpdateWebsiteInput {
  """The id of the website to be updated."""
  id: ID!

  """
  Name of the website. Must be unique within organization. Must not contain any control characters,
  any whitespace other than regular space, any leading, trailing or consecutive whitespace.
  """
  name: String!

  """
  URL of the website. Must be a valid URL with no leading or trailing whitespace. Must not contain
  invalid port number (>65535).
  """
  url: String!

  """
  Use this field to configure availability tests for the website.
  
  If it is omitted or set to null, the resulting Website entity will have no availability tests configured.
  """
  availabilityCheckSettings: AvailabilityCheckSettingsInput
}

type PublicUpdateWebsiteSuccess {
  """The id of the updated website."""
  id: ID!
}

type Query {
  databaseAgents(databaseInstanceID: String!): [DatabaseAgent!]
  databaseTopQueries(input: DatabaseTopQueriesInput!): [DatabaseTopQueries!]!

  """Profiler root field"""
  databaseProfiler: DatabaseProfiler!
  databaseSessionMetrics(input: DatabaseSessionMetricInput): [DatabaseSessionMetricResponse]!
  databaseQueries(input: DatabaseQueriesInput!): DatabaseQueries!
  databaseQuery(input: DatabaseQueryInput!): DatabaseQuery!
  databaseQueryTraces(input: DatabaseTraceInput!): DatabaseTrace!
  dboQueries: DBOQueries

  """Queries related to entities"""
  entities: EntityQueries!

  """Queries related to events"""
  events: EventQueries!

  """Query for logEvents"""
  logEvents(input: LogEventsInput!): LogEvents!

  """Queries related to metadata"""
  metadata: MetadataQueries!

  """Queries related to metrics"""
  metrics: MetricQueries!
  foo: String
  installationStatus(sessionId: String!): AgentInstallationSession
  otelReceivers(filter: OtelReceiverFilter): [OtelReceiverResponse]
  logArchives(input: ListLogArchivesInput!): LogArchiveConnection!
  logArchiveProviders: [LogArchiveProviderStatus!]!
  logArchiveProviderInstructions(input: LogArchiveProviderInstructionsInput!): LogArchiveProviderInstruction!
  logArchiveFailures: LogArchiveFailure
  listExclusionFilters(input: ListExclusionFilterInput!): [ExclusionFilter!]!
  getExclusionFilter(input: GetExclusionFilterInput!): ExclusionFilter

  """Queries related to Alerting."""
  alertQueries: AlertQueries!

  """
  Queries related to External Alerts (alert instances ingested from external systems, such as *HCO*).
  """
  externalAlertQueries(sources: [ExternalAlertSource!]!): ExternalAlertQueries!
  _: String
  user: AuthenticatedUser!
  dem: DemQueries!
  awsService(id: String!): AwsService
  awsServices: [AwsService!]!
  awsRegions: [AwsRegion!]!
  testAwsAccountExists(arn: String!): Boolean
  testAwsAccountConnection(input: TestAwsAccountConnectionInput!): AwsTestConnectionResult!
  testExistingAwsAccountConnection(input: TestExistingAwsAccountConnectionInput!): AwsTestConnectionResult!
  testAzureAccountExists(domainOrTenantdId: String!): Boolean
  awsCloudFormationRedirectUrl: String!
  azureSessionSubscriptions(sessionId: Guid!): [AzureSubscription!]!
  kubernetesHelmValues(input: KubernetesHelmValuesInput!): KubernetesHelmValuesResponse!
  traceServices(context: TraceContext!, before: String, after: String, filter: TraceServiceItemsFilter, first: Int, last: Int, orderBy: TraceServiceItemsOrderBy! = {direction: ASC, sort: NAME}, traceType: TraceType! = REQUESTS): TraceServiceConnection @deprecated(reason: "Use Trace.services instead")
  apmConfig: ApmConfig
  traceArchive(range: TimeRangeInput, traceId: ID!, spanFilter: TraceArchiveSpanFilter, orderBy: TraceArchiveItemsOrderBy! = {direction: ASC, sort: RELATIVE_START_TIME}): TraceArchive
  traceCacheCalls(context: TraceContext!, after: String, before: String, filter: TraceCacheCallItemsFilter, first: Int, last: Int, orderBy: TraceCacheCallItemsOrderBy! = {direction: DESC, sort: TIME}): TraceCacheCallConnection @deprecated(reason: "Use Trace.cacheCalls instead")
  traceCacheCallSummary(context: TraceContext!, before: String, after: String, filter: TraceCacheCallSummaryFilter, first: Int, last: Int, orderBy: TraceCacheCallSummaryOrderBy! = {direction: ASC, sort: NAME}): TraceCacheCallSummaryConnection @deprecated(reason: "Use Trace.cacheCallSummary instead")
  traceDatabaseQueries(context: TraceContext!, after: String, before: String, filter: TraceDatabaseQueryItemsFilter, first: Int, last: Int, orderBy: TraceDatabaseQueryItemsOrderBy! = {direction: DESC, sort: TIME}): TraceDatabaseQueryConnection @deprecated(reason: "Use Trace.databaseQueries instead")
  traceDatabaseQuerySummary(context: TraceContext!, after: String, before: String, filter: TraceDatabaseQuerySummaryFilter, first: Int, last: Int, orderBy: TraceDatabaseQuerySummaryOrderBy! = {direction: DESC, sort: TOTAL_DURATION}): TraceDatabaseQuerySummaryConnection @deprecated(reason: "Use Trace.databaseQuerySummary instead")
  traceDetails(traceId: ID!, spanId: ID): TraceDetails
  traceExceptions(context: TraceContext!, after: String, before: String, filter: TraceExceptionItemsFilter, first: Int, last: Int, orderBy: TraceExceptionItemsOrderBy! = {direction: DESC, sort: TIME}): TraceExceptionConnection @deprecated(reason: "Use Trace.exceptions instead")
  traceExceptionSummary(context: TraceContext!, after: String, before: String, filter: TraceExceptionSummaryFilter, first: Int, last: Int, orderBy: TraceExceptionSummaryOrderBy! = {direction: DESC, sort: FREQUENCY}): TraceExceptionSummaryConnection @deprecated(reason: "Use Trace.exceptionSummary instead")
  traceHistogram(context: TraceContext!, filter: TraceHistogramFilter, verticalCellCount: Int = 30, traceType: TraceType! = REQUESTS, durationColumn: DurationColumn = SPAN_DURATION): TraceHistogram
  traceHosts(context: TraceContext!, after: String, before: String, filter: TraceHostSummaryFilter, first: Int, last: Int, orderBy: TraceHostSummaryOrderBy! = {direction: DESC, sort: COUNT}, traceType: TraceType! = REQUESTS): TraceHostSummaryConnection @deprecated(reason: "Use Trace.hosts instead")
  traceHttpMethodSummary(context: TraceContext!, after: String, before: String, filter: TraceHttpMethodSummaryFilter, first: Int, last: Int, orderBy: TraceHttpMethodSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}): TraceHttpMethodSummaryConnection @deprecated(reason: "Use Trace.httpMethodSummary instead")
  traceHttpStatusSummary(context: TraceContext!, after: String, before: String, filter: TraceHttpStatusSummaryFilter, first: Int, last: Int, orderBy: TraceHttpStatusSummaryOrderBy! = {direction: ASC, sort: CODE}): TraceHttpStatusSummaryConnection @deprecated(reason: "Use Trace.httpStatusSummary instead")
  traceProfile(traceId: ID!, spanId: ID!, startTimestamp: String!, endTimestamp: String!): TraceProfile
  traceRemoteServiceCalls(context: TraceContext!, after: String, before: String, filter: TraceRemoteServiceCallItemsFilter, first: Int, last: Int, orderBy: TraceRemoteServiceCallItemsOrderBy! = {direction: DESC, sort: TIME}): TraceRemoteServiceCallConnection @deprecated(reason: "Use Trace.remoteServiceCalls instead")
  traceRemoteServiceSummary(context: TraceContext!, after: String, before: String, filter: TraceRemoteServiceSummaryFilter, first: Int, last: Int, orderBy: TraceRemoteServiceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}): TraceRemoteServiceSummaryConnection @deprecated(reason: "Use Trace.remoteServiceSummary instead")
  traceRequests(context: TraceContext!, after: String, before: String, filter: TraceRequestItemsFilter, first: Int, last: Int, orderBy: TraceRequestItemsOrderBy! = {direction: DESC, sort: TIME}): TraceRequestConnection @deprecated(reason: "Use Trace.requests instead")
  traceStacktraceSummary(context: TraceContext!, after: String, before: String, filter: StacktraceSummaryFilter, first: Int, last: Int, orderBy: StacktraceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}): StacktraceSummaryConnection @deprecated(reason: "Use Trace.stacktraceSummary instead")
  traceTail(context: TraceContext!, before: String, after: String, filter: TraceTailFilter, first: Int, last: Int, orderBy: TraceTailOrderBy! = {sort: START_TIME, direction: DESC}): TraceItemTailConnection @deprecated(reason: "Use Trace.tail instead")
  traceTransactions(context: TraceContext!, after: String, before: String, filter: TraceTransactionSummaryFilter, first: Int, last: Int, orderBy: TraceTransactionSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, traceType: TraceType! = REQUESTS): TraceTransactionConnection @deprecated(reason: "Use Trace.transactions instead")
  traceWebsites(context: TraceContext!, after: String, before: String, filter: TraceWebsiteSummaryFilter, first: Int, last: Int, orderBy: TraceWebsiteSummaryOrderBy! = {direction: DESC, sort: COUNT}, traceType: TraceType! = REQUESTS): TraceWebsiteSummaryConnection @deprecated(reason: "Use Trace.websites instead")
  trace: Trace
  netpath: NetPath
  nim: NimQueries
  websiteExploits(websiteUrl: String!): [WebsiteExploit!]
  websiteExploitSummary(websiteUrl: String!): WebsiteExploitSummary!
  dashboards: DashboardQueries
  savedSearches: SavedSearchQueries
  test9: String
  registeredUamsClient(clientId: String): UamsClient
  registeredUamsClients(role: String): [UamsClient!]!
  healthcheck: Boolean
  organizationSettings: OrganizationSettings
  swoUrl: String
  logCollectionDownloadUrl(clientId: String): String
  getPluginInstanceStatus(clientId: String, pluginId: String, pluginInstanceId: String): PluginInstanceStatusCode
}

type QueryItem {
  query: String!
  count: Int!
  averageTime: Float!
  totalTime: Float!
  queryHash: String!
  percentOfTraceDuration: Float
  spanIds: [String!]!
}

"""Measurements result metadata"""
type QueryMetadata {
  query: String
  error: String
  warnings: [String!]
  requestId: String
  plan: String
  planQueries: String
}

enum RBACAccess {
  ALLOW
  DENY
}

enum RBACAction {
  READ
  WRITE
}

type RecentLogSearch {
  id: ID!
  query: String!
  lastSearchedAt: Timestamp!
}

input RegisterWebsiteRequest {
  websiteUrl: String!
}

type RegisterWebsiteResponse {
  code: String!
  message: String
}

"""Result for related entities queries"""
type RelatedEntitiesResult {
  """Collection of entities matching given related entities filter"""
  entities: [Entity!]

  """
  Collection of relationships that were traversed to get to the related entities.
  """
  relationships: [Relationship!]

  """Total count of entities without paging."""
  totalEntitiesCount: Int

  """
  Paging information. The paging is done across relationships. Entities field then contains all entities that participate in those relationships.
  """
  pageInfo: PageInfo!
}

"""Container type exposing related things for entities."""
type RelatedEntityFields {
  """
  List of related entities and/or relationships found by traversing the entities graph according to given filter.
  
  Depending on the used traversal `depth` value the supported behavior is slightly different:
  * `depth <= 1` - Results can be sorted using `sortBy` argument and full paging is supported.
  * `depth > 1` - Sorting is not supported and paging supports only `first` argument.
  """
  entities(traversal: EntityGraphTraversalInput, sortBy: EntitySortInput, paging: PagingInput): RelatedEntitiesResult!

  """
  Get entity metrics of given names. If no names are defined then all relevant metrics are returned.
  """
  metrics(names: [String!], paging: PagingInput): [Metric!]!

  """Search for events"""
  events(query: EventsQueryInput, paging: PagingInput): EventsResponse

  """
  Various statistics queries to get information about the entity based on telemetry data.
  """
  telemetryStatistics: EntityTelemetryStatistics!
}

type RelatesTo implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]
}

"""Base interface for all relationships"""
interface Relationship {
  """Should relationship type be an enum? Can enums be extended?"""
  type: String!

  """
  The relationship is directional and this is the entity from which it starts.
  """
  from: Entity!

  """
  The relationship is directional and this is the entity to which it leads.
  """
  to: Entity!

  """Date and time of relationship creation in UTC."""
  createdTime: String

  """Date and time of last relationship update in UTC."""
  updatedTime: String

  """
  Set of contexts in which this relationship was detected or used.
  Values in the set are Entity IDs of "root" entities from distributed trace from which the
  trace originated.
  """
  contexts: [String!]
}

enum RelationshipDirection {
  OUT
  IN
}

"""Input type for generic relationship queries"""
input RelationshipFilterInput {
  """
  List of relationship types to get. If empty/missing then search is across all relationships.
  """
  types: [String!]

  """
  Optional filter definition. Filter supports only relationship properties, not related entities.
  """
  filter: FilterInput

  """
  Contextual search query string. If used along with filter, relationships must match both filters.
  """
  query: String
}

"""Type describing single relationship type"""
type RelationshipTypeMetadata {
  """Name of the relationship type"""
  type: String!

  """List of all properties with metadata for this relationship type"""
  properties: [PropertyMetadata!]!
}

type RequestDetails implements AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
  headers: [HttpHeader!]!
  body: String
}

type RequestMfaBackupCodesResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  mfaBackupCodes: [MfaBackupCode]!
}

input ResetMfaInput {
  userId: String!
}

type ResourceResponse {
  name: String!
  label: String!
  grouping: String!
  visible: Boolean!
}

type ResponseDetails implements AnalysisDetailsBase {
  durationInMs: Int!
  errorMessage: String
  headers: [HttpHeader!]!
  body: String
}

type Retention {
  name: String!
  retentionPeriods: [RetentionPeriod!]!
}

type RetentionPeriod {
  retention: Int!
  resolution: Int!
}

type Role {
  name: String
}

type RolePermissions {
  role: String!
  permissions: [String!]!
}

type RouterNetworkDeviceExtension {
  """Router Name"""
  caption: String!
}

type RumMonitoring {
  apdexTimeInSeconds: Int
  snippet: String
  spa: Boolean
}

input RumMonitoringInput {
  apdexTimeInSeconds: Int
  spa: Boolean
}

type SamlConfiguration {
  serviceProvider: SamlServiceProvider
  identityProvider: SamlIdentityProvider
  enabled: Boolean
  groupMapping: SamlGroupMappingConfiguration
}

type SamlConfigurationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  invalidFields: [InvalidField!]
  samlConfiguration: SamlConfiguration
}

type SamlGroupMapping {
  orgRoles: [SamlRolesGroups!]
}

type SamlGroupMappingConfiguration {
  enabled: Boolean
}

input SamlGroupMappingConfigurationInput {
  enabled: Boolean
}

type SamlGroupMappingResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  orgRoles: [SamlRolesGroups]
}

type SamlIdentityProvider {
  certificate: SamlIdpCertificate
  issuerURI: String
  samlURL: String
  sloURL: String
}

input SamlIdentityProviderInput {
  certificate: String!
  issuerURI: String!
  samlURL: String!
  sloURL: String!
}

type SamlIdpCertificate {
  plainText: String!
  notAfter: DateTime!
  issuer: String!
}

enum SamlOrganizationMapping {
  MAPPING
}

type SamlRole {
  type: String!
  groups: [String!]!
}

input SamlRoleInput {
  type: String!
  groups: [String]
}

input SamlRolesGroupInput {
  id: String!
  roles: [SamlRoleInput]
}

type SamlRolesGroups {
  id: String!
  roles: [SamlRole!]!
}

type SamlServiceAccountsResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  serviceAccounts: [String!]
}

type SamlServiceProvider {
  audienceURI: String
  acsURL: String
  sloURL: String
}

type SavedLogSearch {
  id: ID!
  name: String!
  query: String!
  editable: Boolean!
  hasAlerts: Boolean!
}

type SavedLogSearchResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  savedSearch: SavedLogSearch
}

type SavedSearch {
  id: ID!
  name: String!
  query: String!
  objectId: String
  context: SavedSearchContext!
  isPrivate: Boolean!
  owner: SavedSearchOwner!
  lastSearchedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  static: Boolean!
}

enum SavedSearchContext {
  Entity
  Entities
  Metric
  Metrics
  Traces
  Logs
  Alerts
  Reports
  CloudIntegration
  Agents
  Events
  Filters
  Dashboards
}

input SavedSearchFilter {
  ownerId: ID
  context: SavedSearchContext
  objectId: String
  isPrivate: Boolean
  type: SavedSearchType
}

type SavedSearchOwner {
  id: ID!
  name: String!
}

type SavedSearchQueries {
  byId(id: ID!): SavedSearch
  search(input: SearchSavedSearchesInput!): SearchSavedSearchesResult!
}

enum SavedSearchType {
  StaticSavedSearch
  UserSavedSearch
  All
}

input ScopeInfo {
  scope: LogsCollectionScope!
  pluginId: String
  pluginInstanceId: String
}

type SearchCategoriesResult {
  categories: [CategoryDashboards!]!
  totalCategoriesCount: Int!
}

type SearchDashboard {
  id: ID!
  name: String!
  description: String
  category: DashboardCategory
  systemReference: ID
  isPrivate: Boolean
  owner: DashboardOwner
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SearchDashboardCategoriesInput {
  name: String
  pagination: PaginationInput
  filter: CategoryFilter
}

input SearchDashboardsInput {
  name: String
  pagination: PaginationInput
  sortBy: SortByInput
  filter: DashboardFilter
}

type SearchDashboardsResult {
  dashboards: [SearchDashboard!]!
  totalDashboardsCount: Int!
}

"""Response type for entity graph search query"""
type SearchEntitiesGraphResult {
  """Collection of entities"""
  entities: [Entity!]

  """Collection of relationships that were traversed during the search."""
  relationships: [Relationship!]

  """Total count of entities without paging."""
  totalEntitiesCount: Int

  """
  Paging information. The paging is done across relationships. Entities field then contains all entities that participate in those relationships.
  """
  pageInfo: PageInfo!
}

"""Response type for entity search query"""
type SearchEntitiesResult {
  """
  Entity groups matching given search filter. If a `groupBy` was not not specified then there is just a single group
  with all the matching entities in it.
  """
  groups: [EntitiesGroup!]!

  """Total count of entities without paging."""
  totalEntitiesCount: Int

  """
  Paging information. Depending on the grouping setting the paging is done differently.
  
  If `groupBy.pagingPerGroup == false` then paging is done across all entities across all groups.
  For example if there are enough entities in the first group the first page may not contain any other groups.
  If the single group is large enough then it can span multiple pages.
  
  If `groupBy.pagingPerGroup == true` then paging is done in each group separately. Then this top-level 
  `pageInfo` is empty and each individual group contains own `pageInfo` that can be used to page each group separately.
  """
  pageInfo: PageInfo!
}

input SearchInput {
  query: String!
  timeRange: TimeRangeInput!
}

"""Response type for relationship search query"""
type SearchRelationshipsResult {
  """Collection of relationships that match given search."""
  relationships: [Relationship!]

  """Total count of relationships without paging."""
  totalRelationshipsCount: Int

  """Paging information."""
  pageInfo: PageInfo!
}

input SearchSavedSearchesInput {
  name: String
  sortBy: SortByInput
  filter: SavedSearchFilter
}

type SearchSavedSearchesResult {
  savedSearches: [SavedSearch!]!
}

input SearchWidgetsInput {
  pagination: PaginationInput
}

scalar Seconds

"""Service entity"""
type Service implements Entity & HealthEntity & SyslogEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Language"""
  language: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Service to Service"""
  relatedServices: [Service!]

  """Relation: Service to ServiceInstance"""
  relatedServiceInstances: [ServiceInstance!]

  """Relation: Service to Host"""
  hosts: [Host!]

  """Relation: Service to Website"""
  relatedWebsites: [Website!]
  healthScore: HealthScore

  """
  The hostname field identifies the machine that originally sent the syslog message.
  """
  syslogHostname: String

  """
  The appName field should identify the device or application that originated the message.
  """
  syslogAppName: String
  technology: String
  description: String
  tags: String

  """Service error count"""
  errors: Metric!

  """Service request count"""
  requests: Metric!

  """Service average response time"""
  responseTime: Metric!

  """Count of sampled requests"""
  sampleCount: Metric!

  """Trace service error ratio"""
  traceServiceErrorRatio: Metric!

  """Trace service reqest rate"""
  traceServiceRequestRate: Metric!

  """Count of traces generated from requests"""
  traceCount: Metric!

  """Aggregated value of responseTime for filtering purposes"""
  responseTimeValue: Float!

  """Aggregated value of traceServiceErrorRatio for filtering purposes"""
  traceServiceErrorRatioValue: Float!

  """Aggregated value of traceServiceRequestRate for filtering purposes"""
  traceServiceRequestRateValue: Float!

  """Number of instance of given service over time"""
  instanceCount: Metric!

  """Number of unique transactions for given service over time"""
  transactionCount: Metric!
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""Service Instance entity"""
type ServiceInstance implements Entity & HealthEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name """
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]
  healthScore: HealthScore

  """Service Instance Id"""
  instanceId: String!

  """Service name"""
  serviceName: String

  """Host name"""
  hostId: String

  """Agent Version"""
  apmVersion: String

  """Language"""
  language: String

  """SDK Name"""
  sdkName: String

  """SDK Version"""
  sdkVersion: String

  """SDK Version"""
  processId: String

  """Relation: Service Instance to Service"""
  service: [Service!]

  """Relation: Service Instance to Host"""
  host: [Host!]

  """Service Instance average response time"""
  responseTime: Metric!

  """Trace service instance error ratio"""
  errorRatio: Metric!

  """Trace service instance reqest rate"""
  requestRate: Metric!

  """Aggregated value of responseTime for filtering purposes"""
  responseTimeValue: Float!

  """
  Aggregated value of traceServiceInstanceErrorRatio for filtering purposes
  """
  errorRatioValue: Float!

  """Aggregated value of traceServiceRequestRate for filtering purposes"""
  requestRateValue: Float!
}

type SessionMeasurement {
  time: String!
  active: Int!
  idle: Int!
}

type SessionTimeout {
  """number of seconds until session is expired"""
  timeout: Int
}

type SessionTimeoutResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!

  """number of seconds until session is expired"""
  timeout: Int
}

input SetDatabaseCredentialsRequest {
  databaseInstanceID: String!
  credentials: [KeyValue!]
}

type SetDatabaseCredentialsResponse {
  code: String!
  message: String
}

union SetEntityDisplayNameResult = SetEntityDisplayNameSuccess | EntityMutationError

type SetEntityDisplayNameSuccess {
  """Updated entity ID"""
  id: ID!

  """New entity display name"""
  displayName: String
}

union SetEntitySyslogAppNameResult = SetEntitySyslogAppNameSuccess | EntityMutationError

type SetEntitySyslogAppNameSuccess {
  """Updated entity ID"""
  id: ID!

  """New entity syslogAppName"""
  syslogAppName: String
}

union SetEntitySyslogHostnameResult = SetEntitySyslogHostnameSuccess | EntityMutationError

type SetEntitySyslogHostnameSuccess {
  """Updated entity ID"""
  id: ID!

  """New entity syslogHostname"""
  syslogHostname: String
}

type SlackAuthorizeUrlResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  url: String!
}

input SortByInput {
  direction: SortDirection!
  key: String!
}

enum SortBySavedSearches {
  name
  context
  query
  updatedAt
}

"""Sort direction for query result sorting"""
enum SortDirection {
  ASC
  DESC
}

"""
Query sort definition. Sort support multiple properties and two sort directions.
"""
input SortInput {
  sorts: [SortItemInput!]!
}

"""Single property sort definition."""
input SortItemInput {
  propertyName: String!
  direction: SortDirection
}

type SpanRelatedEntity {
  type: SpanRelatedEntityType!
  id: String!
  name: String
}

enum SpanRelatedEntityType {
  SERVICE
  SERVICE_INSTANCE
  WEBSITE
  HOST
  CONTAINER
}

type SpanSummary {
  id: ID!
  service: String!
  transaction: String
  method: String
  status: String
  duration: String!
  startTime: String!
  errorCount: Int!
  host: String
  controller: String
  action: String
  serviceEntity: String
  hostEntity: String
  websiteEntity: String
  serviceInstanceEntity: String
  containerEntity: String
  serviceEntityName: String
  hostEntityName: String
  websiteEntityName: String
  serviceInstanceEntityName: String
  containerEntityName: String
}

type SslCertificate {
  name: String!
  validTo: String!
  certificate: String!
}

type SslCertificates implements Validation {
  type: ValidationType!
  status: ValidationStatus!
  minTimeValid: Int!
  certificates: SslCertificatesByStatus
}

type SslCertificatesByStatus {
  expired: [SslCertificate!]!
  expiring: [SslCertificate!]!
  invalid: [SslCertificate!]!
  valid: [SslCertificate!]!
}

type SslMonitoring {
  daysPriorToExpiration: Int
  enabled: Boolean
  ignoreIntermediateCertificates: Boolean!
}

input SslMonitoringInput {
  """
  Whether SSL monitoring is enabled for the website.
  
  If set to false, SSL monitoring will be disabled, but the other settings will be remembered in
  case you re-enable it later.
  
  If omitted, the previous setting will stay in effect. If there is no previous setting, the value
  will default to false.
  """
  enabled: Boolean

  """
  Number of days before the expiration date an SSL certificate will be considered 'expiring.'
  """
  daysPriorToExpiration: Int

  """
  Use this option to limit the certificate expiration check to only the first certificate in the
  chain (normally the host certificate). This way you will not be warned about impending expiration
  of intermediate or root Certification Authority certificates in the chain.
  
  This option does not affect any other certificate validity checks besides expiration.
  
  If omitted, the previous setting will stay in effect. If there is no previous setting, the value
  will default to false.
  """
  ignoreIntermediateCertificates: Boolean
}

type StacktraceSummary implements TraceSpanSummary {
  id: ID!
  name: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
  transaction: String!
  stacktrace: String!
  classMessageBacktraceHash: String!
  exceptionClass: String!
  exceptionClassMessageHash: String!
  exceptionMessage: String!
  lastOccurred: String!
  lastTraceId: String!
  lastTraceSpanId: String!
}

type StacktraceSummaryConnection {
  edges: [StacktraceSummaryEdge!]
  pageInfo: PageInfo!
}

type StacktraceSummaryEdge {
  cursor: String!
  node: StacktraceSummary!
}

input StacktraceSummaryFilter {
  exceptionClass: String
  exceptionClassMessageBacktraceHash: String
  exceptionClassMessageHash: String
  id: String
  transaction: String
}

input StacktraceSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: StacktraceSummarySort! = AVERAGE_DURATION
}

enum StacktraceSummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
}

"""State of entity"""
type State {
  """
  State of the entity as it is reported (as opposed to normalizedState which will be added later)
  """
  nativeState: String
}

"""The base interface for entities with state"""
interface StatefulEntity {
  id: ID!

  """State of entity"""
  state: State
}

"""The group will contain only the entities listed here."""
type StaticEntityGroupDefinition {
  staticMemberIds: [ID!]!
}

"""String representation of the value."""
type StringKeyValuePair implements EventKeyValuePair {
  key: String!
  value: String! @deprecated(reason: "Only for backwards compatibility, will be removed in favor of typed values (valueString)")
  valueString: String!
}

interface SwicusUser {
  id: ID!
  email: String!
  firstName: String
  lastName: String
  lastLogin: DateTime
  emailVerified: Boolean!
}

type SwitchNetworkDeviceExtension {
  """Switch name"""
  name: String
}

"""
The base interface for entities with syslog log events.
When searching for log events of entity implementing this interface, the system looks
for any syslog event matching parameters declared by the entity.
"""
interface SyslogEntity {
  id: ID!

  """
  The hostname field identifies the machine that originally sent the syslog message.
  """
  syslogHostname: String

  """
  The appName field should identify the device or application that originated the message.
  """
  syslogAppName: String
}

"""Tag key and value used when grouping measurement streams"""
type Tag {
  key: String!
  value: String!
}

input TagCredentialInput {
  key: String!
  value: String!
}

enum TailingEdge {
  Top
  Bottom
}

"""Enum defining how the telemetry mapping condition should be evaluated."""
enum TelemetryMappingConditionEvaluationMethod {
  """
  Condition means that telemetry should contain given key. This is the default.
  """
  CONTAINS

  """Condition means that telemetry should NOT contain given key."""
  DOESNT_CONTAIN
}

"""Condition used to match an entity type to a telemetry attributes."""
input TelemetryMappingConditionInput {
  """Key of telemetry resource attribute to check."""
  key: String!

  """
  Allowed values of given telemetry resource attribute. Multiple values are used in OR relation.
  Example: my.key=["value1", "value2"] => my.key="value1" OR my.key="value2".
  If the values are empty then the condition is evaluated as "if there is a resource attribute with this key then it's a match".
  """
  values: [String!]

  """
  Property defining how the telemetry mapping condition should be evaluated.
  """
  evaluationMethod: TelemetryMappingConditionEvaluationMethod = CONTAINS
}

type Tenant {
  status: TenantStatus!
  statusEnd: Timestamp!
  retrialAfter: Timestamp!
}

enum TenantStatus {
  TRIAL
  ACTIVE
  SUSPENDED
}

input TestAwsAccountConnectionInput {
  arn: String!
  externalId: String!
}

input TestExistingAwsAccountConnectionInput {
  arn: String!
  entityId: String!
}

input TestNotificationServiceConfigurationInput {
  type: String!
  id: String
  description: String
  settings: JSON
  template: JSON
}

type TestNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
}

"""Thin Access Point"""
type ThinAccessPoint implements Entity & WirelessAccessPoint & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Universal Resource Identifier of Access Point within Orion"""
  uri: String!

  """Access Point IP Address"""
  ipAddress: String

  """Relation: Wireless Interfaces of Access Point"""
  interfaces: [WirelessInterface]

  """Relation: Network Device (WirelessController) to Thin Access Point"""
  controller: NetworkDevice
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

"""
Type representing a time range for queries.

Accepted datetime formats:
    * relative values: 
        * 1 day ago
        * last wednesday
    * absolute values: 
        * 2022-02-25T12:13:14 - UTC time
        * 2022-02-25T12:13:14Z - UTC time
        * 2022-02-25T12:13:14+00:00 - UTC time
        * 2022-02-25T14:13:14+02:00 - local time (UTC+2)
        * 2/25/2022 - UTC
        * 1645776702000 - Unix timestamp in milliseconds
"""
input TimeRangeInput {
  """End of a time range - exclusive"""
  endTime: String

  """Beginning of a time range - inclusive."""
  startTime: String
}

type TimeSeriesSample {
  time: Timestamp!
  value: Float!
}

type TimeSeriesSampleMs {
  time: TimestampMs!
  value: Float!
}

scalar Timestamp

scalar TimestampMs

input ToggleLogFilterInput {
  filterId: ID!
  enabled: Boolean!
}

type Token {
  """The ID of the Token. Known internally to Swoken as "signature"."""
  id: ID!

  """The Organization ID of the Token."""
  orgId: String

  """The name of the Token. Generated from user input."""
  name: String

  """The plain-text token of the Token."""
  token: String

  """The obfuscated token of the Token."""
  obfuscatedToken: String

  """
  The access level of the Token. Available access levels must be one of read, record, or full.
  """
  accessLevel: TokenAccessLevel

  """The enabled state of the Token."""
  enabled: Boolean

  """
  The type of the Token. Internal field in Swoken to support multiple types of tokens, e.g. admin, azure_integration, etc.
  """
  type: String

  """
  The secure state of the Token. Secure tokens are only revealed to the user once at creation and cannot be unobfuscated.
  """
  secure: Boolean

  """The date of when the Token was created."""
  createdAt: DateTime

  """The date of when the Token was last updated."""
  updatedAt: DateTime

  """The date of when the Token was last used."""
  usedAt: DateTime

  """The SWICUS user that did create this token."""
  createdBy: String

  """The SWICUS user name that did create this token."""
  createdByName: String
}

enum TokenAccessLevel {
  RECORD
  READ
  FULL
}

"""Type of Simple netflow metric to query"""
enum TopNetflowMetric {
  TopProtocols
  TopApplications
  TopAdvancedApplications
  TopEndpoints
  TopCountries
}

input TopNetflowSourcesInput {
  """
  Sets the top limit of netflow sources with highest flows traffic to retrieve.
  """
  limit: Int!

  """Sets time range to load netflow data from"""
  timeFilter: TimeRangeInput!

  """Input used to construct dynamic filters"""
  advancedFilter: AdvancedNetflowFilter
}

"""
The topology connection relation type used in topology data processing in the Topology service.
Represents a connection on L2 layer of the OSI model.
"""
type TopologyConnectionL2 implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]

  """
  UAMS Client IDs of topology data sources.
  Topology data sources are Network collector UAMS client plugins.
  """
  uamsClients: [String!]!

  """Array of interface ids of the 'from' connection."""
  fromInterfaceIdArray: [String]

  """Array of interface ids of the 'to' connection."""
  toInterfaceIdArray: [String]
}

"""
The topology connection relation type used in topology data processing in the Topology service.
Represents a connection on L3 layer of the OSI model.
"""
type TopologyConnectionL3 implements Relationship {
  type: String!
  from: Entity!
  to: Entity!
  createdTime: String
  updatedTime: String
  contexts: [String!]

  """
  UAMS Client IDs of topology data sources.
  Topology data sources are Network collector UAMS client plugins.
  """
  uamsClients: [String!]!

  """Array of interface ids of the 'from' connection."""
  fromInterfaceIdArray: [String]

  """Array of interface ids of the 'to' connection."""
  toInterfaceIdArray: [String]
}

type Trace {
  noop: String
  cacheCalls(context: TraceQueryContext!, search: SearchInput!, filter: TraceCacheCallItemsFilter, orderBy: TraceCacheCallItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput): TraceCacheCallConnection
  cacheCallSummary(context: TraceQueryContext!, search: SearchInput!, filter: TraceCacheCallSummaryFilter, orderBy: TraceCacheCallSummaryOrderBy! = {direction: ASC, sort: NAME}, paging: PagingInput): TraceCacheCallSummaryConnection
  databaseQueries(context: TraceQueryContext!, search: SearchInput!, filter: TraceDatabaseQueryItemsFilter, orderBy: TraceDatabaseQueryItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput): TraceDatabaseQueryConnection
  databaseQuerySummary(context: TraceQueryContext!, search: SearchInput!, filter: TraceDatabaseQuerySummaryFilter, orderBy: TraceDatabaseQuerySummaryOrderBy! = {direction: DESC, sort: TOTAL_DURATION}, paging: PagingInput): TraceDatabaseQuerySummaryConnection
  exceptions(context: TraceQueryContext!, search: SearchInput!, filter: TraceExceptionItemsFilter, orderBy: TraceExceptionItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput): TraceExceptionConnection
  exceptionSummary(context: TraceQueryContext!, search: SearchInput!, filter: TraceExceptionSummaryFilter, orderBy: TraceExceptionSummaryOrderBy! = {direction: DESC, sort: FREQUENCY}, paging: PagingInput): TraceExceptionSummaryConnection
  histogram(context: TraceQueryContext!, search: SearchInput!, filter: TraceHistogramFilter, verticalCellCount: Int = 30, traceType: TraceType! = REQUESTS, durationColumn: DurationColumn = SPAN_DURATION): TraceHistogram
  hosts(context: TraceQueryContext!, search: SearchInput!, filter: TraceHostSummaryFilter, traceType: TraceType! = REQUESTS, orderBy: TraceHostSummaryOrderBy! = {direction: DESC, sort: COUNT}, paging: PagingInput): TraceHostSummaryConnection
  httpMethodSummary(context: TraceQueryContext!, search: SearchInput!, filter: TraceHttpMethodSummaryFilter, orderBy: TraceHttpMethodSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput): TraceHttpMethodSummaryConnection
  httpStatusSummary(context: TraceQueryContext!, search: SearchInput!, filter: TraceHttpStatusSummaryFilter, orderBy: TraceHttpStatusSummaryOrderBy! = {direction: ASC, sort: CODE}, paging: PagingInput): TraceHttpStatusSummaryConnection
  remoteServiceCalls(context: TraceQueryContext!, search: SearchInput!, filter: TraceRemoteServiceCallItemsFilter, orderBy: TraceRemoteServiceCallItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput): TraceRemoteServiceCallConnection
  remoteServiceSummary(context: TraceQueryContext!, search: SearchInput!, filter: TraceRemoteServiceSummaryFilter, orderBy: TraceRemoteServiceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput): TraceRemoteServiceSummaryConnection
  requests(context: TraceQueryContext!, search: SearchInput!, filter: TraceRequestItemsFilter, orderBy: TraceRequestItemsOrderBy! = {direction: DESC, sort: TIME}, paging: PagingInput): TraceRequestConnection
  services(context: TraceQueryContext!, search: SearchInput!, filter: TraceServiceItemsFilter, traceType: TraceType! = REQUESTS, orderBy: TraceServiceItemsOrderBy! = {direction: ASC, sort: NAME}, paging: PagingInput): TraceServiceConnection
  stacktraceSummary(context: TraceQueryContext!, search: SearchInput!, filter: StacktraceSummaryFilter, orderBy: StacktraceSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput): StacktraceSummaryConnection
  tail(context: TraceQueryContext!, search: SearchInput!, filter: TraceTailFilter, orderBy: TraceTailOrderBy! = {sort: START_TIME, direction: DESC}, paging: PagingInput): TraceItemTailConnection
  transactions(context: TraceQueryContext!, search: SearchInput!, filter: TraceTransactionSummaryFilter, traceType: TraceType! = REQUESTS, orderBy: TraceTransactionSummaryOrderBy! = {direction: DESC, sort: AVERAGE_DURATION}, paging: PagingInput): TraceTransactionConnection
  websites(context: TraceQueryContext!, search: SearchInput!, filter: TraceWebsiteSummaryFilter, traceType: TraceType! = REQUESTS, orderBy: TraceWebsiteSummaryOrderBy! = {direction: DESC, sort: COUNT}, paging: PagingInput): TraceWebsiteSummaryConnection
}

type TraceArchive {
  traceId: ID!
  transaction: String
  service: String
  startTime: String
  endTime: String
  profilingSupported: Boolean
  bucketRate: Float
  bucketCapacity: Int
  sampleRate: Float
  sampleSource: Int
  layerCounts: TraceArchiveLayerCounts
  eventSummary: TraceArchiveEventSummary
  traceSpans(after: String, before: String, first: Int, last: Int): TraceSpanConnection
}

type TraceArchiveEventSummary {
  eventSummaryItems: [TraceArchiveEventSummaryItem]!
}

type TraceArchiveEventSummaryItem {
  layer: String
  label: String
  service: String
  spanId: String
  eventId: String!
}

input TraceArchiveItemsOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceArchiveItemsSort! = RELATIVE_START_TIME
}

enum TraceArchiveItemsSort {
  LABEL
  DURATION
  RELATIVE_START_TIME
}

type TraceArchiveLayerCounts {
  layerCountItems: [TraceArchiveLayerCountsItem]!
}

type TraceArchiveLayerCountsItem {
  layer: String!
  entry: Int!
  info: Int!
  error: Int!
  exit: Int!
}

input TraceArchiveSpanFilter {
  id: String
  label: String
  queryHash: String
  exceptionClassMessageHash: String
}

type TraceBreakdownItem {
  layer: String!
  duration: Float!
  percentOfTraceDuration: Float
  spanCount: Int!
  errorCount: Int!
}

enum TraceBreakdownItemsSort {
  LAYER
  DURATION
  PERCENT_OF_TRACE_DURATION
  SPAN_COUNT
  ERROR_COUNT
}

input TraceBreakdownOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceBreakdownItemsSort! = LAYER
}

type TraceCacheCall implements TraceSpanItem {
  id: ID!
  transaction: String
  traceId: String!
  spanId: String
  service: String!
  serviceEntityId: String!
  websiteId: String
  hostname: String
  hostEntityId: String
  hostEntityName: String
  websiteEntityName: String
  time: String!
  duration: TraceDuration!
  traceDuration: TraceDuration!
  spanDuration: TraceDuration!
  cache: String!
  cacheHost: String!
  cacheOp: String!
}

type TraceCacheCallConnection {
  edges: [TraceCacheCallEdge!]
  pageInfo: PageInfo!
}

type TraceCacheCallEdge {
  cursor: String!
  node: TraceCacheCall!
}

input TraceCacheCallItemsFilter {
  caches: [String!]
  cacheHosts: [String!]
  cacheOps: [String!]
  maxResponseTime: Int
  minResponseTime: Int
  transactions: [String!]
}

input TraceCacheCallItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceCacheCallItemsSort! = TIME
}

enum TraceCacheCallItemsSort {
  TIME
  DURATION
  TRACE_DURATION
  SPAN_DURATION
}

type TraceCacheCallSummary implements TraceSpanSummary {
  id: ID!
  name: String
  cacheOp: String
  cacheHost: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  serviceInstanceName: String
  serviceInstanceId: String
  relativeCountPercentage: String!
  totalDuration: TraceDuration!
}

type TraceCacheCallSummaryConnection {
  edges: [TraceCacheCallSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceCacheCallSummaryEdge {
  cursor: String!
  node: TraceCacheCallSummary!
}

input TraceCacheCallSummaryFilter {
  caches: [String!]
  cacheHosts: [String!]
  cacheOps: [String!]
  transactions: [String!]
  serviceInstanceIds: [String!]
  searchText: String
}

input TraceCacheCallSummaryOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceCacheCallSummarySort! = NAME
}

enum TraceCacheCallSummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  RELATIVE_COUNT_PERCENTAGE
  TOTAL_DURATION
  CACHE_OP
  CACHE_HOST
  SERVICE_INSTANCE_ID
}

type TraceClientCacheSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  cacheHostname: String
  cacheHostEntityId: String
  cacheName: String
  cacheEntityId: String
  cacheKey: String
  cacheOperation: String
  cacheVendor: String
  cacheHit: Boolean
}

type TraceClientHttpRequestSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  requestProtocol: String
  requestMethod: String
  requestAction: String
  requestController: String
  requestOperation: String
  requestUri: String
  peerDomain: String
  peerDomainEntityId: String
  peerHostname: String
  peerHostEntityId: String
  peerService: String
  peerServiceEntityId: String
  responseCode: String!
  responseMessage: String
}

type TraceClientProtocolRequestSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  requestProtocol: String
  requestAction: String
  requestController: String
  requestOperation: String
  requestUri: String
  peerDomain: String
  peerDomainEntityId: String
  peerHostname: String
  peerHostEntityId: String
  peerService: String
  peerServiceEntityId: String
  responseCode: String!
  responseMessage: String
}

type TraceClientQuerySpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  databaseHostname: String
  databaseHostEntityId: String
  databaseName: String
  databaseEntityId: String
  databaseClusterName: String
  databaseClusterId: String
  databaseTable: String
  databaseColumnSet: String
  databasePartition: String
  databaseKeyspace: String
  databaseConnectionPool: String
  databaseCallConsistency: String
  databaseQuery: String
  databaseQueryArguments: String
  databaseOperation: String
  databaseVendor: String
  databaseQueryHash: String
}

type TraceConsumerSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  queueName: String
  queueEntityId: String
  queueCoordinationGroup: String
  queueHost: String
  queueHostEntityId: String
  queuePort: Int
  queueVendor: String!
  queueItemTransaction: String
  queueItemPartition: String
  queueItemIdentifier: String
}

input TraceContext {
  serviceNames: [String!]
  serviceEntityIds: [String!]
  range: TimeRangeInput!
  hostEntityIds: [String!]
  websiteIds: [String!]
}

type TraceDatabaseQuery implements TraceSpanItem {
  id: ID!
  transaction: String
  traceId: String!
  spanId: String
  service: String!
  serviceEntityId: String!
  websiteId: String
  hostname: String
  hostEntityId: String
  hostEntityName: String
  websiteEntityName: String
  time: String!
  duration: TraceDuration!
  traceDuration: TraceDuration!
  spanDuration: TraceDuration!
  database: String!
  databaseEntityId: String
  databaseHostname: String!
  databaseHostEntityId: String
  queryOp: String!
  queryTable: String!
}

type TraceDatabaseQueryConnection {
  edges: [TraceDatabaseQueryEdge!]
  pageInfo: PageInfo!
}

type TraceDatabaseQueryEdge {
  cursor: String!
  node: TraceDatabaseQuery!
}

input TraceDatabaseQueryItemsFilter {
  transactions: [String!]
  databases: [String!]
  databaseHosts: [String!]
  queryOps: [String!]
  queryTables: [String!]
  maxResponseTime: Int
  minResponseTime: Int
}

input TraceDatabaseQueryItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceDatabaseQueryItemsSort! = DURATION
}

enum TraceDatabaseQueryItemsSort {
  TIME
  DURATION
  TRACE_DURATION
  SPAN_DURATION
}

type TraceDatabaseQuerySummary implements TraceSpanSummary {
  id: ID!
  name: String
  queryOp: String
  queryTable: String
  databaseHost: String
  serviceInstanceName: String
  serviceInstanceId: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
  relativeCountPercentage: String!
}

type TraceDatabaseQuerySummaryConnection {
  edges: [TraceDatabaseQuerySummaryEdge!]
  pageInfo: PageInfo!
}

type TraceDatabaseQuerySummaryEdge {
  cursor: String!
  node: TraceDatabaseQuerySummary!
}

input TraceDatabaseQuerySummaryFilter {
  databases: [String!]
  databaseHosts: [String!]
  queryOps: [String!]
  queryTables: [String!]
  transactions: [String!]
  serviceInstanceIds: [String!]
  searchText: String
}

input TraceDatabaseQuerySummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceDatabaseQuerySummarySort! = TOTAL_DURATION
}

enum TraceDatabaseQuerySummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
  QUERY_OPERATION
  QUERY_TABLE
  RELATIVE_COUNT_PERCENTAGE
  DATABASE_HOST
  SERVICE_INSTANCE_ID
}

type TraceDetails {
  traceId: ID!
  time: String!
  duration: String!
  transaction: String!
  controller: String
  action: String
  spanCount: Int!
  waterfall: [WaterfallRow!]!
  originSpan: SpanSummary!
  selectedSpan: SpanSummary
  traceBreakdown(orderBy: TraceBreakdownOrderBy! = {direction: ASC, sort: LAYER}): [TraceBreakdownItem!]
  allErrors(orderBy: TraceErrorOrderBy! = {direction: ASC, sort: LAYER}): [ErrorItem!]
  allQueries(orderBy: TraceQueryOrderBy! = {direction: ASC, sort: QUERY}): [QueryItem!]
}

type TraceDuration {
  value: String!
  units: TraceTimeScale!
}

type TraceError {
  type: String
  timestamp: String
  message: String
  backtrace: String
  exceptionClassMessageHash: String
}

enum TraceErrorItemsSort {
  TIME
  MESSAGE
  LAYER
  HOSTNAME
}

input TraceErrorOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceErrorItemsSort! = LAYER
}

type TraceEvent {
  eventId: ID!
  properties: [TracePair!]
}

type TraceEventConnection {
  edges: [TraceEventEdge!]
  pageInfo: PageInfo!
}

type TraceEventEdge {
  cursor: String!
  node: TraceEvent
}

type TraceException implements TraceSpanItem {
  id: ID!
  transaction: String
  traceId: String!
  spanId: String
  service: String!
  serviceEntityId: String!
  websiteId: String
  websiteEntityName: String
  hostname: String
  hostEntityId: String
  hostEntityName: String
  time: String!
  duration: TraceDuration!
  eventId: String!
  exceptionClass: String!
  exceptionClassMessageHash: String!
  exceptionMessage: String!
  httpMethod: String!
  httpStatus: String!
}

type TraceExceptionConnection {
  edges: [TraceExceptionEdge!]
  pageInfo: PageInfo!
}

type TraceExceptionEdge {
  cursor: String!
  node: TraceException!
}

input TraceExceptionItemsFilter {
  transactions: [String!]
  exceptionClasses: [String!]
  exceptionClassMessageHashes: [String!]
  maxDurationTime: Int
  minDurationTime: Int
}

input TraceExceptionItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceExceptionItemsSort! = DURATION
}

enum TraceExceptionItemsSort {
  EXCEPTION_CLASS
  EXCEPTION_MESSAGE
  HTTP_METHOD
  HTTP_STATUS
  TIME
  DURATION
  TRANSACTION
}

type TraceExceptionSummary implements TraceSpanSummary {
  id: ID!
  name: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
  serviceInstanceName: String
  serviceInstanceId: String
  relativeCountPercentage: String!
  exceptionClass: String!
  exceptionClassMessageHash: String!
  exceptionMessage: String!
  firstOccurred: String
  lastOccurred: String
  lastTraceId: String
  lastTraceSpanId: String
  transactions: [String!]
}

type TraceExceptionSummaryConnection {
  edges: [TraceExceptionSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceExceptionSummaryEdge {
  cursor: String!
  node: TraceExceptionSummary!
}

input TraceExceptionSummaryFilter {
  exceptionClassMessageHash: String
  exceptionClasses: [String!]
  id: String
  transactions: [String!]
  serviceInstanceIds: [String!]
  searchText: String
}

input TraceExceptionSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceExceptionSummarySort! = FREQUENCY
}

enum TraceExceptionSummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
  RELATIVE_COUNT_PERCENTAGE
  EXCEPTION_CLASS
  EXCEPTION_MESSAGE
  FIRST_OCCURRED
  LAST_OCCURRED
  SERVICE_INSTANCE_ID
}

enum TraceFileOperation {
  OPEN
  READ
  WRITE
  CLOSE
  DELETE
  READ_METADATA
  WRITE_METADATA
  COMPOUND
}

enum TraceFileType {
  FILE
  DIRECTORY
  SYMLINK
  HARDLINK
  SOCKET
  NAMED_PIPE
  SHARED_MEMORY
}

type TraceFrequency {
  value: Float!
  units: TraceTimeScale!
}

type TraceHistogram {
  series: [TraceHistogramColumn!]!
  maxDuration: Int!
  maxCount: Int!
}

type TraceHistogramColumn {
  timestamp: String!
  timestampEnd: String!
  histogram: [TraceHistogramEntry!]!
}

type TraceHistogramEntry {
  duration: Int!
  durationUpperBound: Int!
  count: Int!
}

input TraceHistogramFilter {
  httpMethod: String
  httpStatus: String
  transactions: [String!]
  remoteServices: [String!]
  remoteServiceOps: [String!]
  remoteServiceTypes: [String!]
  caches: [String!]
  cacheHosts: [String!]
  cacheOps: [String!]
  databases: [String!]
  databaseHosts: [String!]
  queryOps: [String!]
  queryTables: [String!]
  exceptionClassMessageHashes: [String!]
}

type TraceHost {
  hostEntityId: String!
  hostEntityName: String!
  count: String!
}

type TraceHostSummaryConnection {
  edges: [TraceHostSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceHostSummaryEdge {
  cursor: String!
  node: TraceHost!
}

input TraceHostSummaryFilter {
  transactions: [String!]
}

input TraceHostSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceHostSummarySort! = COUNT
}

enum TraceHostSummarySort {
  COUNT
}

type TraceHttpMethodSummary implements TraceSpanSummary {
  id: ID!
  name: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
}

type TraceHttpMethodSummaryConnection {
  edges: [TraceHttpMethodSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceHttpMethodSummaryEdge {
  cursor: String!
  node: TraceHttpMethodSummary!
}

input TraceHttpMethodSummaryFilter {
  name: String
}

input TraceHttpMethodSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceHttpMethodSummarySort! = AVERAGE_DURATION
}

enum TraceHttpMethodSummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
}

type TraceHttpStatusSummary implements TraceSpanSummary {
  id: ID!
  name: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
  code: Int
  codeWithText: String
  text: String
}

type TraceHttpStatusSummaryConnection {
  edges: [TraceHttpStatusSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceHttpStatusSummaryEdge {
  cursor: String!
  node: TraceHttpStatusSummary!
}

input TraceHttpStatusSummaryFilter {
  code: String
}

input TraceHttpStatusSummaryOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceHttpStatusSummarySort! = CODE
}

enum TraceHttpStatusSummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
  CODE
}

type TraceInternalSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
}

type TraceIOSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  ioFileType: TraceFileType!
  ioOperation: TraceFileOperation!
  ioPath: String!
  ioFileName: String!
  ioDevice: String
}

type TraceItemTailConnection {
  edges: [TraceItemTailEdge!]
  pageInfo: PageInfo!
}

type TraceItemTailEdge {
  cursor: String!
  node: TraceRecord!
}

type TracePair {
  key: String
  value: String
}

type TraceProducerSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  queueName: String
  queueEntityId: String
  queueHost: String
  queueHostEntityId: String
  queuePort: Int
  queueVendor: String!
  queueItemTransaction: String
  queueItemPartition: String
  queueItemIdentifier: String
}

type TraceProfile {
  entries: [ProfileEntry!]!
}

type TraceProfileSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  profileStacks: [[TraceProfileStackEntry!]!]
}

type TraceProfileStackEntry {
  file: String
  encapsulation: String
  function: String
  lineNumber: Int
}

input TraceQueryContext {
  serviceNames: [String!]
  serviceEntityIds: [String!]
  hostEntityIds: [String!]
  websiteIds: [String!]
}

enum TraceQueryItemsSort {
  QUERY
  COUNT
  AVERAGE_TIME
  TOTAL_TIME
}

input TraceQueryOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceQueryItemsSort! = QUERY
}

type TraceRecord {
  id: ID!
  traceId: String!
  transaction: String
  time: String!
  duration: TraceDuration!
}

type TraceRemoteServiceCall implements TraceSpanItem {
  id: ID!
  transaction: String
  traceId: String!
  spanId: String
  service: String!
  serviceEntityId: String!
  websiteId: String
  hostname: String
  hostEntityId: String
  hostEntityName: String
  websiteEntityName: String
  time: String!
  duration: TraceDuration!
  traceDuration: TraceDuration!
  spanDuration: TraceDuration!
  remoteService: String!
  remoteServiceOp: String!
  remoteServiceType: String!
}

type TraceRemoteServiceCallConnection {
  edges: [TraceRemoteServiceCallEdge!]
  pageInfo: PageInfo!
}

type TraceRemoteServiceCallEdge {
  cursor: String!
  node: TraceRemoteServiceCall!
}

input TraceRemoteServiceCallItemsFilter {
  maxResponseTime: Int
  minResponseTime: Int
  remoteServices: [String!]
  remoteServiceOps: [String!]
  remoteServiceTypes: [String!]
  transactions: [String!]
}

input TraceRemoteServiceCallItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceRemoteServiceCallItemsSort! = DURATION
}

enum TraceRemoteServiceCallItemsSort {
  TIME
  DURATION
  TRACE_DURATION
  SPAN_DURATION
}

type TraceRemoteServiceSummary implements TraceSpanSummary {
  id: ID!
  name: String
  remoteServiceOp: String
  remoteServiceType: String
  serviceInstanceId: String
  serviceInstanceName: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
  relativeCountPercentage: String!
}

type TraceRemoteServiceSummaryConnection {
  edges: [TraceRemoteServiceSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceRemoteServiceSummaryEdge {
  cursor: String!
  node: TraceRemoteServiceSummary!
}

input TraceRemoteServiceSummaryFilter {
  remoteServices: [String!]
  remoteServiceOps: [String!]
  remoteServiceTypes: [String!]
  transactions: [String!]
  serviceInstanceIds: [String!]
  searchText: String
}

input TraceRemoteServiceSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceRemoteServiceSummarySort! = AVERAGE_DURATION
}

enum TraceRemoteServiceSummarySort {
  NAME
  REMOTE_SERVICE_OP
  REMOTE_SERVICE_TYPE
  SERVICE_INSTANCE_ID
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
  RELATIVE_COUNT_PERCENTAGE
}

type TraceRequest implements TraceSpanItem {
  id: ID!
  transaction: String
  traceId: String!
  spanId: String
  service: String!
  serviceEntityId: String!
  websiteId: String
  hostname: String
  hostEntityId: String
  hostEntityName: String
  websiteEntityName: String
  time: String!
  duration: TraceDuration!
  httpStatus: String
  httpMethod: String
  serviceUrlDomain: String
  serviceUrlPath: String
  traceUrlDomain: String
  traceUrlPath: String
}

type TraceRequestConnection {
  edges: [TraceRequestEdge!]
  pageInfo: PageInfo!
}

type TraceRequestEdge {
  cursor: String!
  node: TraceRequest!
}

input TraceRequestItemsFilter {
  host: String
  httpStatus: String
  id: String
  maxResponseTime: Int
  minResponseTime: Int
  serviceUrlDomain: String
  serviceUrlPath: String
  traceUrlDomain: String
  traceUrPath: String
  transactions: [String!]
  exceptionClassMessageHash: String
}

input TraceRequestItemsOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceRequestItemsSort! = TIME
}

enum TraceRequestItemsSort {
  TIME
  HTTP_STATUS
  DURATION
}

type TraceServerHttpSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  requestProtocol: String
  requestAction: String
  requestCommand: String
  requestController: String
  requestOriginalUri: String
  requestUrl: String
  requestUrlPath: String
  requestUrlQueryString: String
  requestTraceMetadata: [TracePair!]
  requestMethod: String
  responseCode: String!
  responseMessage: String
}

type TraceServerProtocolSpan implements TraceSpan {
  id: ID!
  traceId: String!
  transaction: String
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
  requestProtocol: String
  requestAction: String
  requestCommand: String
  requestController: String
  requestHostname: String
  requestOriginalUri: String
  requestUrl: String
  requestUrlPath: String
  requestUrlQueryString: String
  requestTraceMetadata: [TracePair!]
  requestMethod: String
  responseCode: String!
  responseMessage: String
}

type TraceService {
  id: ID!
  name: String!
  lastSeen: String
  count: String!
}

type TraceServiceConnection {
  edges: [TraceServiceEdge!]
  pageInfo: PageInfo!
}

type TraceServiceEdge {
  cursor: String!
  node: TraceService!
}

input TraceServiceItemsFilter {
  nameStartsWith: String
  name: String
}

input TraceServiceItemsOrderBy {
  direction: TraceSortDirection! = ASC
  sort: TraceServiceItemsSort! = NAME
}

enum TraceServiceItemsSort {
  NAME
  LAST_SEEN
  COUNT
}

enum TraceSortDirection {
  ASC
  DESC
}

interface TraceSpan {
  id: ID!
  transaction: String
  traceId: String!
  parentSpanId: String
  spanId: String!
  spanType: String!
  start: String!
  end: String!
  relativeStartTime: Int!
  duration: TraceDuration!
  durationPercent: Float
  selfDurationTime: Int!
  selfDurationPercent: Float!
  label: String!
  service: String!
  serviceEntityId: String!
  hostname: String!
  hostEntityId: String!
  errorRaised: Boolean!
  errorPropagated: Boolean!
  language: String
  cpuDuration: TraceDuration
  errors: [TraceError!]!
  events: [TraceEvent!]!
  relatedEntities: [SpanRelatedEntity!]
}

type TraceSpanConnection {
  edges: [TraceSpanEdge!]
  pageInfo: PageInfo!
}

type TraceSpanEdge {
  cursor: String!
  node: TraceSpan!
}

interface TraceSpanItem {
  id: ID!
  transaction: String
  traceId: String!
  spanId: String
  service: String!
  serviceEntityId: String!
  websiteId: String
  hostname: String
  hostEntityId: String
  time: String!
  duration: TraceDuration!
}

interface TraceSpanSummary {
  id: ID!
  name: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
}

input TraceTailFilter {
  transaction: String
}

input TraceTailOrderBy {
  sort: TraceTailSort! = START_TIME
  direction: TraceSortDirection! = DESC
}

enum TraceTailSort {
  START_TIME
  END_TIME
}

enum TraceTimeScale {
  NANOSECONDS
  MICROSECONDS
  MILLISECONDS
  SECONDS
  MINUTES
  HOURS
  DAYS
  MONTHS
  YEARS
}

type TraceTransactionConnection {
  edges: [TraceTransactionSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceTransactionSummary implements TraceSpanSummary {
  id: ID!
  name: String
  frequency: TraceFrequency!
  averageDuration: TraceDuration!
  count: String!
  totalDuration: TraceDuration!
}

type TraceTransactionSummaryEdge {
  cursor: String!
  node: TraceTransactionSummary!
}

input TraceTransactionSummaryFilter {
  id: String
  name: String
}

input TraceTransactionSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceTransactionSummarySort! = AVERAGE_DURATION
}

enum TraceTransactionSummarySort {
  NAME
  FREQUENCY
  AVERAGE_DURATION
  COUNT
  TOTAL_DURATION
}

enum TraceType {
  REQUESTS
  QUERIES
  REMOTE_CALLS
  CACHE_CALLS
  EXCEPTIONS
}

type TraceWebsite {
  websiteEntityId: String!
  websiteEntityName: String!
  count: String!
}

type TraceWebsiteSummaryConnection {
  edges: [TraceWebsiteSummaryEdge!]
  pageInfo: PageInfo!
}

type TraceWebsiteSummaryEdge {
  cursor: String!
  node: TraceWebsite!
}

input TraceWebsiteSummaryFilter {
  transactions: [String!]
}

input TraceWebsiteSummaryOrderBy {
  direction: TraceSortDirection! = DESC
  sort: TraceWebsiteSummarySort! = COUNT
}

enum TraceWebsiteSummarySort {
  COUNT
}

"""
Type of traffic:
NorthSouth - going outside of the network
EastWest - traffic inside of the private network
NotClassified - traffic that cannot be classified
All - No filtering
"""
enum TrafficFilter {
  NorthSouth
  EastWest
  NotClassified
  All
}

type TriggerOnDemandCheckError {
  code: Int!
  errorMessage: String!
}

input TriggerOnDemandCheckInput {
  id: ID!
}

union TriggerOnDemandCheckResult = TriggerOnDemandCheckSuccess | TriggerOnDemandCheckError

type TriggerOnDemandCheckSuccess {
  lockReleaseTime: Timestamp!
  onDemandCheckStatus: OnDemandCheckStatus!
}

type TrustedDevice {
  deviceId: String
  userId: String
  userAgent: String
  ipAddress: String
  countryName: String
  lastUsedAt: DateTime
}

type UamsClient {
  id: ID!
  orgId: String
  version: String
  osVersion: String
  architecture: String
  registeredOnUtc: DateTime
  lastSeenUtc: DateTime
  lastSeenOffset: Seconds
  cloudInstanceId: String
  cloudInstanceZone: String
  cloudProvider: String
  containerId: String
  hostName: String
  listOfMacAddresses: [String]
  serialNumber: String
  autoUpdateEnabled: Boolean
  deploymentStatus: DeploymentStatus
  lastErrorMessage: String
  installedPlugins: [PluginInfo]
  isConnected: Boolean
  environmentInfo: String
  roles: [Role]
  logCollectionStatus: UamsClientLogCollectionStatus
}

enum UamsClientLogCollectionStatus {
  NONE
  PENDING
  READY
  TIMED_OUT
}

"""UAMS entity extension for Host"""
type UAMSHostExtension {
  """UAMS client Id"""
  uamsClientId: String!

  """Host Id"""
  hostId: String

  """Entity name"""
  name: String!

  """Os type"""
  osType: String

  """Total CPU seconds broken down by different states"""
  cpuTime: Metric!

  """Percentage of CPU time broken down by different states"""
  cpuUtilization: Metric!

  """Average CPU Load over 1 minute"""
  cpuLoadAverage1m: Metric!

  """Average CPU Load over 5 minutes"""
  cpuLoadAverage5m: Metric!

  """Average CPU Load over 15 minutes"""
  cpuLoadAverage15m: Metric!

  """Disk bytes transferred"""
  diskIo: Metric!

  """
  Time disk spent activated. On Windows, this is calculated as the inverse of disk idle time.
  """
  diskIoTime: Metric!

  """Disk operations count"""
  diskOperations: Metric!

  """Time spent in disk operations"""
  diskOperationsTime: Metric!

  """The queue size of pending I/O operations"""
  diskPendingOperations: Metric!

  """Filesystem bytes used"""
  filesystemUsage: Metric!

  """Bytes of memory in use"""
  memoryUsage: Metric!

  """Percentage of memory bytes in use"""
  memoryUtilization: Metric!

  """The number of connections"""
  networkConnections: Metric!

  """The number of packets dropped"""
  networkDropped: Metric!

  """The number of errors encountered"""
  networkErrors: Metric!

  """The number of bytes transmitted and received"""
  networkIo: Metric!

  """The number of packets transferred"""
  networkPackets: Metric!

  """The number of paging operations"""
  pagingOperations: Metric!

  """Swap (unix) or pagefile (windows) usage"""
  pagingUsage: Metric!
}

input UnobserveDatabaseRequest {
  databaseInstanceID: String!
}

type UnobserveDatabaseResponse {
  code: String!
  message: String
}

input UpdateAwsCloudAccountConfigurationInput {
  enabled: Boolean
  metricsTag: String
  arn: String
  regions: [String!]
  services: [String!]
}

input UpdateAwsCloudAccountInput {
  sessionId: Guid
  entityId: String!
  displayName: String
  configuration: UpdateAwsCloudAccountConfigurationInput
}

type UpdateAwsCloudAccountResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
}

input UpdateAzureCloudAccountConfigurationInput {
  enabled: Boolean
  metricsTag: String
  subscriptions: [AzureSubscriptionInput!]
}

input UpdateAzureCloudAccountInput {
  entityId: String!
  displayName: String
  configuration: UpdateAzureCloudAccountConfigurationInput
}

type UpdateAzureCloudAccountResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
}

input UpdateAzureIntegrationInput {
  entityId: String!
  displayName: String
  metricsTag: String
  enabled: Boolean
  credential: AzureCredentialInput
  subscription: AzureSubscriptionInput
}

type UpdateAzureIntegrationResponse implements MutationResponseInterface {
  success: Boolean!
  message: String!
  code: String!
}

input UpdateCategoryInput {
  id: ID!
  name: String!
}

type UpdateCategoryResponse {
  code: String!
  success: Boolean!
  message: String!
  category: DashboardCategory
}

input UpdateDashboardInput {
  id: ID!
  name: String!
  description: String
  isPrivate: Boolean
  categoryId: ID
  widgets: [WidgetInput!]!
  layout: [LayoutInput!]!
}

type UpdateDashboardResponse {
  code: String!
  success: Boolean!
  message: String!
  dashboard: Dashboard
}

input UpdateDatabaseRequest {
  databaseInstanceID: String!
  name: String
  description: String
  bindings: [String!]
  options: [KeyValue!]
  credentials: [KeyValue!]
}

type UpdateDatabaseResponse {
  code: String!
  message: String
}

union UpdateEntityGroupResult = UpdateEntityGroupSuccess | EntityGroupMutationError

type UpdateEntityGroupSuccess {
  """Updated entity group"""
  entityGroup: EntityGroup!
}

input UpdateExclusionFilterExpressionInput {
  kind: ExclusionFilterExpressionKind!
  expression: String!
}

input UpdateExclusionFilterInput {
  id: ID!
  name: String!
  enabled: Boolean!
  description: String!
  expressions: [UpdateExclusionFilterExpressionInput!]!
}

input UpdateLogArchiveProviderStatusInput {
  provider: LogArchiveProvider!
  isEnabled: Boolean!
}

type UpdateLogArchiveProviderStatusResponse implements LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  success: Boolean!
  message: String!
}

input UpdateLogArchiveStorageInput {
  name: String!
  provider: LogArchiveProvider!
  enabled: Boolean!
  storage: String!
  region: String!
  prefix: String!
}

type UpdateLogArchiveStorageResponse implements LogArchiveResponseInterface {
  code: LogArchiveResponseCode!
  success: Boolean!
  message: String!
}

input UpdateLogFilterInput {
  id: ID!
  name: String!
  description: String
  expressions: [LogFilterExpressionInput!]!
  groupIds: [ID!]!
  global: Boolean!
}

type UpdateLogFilterResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  logFilter: LogFilter
}

input UpdateLogGroupInput {
  id: ID!
  name: String!
  description: String
  syslogHosts: [String!]
  syslogApps: [String!]
  tags: [String!]
  httpHosts: [String!]
}

input UpdateLogSearchInput {
  id: ID!
  query: String!
}

type UpdateMemberRolesResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  member: OrganizationMember
}

input UpdateMfaSettingsInput {
  enabled: Boolean!
  logoutUsers: Boolean
  lifespan: Int
}

input UpdateNotificationServiceConfigurationInput {
  id: ID!
  title: String
  description: String
  settings: JSON
}

type UpdateNotificationServiceConfigurationResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  configuration: NotificationService
}

type UpdateOrganizationAttributesResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  invalidFields: [InvalidField!]
  organization: Organization
}

input UpdateSamlConfigurationInput {
  identityProvider: SamlIdentityProviderInput
  enabled: Boolean
  groupMapping: SamlGroupMappingConfigurationInput
}

input UpdateSamlGroupMappingInput {
  orgRoles: [SamlRolesGroupInput]
}

input UpdateSamlServiceAccountsInput {
  serviceAccounts: [String!]!
}

input UpdateSavedSearchInput {
  id: ID!
  name: String
  query: String
  isPrivate: Boolean
  objectId: String
  updateLastSearchAt: Boolean!
}

type UpdateSavedSearchResponse {
  code: String!
  success: Boolean!
  message: String!
  savedSearch: SavedSearch
}

input UpdateSessionTimeoutInput {
  """number of seconds until session is expired"""
  timeout: Int!
}

input UpdateTokenInput {
  id: ID!
  name: String
  accessLevel: TokenAccessLevel
  enabled: Boolean
  type: String
}

type UpdateTokenResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  token: Token
}

input UpdateUserAttributeInput {
  id: String!
  value: String!
}

type UpdateUserAttributeResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  userAttribute: UserAttribute
}

type UpdateUserAttributesResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  invalidFields: [InvalidField!]
  user: User
}

type UpdateUserEmailResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  invalidField: String
  user: User
}

type UpdateUserPasswordResponse implements MutationResponseInterface {
  code: String!
  success: Boolean!
  message: String!
  invalidField: String
}

input UpdateUserTrustedDeviceInput {
  userId: String!
  deviceId: String!
}

input UpdateWebsiteInput {
  id: ID!
  name: String!
  url: String!
  options: MonitoringOptionsInput!
  availability: AvailabilityMonitoringInput!
  rum: RumMonitoringInput
  customHeaders: [CustomHeaderInput!]
}

union UpdateWebsiteResult = UpdateWebsiteSuccess | WebsiteInputValidationError

type UpdateWebsiteSuccess {
  website: Website!
}

type User implements SwicusUser {
  id: ID!
  email: String!
  firstName: String
  lastName: String
  lastLogin: DateTime
  emailVerified: Boolean!
  timezone: String
}

union UserAttribute = AttributeString | AttributeInt | AttributeFloat | AttributeBool | AttributeJson

input UserAttributesInput {
  firstName: String
  lastName: String
  timezone: String
}

input UserEmailInput {
  email: String!
  password: String!
}

input UserPasswordInput {
  currentPassword: String!
  newPassword: String!
}

interface Validation {
  type: ValidationType!
  status: ValidationStatus!
}

"""Error that occurred during validation."""
type ValidationResult {
  """Validation message"""
  message: String!

  """Name of property that caused the error"""
  propertyName: String

  """Value of the property that caused the error"""
  invalidValue: String
}

enum ValidationStatus {
  SUCCESS
  WARNING
  FAILURE
  SKIPPED
}

enum ValidationType {
  CERTIFICATES
  CONTAINS_STRING
  NOT_CONTAINS_STRING
}

"""Virtual Routing Forwarding (VRF) entity"""
type VirtualRoutingForwarding implements Entity {
  """Unique identifier of an entity."""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name."""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Orion VRF Uri"""
  uri: String!

  """Relation: Network Device to VirtualRoutingForwarding"""
  networkDevice: NetworkDevice
}

enum Visibility {
  Show
  Hide
  Collapse
}

type VisibilitySettings {
  time: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  source: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  program: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
  severity: Visibility! @deprecated(reason: "No longer needed for resolver. Handled on client-side.")
}

enum VolumetricsField {
  NAMESPACE
  ENTITY_TYPE
  LOG_TYPE
  TAG
  CATEGORY
}

input VolumetricsFilterBy {
  kind: VolumetricsField!
  value: String!
}

enum VolumetricsMeasurementType {
  VOLUME_BYTES
  LATENCY_MILLIS
  COUNT
}

type VolumetricsResponse {
  results: [VolumetricsResult!]!
  totalResults: Int!
}

type VolumetricsResult {
  name: String!
  summary: TimeSeriesSample!
  timeseries: [TimeSeriesSample!]!
  categories: [String!]
  entityTypes: [String!]
  namespace: String
  logTypes: [String!]
}

input VolumetricsSummaryInput {
  filterBy: [VolumetricsFilterBy!]!
  groupBy: [VolumetricsField!]!
  category: String!
  measurementType: VolumetricsMeasurementType!
  startTimestamp: Timestamp!
  endTimestamp: Timestamp!
  limit: Int
  groupIds: [ID!]
}

type VolumetricsSummaryResponse {
  results: [VolumetricsSummaryResult!]!
}

type VolumetricsSummaryResult {
  name: String!
  summary: TimeSeriesSample!
  categories: [String!]
  entityTypes: [String!]
  namespace: String
  logTypes: [String!]
}

input VolumetricsTimeseriesInput {
  filterBy: [VolumetricsFilterBy!]!
  groupBy: [VolumetricsField!]!
  category: String!
  measurementType: VolumetricsMeasurementType!
  startTimestamp: Timestamp!
  endTimestamp: Timestamp!
  limit: Int
  groupIds: [ID!]
  zeroFill: Boolean
}

type VolumetricsTimeseriesResponse {
  results: [VolumetricsTimeseriesResult!]!
}

type VolumetricsTimeseriesResult {
  name: String!
  timeseries: [TimeSeriesSample!]!
  categories: [String!]
  entityTypes: [String!]
  namespace: String
  logTypes: [String!]
}

input VolumetricsTotalInput {
  groupBy: VolumetricsField!
  startTimestamp: Timestamp!
  endTimestamp: Timestamp!
}

type VolumetricsTotalResponse {
  totalResults: Int!
}

type WaterfallErrorItem {
  spanId: ID!
  message: String!
  timestamp: String!
  exceptionClassMessageHash: String
}

type WaterfallItem {
  spanId: ID!
  layer: String!
  startTime: String!
  endTime: String!
  service: String!
  error: [WaterfallErrorItem!]!
  async: Boolean!
}

type WaterfallRow {
  parentId: ID
  items: [WaterfallItem!]
}

"""Website entity"""
type Website implements Entity & HealthEntity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Relation: Website to Service"""
  services: [Service!]
  healthScore: HealthScore
  httpResponseTime: Metric!
  httpsResponseTime: Metric!
  url: String!

  """Collection of website features e.g. [Synthetic, RUM]"""
  features: [String!]
  synthetics: WebsiteSynthetics
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
  lockReleaseTime: Timestamp
  monitoring: WebsiteMonitoring
  availabilityTestAnalysis: AvailabilityTestAnalysisQueries
  availabilityTestValidations: AvailabilityTestValidationsQueries
  mockPerformanceTests: MockPerformanceTestMetric
}

type WebsiteExploit {
  asset: String!
  severity: String!
  facet: String!
  observation: String!
  age: Int!
  lastSeen: String!
}

type WebsiteExploitSummary {
  total: Int!
  high: Int!
  medium: Int!
  low: Int!
}

type WebsiteInputValidationError {
  nameExists: Boolean
}

type WebsiteMonitoring {
  options: MonitoringOptions
  availability: AvailabilityMonitoring
  rum: RumMonitoring
  customHeaders: [CustomHeader!]
}

enum WebsiteProtocol {
  HTTP
  HTTPS
}

"""Aggregated metrics for Website availability"""
type WebsiteSynthetics {
  """Aggregated average value of httpResponseTime for filtering purposes"""
  avgHttpResponseTime: Float!

  """Aggregated average value of httpsResponseTime for filtering purposes"""
  avgHttpsResponseTime: Float!

  """Aggregated count of performed availability tests"""
  attempts: Int!

  """Aggregated count of successful availability tests"""
  successes: Int!

  """Aggregated count of failed availability tests"""
  errors: Int!

  """Aggregated percentage of successful availability tests"""
  successRate: Float!

  """Aggregated percentage of failed availability tests"""
  errorRate: Float!

  """Aggregated percentage of successful availability tests"""
  availability: Float!
}

type Widget {
  id: ID!
  type: String!
  title: String
  properties: JSON
}

input WidgetInput {
  id: ID!
  title: String
  type: String!
  properties: JSON
}

type WidgetQueries {
  search(inputs: SearchWidgetsInput!): [Widget!]!
}

"""Base interface for Access Point entities"""
interface WirelessAccessPoint {
  """
  Universal Resource Identifier of Access Point within Orion. Serves as a natural key.
  """
  uri: String!

  """IP address"""
  ipAddress: String

  """Relation: Wireless Interfaces of Access Point"""
  interfaces: [WirelessInterface]
}

"""Thin Access Point"""
type WirelessClient implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Universal Resource Identifier of Wireless Client within Orion"""
  uri: String!

  """Wireless client network name"""
  ssid: String!

  """Wireless client IP Address"""
  ipAddress: String

  """Wireless client physical address"""
  mac: String

  """Wireless client connected date time"""
  connectedTime: String

  """Wireless client signal strength"""
  signalStrength: Metric!

  """Wireless client data rate in MBps"""
  outDataRate: Metric!

  """Wireless bytes received in bytes"""
  inTotalBytes: Metric!

  """Wireless bytes transmitted in bytes"""
  outTotalBytes: Metric!

  """Relation: Parent Wireless Interface where the client is connected to"""
  interface: WirelessInterface
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}

type WirelessControllerNetworkDeviceExtension {
  """Number of thin access points"""
  thinAccessPointsCount: Int

  """Relation: Thin Access Points managed by this controller"""
  thinAccessPoints: [ThinAccessPoint]
}

"""Thin Access Point"""
type WirelessInterface implements Entity & AlertingEntity {
  """Unique identifier of an entity"""
  id: ID!

  """Entity type."""
  type: String!

  """Entity name"""
  name: String

  """
  Entity display name / alias. This value is equal to `name` unless it's explicitly overriden. 
  """
  displayName: String

  """Date and time of entity creation in UTC."""
  createdTime: String

  """Date and time of last entity update in UTC."""
  updatedTime: String

  """Date and time when the entity has last received telemetry in UTC."""
  lastSeenTime: String

  """
  How long the entity may not be receiving updates/telemetry before it should be considered "unknown".
  The platform may stop doing certain things with the entity when it is in unknown state.
  """
  maxUnknownPeriodMinutes: Int

  """
  Flag telling if given entity is in unknown state. 
  Entity gets to unknown state if it doesn't receive eny telemetry for more than 'maxUnknownPeriodMinutes'.
  """
  isUnknown: Boolean

  """Set of fields to get to things related to a given entity"""
  related: RelatedEntityFields

  """List of entity extensions that are currently set on given entity"""
  extensions: [String!]

  """Universal Resource Identifier of Wireless Interface within Orion"""
  uri: String!

  """Wireless network name"""
  ssid: String

  """Physical address"""
  mac: String

  """Wireless channel"""
  channel: Int

  """Radio type (802.11g, ...)"""
  radioType: String

  """Relation: Clients connected to interface"""
  clients: [WirelessClient]
  alertEvaluationsV2: [AlertConditionEvaluationV2!]!
}